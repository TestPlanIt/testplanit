{
  "version": 3,
  "sources": ["../../lib/prismaBase.ts", "../../workers/emailWorker.ts", "../../lib/valkey.ts", "../../lib/queues.ts", "../../lib/queueNames.ts", "../../lib/email/notificationTemplates.ts", "../../lib/email/template-service.ts", "../../lib/server-date-formatter.ts", "../../lib/server-translations.ts", "../../utils/tiptapToHtml.ts", "../../lib/multiTenantPrisma.ts"],
  "sourcesContent": ["// lib/prismaBase.ts\n// Base Prisma client without Elasticsearch sync extensions\n// Use this for workers and services that don't need auto-ES sync\n\nimport { PrismaClient } from \"@prisma/client\";\n\n// Declare global types\ndeclare global {\n  var prismaBase: PrismaClient | undefined;\n}\n\nlet prismaClient: PrismaClient;\n\n// Create a simple PrismaClient without extensions\nif (process.env.NODE_ENV === \"production\") {\n  prismaClient = new PrismaClient({ errorFormat: \"pretty\" });\n} else {\n  // Reuse global instance in development to prevent hot-reload issues\n  if (!global.prismaBase) {\n    global.prismaBase = new PrismaClient({ errorFormat: \"colorless\" });\n  }\n  prismaClient = global.prismaBase;\n}\n\nexport const prisma = prismaClient;\n", "import { Worker, Job } from \"bullmq\";\nimport valkeyConnection from \"../lib/valkey\";\nimport { EMAIL_QUEUE_NAME } from \"../lib/queues\";\nimport {\n  sendNotificationEmail,\n  sendDigestEmail,\n} from \"../lib/email/notificationTemplates\";\nimport { pathToFileURL } from \"node:url\";\nimport {\n  getServerTranslation,\n  getServerTranslations,\n  formatLocaleForUrl,\n} from \"../lib/server-translations\";\nimport { tiptapToHtml, isTipTapContent } from \"../utils/tiptapToHtml\";\nimport {\n  getPrismaClientForJob,\n  isMultiTenantMode,\n  MultiTenantJobData,\n  disconnectAllTenantClients,\n  validateMultiTenantJobData,\n  getTenantConfig,\n} from \"../lib/multiTenantPrisma\";\n\ninterface SendNotificationEmailJobData extends MultiTenantJobData {\n  notificationId: string;\n  userId: string;\n  immediate: boolean;\n}\n\ninterface SendDigestEmailJobData extends MultiTenantJobData {\n  userId: string;\n  notifications: Array<{\n    id: string;\n    title: string;\n    message: string;\n    createdAt: Date;\n    url?: string;\n  }>;\n}\n\nconst processor = async (job: Job) => {\n  console.log(`Processing email job ${job.id} of type ${job.name}${job.data.tenantId ? ` for tenant ${job.data.tenantId}` : \"\"}`);\n\n  // Validate multi-tenant job data if in multi-tenant mode\n  validateMultiTenantJobData(job.data);\n\n  // Get the appropriate Prisma client (tenant-specific or default)\n  const prisma = getPrismaClientForJob(job.data);\n\n  switch (job.name) {\n    case \"send-notification-email\":\n      const notificationData = job.data as SendNotificationEmailJobData;\n\n      try {\n        // Get notification details with user preferences\n        const notification = await prisma.notification.findUnique({\n          where: { id: notificationData.notificationId },\n          include: {\n            user: {\n              include: {\n                userPreferences: true,\n              },\n            },\n          },\n        });\n\n        if (!notification || !notification.user.email) {\n          console.log(\"Notification or user email not found\");\n          return;\n        }\n\n        // Build notification URL based on type and data\n        let notificationUrl: string | undefined;\n        // In multi-tenant mode, use the tenant's baseUrl from config; otherwise fall back to NEXTAUTH_URL\n        const tenantConfig = notificationData.tenantId ? getTenantConfig(notificationData.tenantId) : undefined;\n        const baseUrl = tenantConfig?.baseUrl || process.env.NEXTAUTH_URL || \"http://localhost:3000\";\n        const userLocale = notification.user.userPreferences?.locale || \"en_US\";\n        const urlLocale = formatLocaleForUrl(userLocale);\n\n        // Parse notification data if it exists\n        const data = (notification.data as any) || {};\n\n        if (notification.type === \"WORK_ASSIGNED\" && !data.isBulkAssignment) {\n          // Test run case assignment\n          if (data.projectId && data.testRunId && data.testCaseId) {\n            notificationUrl = `${baseUrl}/${urlLocale}/projects/runs/${data.projectId}/${data.testRunId}?selectedCase=${data.testCaseId}`;\n          }\n        } else if (notification.type === \"SESSION_ASSIGNED\") {\n          // Session assignment\n          if (data.projectId && data.sessionId) {\n            notificationUrl = `${baseUrl}/${urlLocale}/projects/sessions/${data.projectId}/${data.sessionId}`;\n          }\n        } else if (notification.type === \"MILESTONE_DUE_REMINDER\") {\n          // Milestone due reminder\n          if (data.projectId && data.milestoneId) {\n            notificationUrl = `${baseUrl}/${urlLocale}/projects/milestones/${data.projectId}/${data.milestoneId}`;\n          }\n        }\n\n        // Get translated title and message\n        let translatedTitle = notification.title;\n        let translatedMessage = notification.message;\n        let htmlMessage: string | undefined;\n\n        if (notification.type === \"WORK_ASSIGNED\" && !data.isBulkAssignment) {\n          translatedTitle = await getServerTranslation(\n            userLocale,\n            \"components.notifications.content.testCaseAssignmentTitle\"\n          );\n          translatedMessage = `${data.assignedByName} ${await getServerTranslation(userLocale, \"components.notifications.content.assignedTestCase\")} \"${data.testCaseName}\" ${await getServerTranslation(userLocale, \"components.notifications.content.inProject\")} \"${data.projectName}\"`;\n        } else if (\n          notification.type === \"WORK_ASSIGNED\" &&\n          data.isBulkAssignment\n        ) {\n          translatedTitle = await getServerTranslation(\n            userLocale,\n            \"components.notifications.content.multipleTestCaseAssignmentTitle\"\n          );\n          translatedMessage = `${data.assignedByName} ${await getServerTranslation(userLocale, \"components.notifications.content.assignedMultipleTestCases\", { count: data.count })}`;\n        } else if (notification.type === \"SESSION_ASSIGNED\") {\n          translatedTitle = await getServerTranslation(\n            userLocale,\n            \"components.notifications.content.sessionAssignmentTitle\"\n          );\n          translatedMessage = `${data.assignedByName} ${await getServerTranslation(userLocale, \"components.notifications.content.assignedSession\")} \"${data.sessionName || data.entityName}\" ${await getServerTranslation(userLocale, \"components.notifications.content.inProject\")} \"${data.projectName}\"`;\n        } else if (notification.type === \"COMMENT_MENTION\") {\n          translatedTitle = await getServerTranslation(\n            userLocale,\n            \"components.notifications.content.commentMentionTitle\"\n          );\n          translatedMessage = `${data.creatorName} ${await getServerTranslation(userLocale, \"components.notifications.content.mentionedYouInComment\")} \"${data.entityName}\" ${await getServerTranslation(userLocale, \"components.notifications.content.inProject\")} \"${data.projectName}\"`;\n\n          // Build notification URL based on entity type\n          if (data.projectId && data.hasProjectAccess) {\n            if (data.entityType === \"RepositoryCase\" && data.repositoryCaseId) {\n              notificationUrl = `${baseUrl}/${urlLocale}/projects/repository/${data.projectId}/${data.repositoryCaseId}`;\n            } else if (data.entityType === \"TestRun\" && data.testRunId) {\n              notificationUrl = `${baseUrl}/${urlLocale}/projects/runs/${data.projectId}/${data.testRunId}`;\n            } else if (data.entityType === \"Session\" && data.sessionId) {\n              notificationUrl = `${baseUrl}/${urlLocale}/projects/sessions/${data.projectId}/${data.sessionId}`;\n            } else if (data.entityType === \"Milestone\" && data.milestoneId) {\n              notificationUrl = `${baseUrl}/${urlLocale}/projects/milestones/${data.projectId}/${data.milestoneId}`;\n            }\n          }\n        } else if (notification.type === \"SYSTEM_ANNOUNCEMENT\") {\n          // For system announcements, check if we have rich content or raw HTML\n          if (data.htmlContent) {\n            // Use raw HTML content (e.g., from upgrade notifications)\n            htmlMessage = data.htmlContent;\n          } else if (data.richContent && isTipTapContent(data.richContent)) {\n            htmlMessage = tiptapToHtml(data.richContent);\n          }\n          // Add sender info to the message if not using HTML\n          if (!htmlMessage && data.sentByName) {\n            translatedMessage += `\\n\\n${await getServerTranslation(userLocale, \"components.notifications.content.sentBy\", { name: data.sentByName })}`;\n          }\n        } else if (notification.type === \"MILESTONE_DUE_REMINDER\") {\n          // Milestone due reminder\n          const isOverdue = data.isOverdue === true;\n          translatedTitle = await getServerTranslation(\n            userLocale,\n            isOverdue\n              ? \"components.notifications.content.milestoneOverdueTitle\"\n              : \"components.notifications.content.milestoneDueSoonTitle\"\n          );\n          const formattedDueDate = data.dueDate\n            ? new Date(data.dueDate).toLocaleDateString(userLocale.replace(\"_\", \"-\"))\n            : \"\";\n          translatedMessage = await getServerTranslation(\n            userLocale,\n            isOverdue\n              ? \"components.notifications.content.milestoneOverdue\"\n              : \"components.notifications.content.milestoneDueSoon\",\n            { milestoneName: data.milestoneName, projectName: data.projectName, dueDate: formattedDueDate }\n          );\n        }\n\n        // Get email template translations\n        const emailTranslations = await getServerTranslations(userLocale, [\n          \"email.greeting\",\n          \"email.greetingWithName\",\n          \"email.notification.intro\",\n          \"email.notification.viewDetails\",\n          \"email.notification.viewAll\",\n          \"email.footer.sentBy\",\n          \"email.footer.unsubscribe\",\n          \"email.footer.managePreferences\",\n          \"email.footer.allRightsReserved\",\n        ]);\n\n        // Build additional info for milestone notifications\n        let additionalInfo: string | undefined;\n        if (notification.type === \"MILESTONE_DUE_REMINDER\") {\n          const reasonMessage = await getServerTranslation(\n            userLocale,\n            \"components.notifications.content.milestoneNotificationReason\"\n          );\n          const continueMessage = await getServerTranslation(\n            userLocale,\n            \"components.notifications.content.milestoneNotificationContinue\"\n          );\n          additionalInfo = `${reasonMessage} ${continueMessage}`;\n        }\n\n        await sendNotificationEmail({\n          to: notification.user.email,\n          userId: notification.userId,\n          userName: notification.user.name,\n          notificationTitle: translatedTitle,\n          notificationMessage: translatedMessage,\n          notificationUrl,\n          locale: urlLocale,\n          translations: emailTranslations,\n          htmlMessage,\n          baseUrl,\n          additionalInfo,\n        });\n\n        console.log(`Sent notification email to ${notification.user.email}`);\n      } catch (error) {\n        console.error(`Failed to send notification email:`, error);\n        throw error;\n      }\n      break;\n\n    case \"send-digest-email\":\n      const digestData = job.data as SendDigestEmailJobData;\n\n      try {\n        // Get user details with preferences\n        const user = await prisma.user.findUnique({\n          where: { id: digestData.userId },\n          include: {\n            userPreferences: true,\n          },\n        });\n\n        if (!user || !user.email) {\n          console.log(\"User or email not found\");\n          return;\n        }\n\n        // Fetch full notification data to build URLs\n        const fullNotifications = await prisma.notification.findMany({\n          where: {\n            id: { in: digestData.notifications.map((n) => n.id) },\n          },\n        });\n\n        // Build URLs and translate content for each notification\n        // In multi-tenant mode, use the tenant's baseUrl from config\n        const digestTenantConfig = digestData.tenantId ? getTenantConfig(digestData.tenantId) : undefined;\n        const digestBaseUrl = digestTenantConfig?.baseUrl || process.env.NEXTAUTH_URL || \"http://localhost:3000\";\n        const notificationsWithUrls = await Promise.all(\n          fullNotifications.map(async (notification: any) => {\n            const baseUrl = digestBaseUrl;\n            const userLocale = user.userPreferences?.locale || \"en_US\";\n            const urlLocale = formatLocaleForUrl(userLocale);\n            const data = (notification.data as any) || {};\n            let url: string | undefined;\n\n            if (\n              notification.type === \"WORK_ASSIGNED\" &&\n              !data.isBulkAssignment\n            ) {\n              if (data.projectId && data.testRunId && data.testCaseId) {\n                url = `${baseUrl}/${urlLocale}/projects/runs/${data.projectId}/${data.testRunId}?selectedCase=${data.testCaseId}`;\n              }\n            } else if (notification.type === \"SESSION_ASSIGNED\") {\n              if (data.projectId && data.sessionId) {\n                url = `${baseUrl}/${urlLocale}/projects/sessions/${data.projectId}/${data.sessionId}`;\n              }\n            } else if (notification.type === \"COMMENT_MENTION\") {\n              // Build URL based on entity type\n              if (data.projectId && data.hasProjectAccess) {\n                if (data.entityType === \"RepositoryCase\" && data.repositoryCaseId) {\n                  url = `${baseUrl}/${urlLocale}/projects/repository/${data.projectId}/${data.repositoryCaseId}`;\n                } else if (data.entityType === \"TestRun\" && data.testRunId) {\n                  url = `${baseUrl}/${urlLocale}/projects/runs/${data.projectId}/${data.testRunId}`;\n                } else if (data.entityType === \"Session\" && data.sessionId) {\n                  url = `${baseUrl}/${urlLocale}/projects/sessions/${data.projectId}/${data.sessionId}`;\n                } else if (data.entityType === \"Milestone\" && data.milestoneId) {\n                  url = `${baseUrl}/${urlLocale}/projects/milestones/${data.projectId}/${data.milestoneId}`;\n                }\n              }\n            } else if (notification.type === \"MILESTONE_DUE_REMINDER\") {\n              // Milestone due reminder\n              if (data.projectId && data.milestoneId) {\n                url = `${baseUrl}/${urlLocale}/projects/milestones/${data.projectId}/${data.milestoneId}`;\n              }\n            }\n\n            // Get translated title and message\n            let translatedTitle = notification.title;\n            let translatedMessage = notification.message;\n\n            if (\n              notification.type === \"WORK_ASSIGNED\" &&\n              !data.isBulkAssignment\n            ) {\n              translatedTitle = await getServerTranslation(\n                userLocale,\n                \"components.notifications.content.testCaseAssignmentTitle\"\n              );\n              translatedMessage = `${data.assignedByName} ${await getServerTranslation(userLocale, \"components.notifications.content.assignedTestCase\")} \"${data.testCaseName}\" ${await getServerTranslation(userLocale, \"components.notifications.content.inProject\")} \"${data.projectName}\"`;\n            } else if (\n              notification.type === \"WORK_ASSIGNED\" &&\n              data.isBulkAssignment\n            ) {\n              translatedTitle = await getServerTranslation(\n                userLocale,\n                \"components.notifications.content.multipleTestCaseAssignmentTitle\"\n              );\n              translatedMessage = `${data.assignedByName} ${await getServerTranslation(userLocale, \"components.notifications.content.assignedMultipleTestCases\", { count: data.count })}`;\n            } else if (notification.type === \"SESSION_ASSIGNED\") {\n              translatedTitle = await getServerTranslation(\n                userLocale,\n                \"components.notifications.content.sessionAssignmentTitle\"\n              );\n              translatedMessage = `${data.assignedByName} ${await getServerTranslation(userLocale, \"components.notifications.content.assignedSession\")} \"${data.sessionName || data.entityName}\" ${await getServerTranslation(userLocale, \"components.notifications.content.inProject\")} \"${data.projectName}\"`;\n            } else if (notification.type === \"COMMENT_MENTION\") {\n              translatedTitle = await getServerTranslation(\n                userLocale,\n                \"components.notifications.content.commentMentionTitle\"\n              );\n              translatedMessage = `${data.creatorName} ${await getServerTranslation(userLocale, \"components.notifications.content.mentionedYouInComment\")} \"${data.entityName}\" ${await getServerTranslation(userLocale, \"components.notifications.content.inProject\")} \"${data.projectName}\"`;\n            } else if (notification.type === \"MILESTONE_DUE_REMINDER\") {\n              const isOverdue = data.isOverdue === true;\n              translatedTitle = await getServerTranslation(\n                userLocale,\n                isOverdue\n                  ? \"components.notifications.content.milestoneOverdueTitle\"\n                  : \"components.notifications.content.milestoneDueSoonTitle\"\n              );\n              const formattedDueDate = data.dueDate\n                ? new Date(data.dueDate).toLocaleDateString(userLocale.replace(\"_\", \"-\"))\n                : \"\";\n              translatedMessage = await getServerTranslation(\n                userLocale,\n                isOverdue\n                  ? \"components.notifications.content.milestoneOverdue\"\n                  : \"components.notifications.content.milestoneDueSoon\",\n                { milestoneName: data.milestoneName, projectName: data.projectName, dueDate: formattedDueDate }\n              );\n            }\n\n            return {\n              id: notification.id,\n              title: translatedTitle,\n              message: translatedMessage,\n              createdAt: notification.createdAt,\n              url,\n            };\n          })\n        );\n\n        // Get email template translations\n        const digestUserLocale = user.userPreferences?.locale || \"en_US\";\n        const digestTranslations = await getServerTranslations(\n          digestUserLocale,\n          [\n            \"email.greeting\",\n            \"email.greetingWithName\",\n            \"email.digest.intro\",\n            \"email.digest.viewDetails\",\n            \"email.digest.viewAll\",\n            \"email.digest.noNotifications\",\n            \"email.digest.footer\",\n            \"email.digest.profileSettings\",\n            \"email.footer.sentBy\",\n            \"email.footer.unsubscribe\",\n            \"email.footer.managePreferences\",\n            \"email.footer.allRightsReserved\",\n          ]\n        );\n\n        await sendDigestEmail({\n          to: user.email,\n          userId: user.id,\n          userName: user.name,\n          notifications: notificationsWithUrls,\n          locale: formatLocaleForUrl(user.userPreferences?.locale || \"en_US\"),\n          translations: digestTranslations,\n          baseUrl: digestBaseUrl,\n        });\n\n        // Mark notifications as read after sending digest\n        await prisma.notification.updateMany({\n          where: {\n            id: { in: digestData.notifications.map((n) => n.id) },\n          },\n          data: { isRead: true },\n        });\n\n        console.log(\n          `Sent digest email to ${user.email} with ${digestData.notifications.length} notifications`\n        );\n      } catch (error) {\n        console.error(`Failed to send digest email:`, error);\n        throw error;\n      }\n      break;\n\n    default:\n      throw new Error(`Unknown job type: ${job.name}`);\n  }\n};\n\nlet worker: Worker | null = null;\n\n// Function to start the worker\nconst startWorker = async () => {\n  // Log multi-tenant mode status\n  if (isMultiTenantMode()) {\n    console.log(\"Email worker starting in MULTI-TENANT mode\");\n  } else {\n    console.log(\"Email worker starting in SINGLE-TENANT mode\");\n  }\n\n  if (valkeyConnection) {\n    worker = new Worker(EMAIL_QUEUE_NAME, processor, {\n      connection: valkeyConnection,\n      concurrency: 3,\n    });\n\n    worker.on(\"completed\", (job) => {\n      console.log(`Email job ${job.id} completed successfully.`);\n    });\n\n    worker.on(\"failed\", (job, err) => {\n      console.error(`Email job ${job?.id} failed:`, err);\n    });\n\n    worker.on(\"error\", (err) => {\n      console.error(\"Email worker error:\", err);\n    });\n\n    console.log(`Email worker started for queue \"${EMAIL_QUEUE_NAME}\".`);\n  } else {\n    console.warn(\"Valkey connection not available. Email worker not started.\");\n  }\n\n  // Allow graceful shutdown\n  process.on(\"SIGINT\", async () => {\n    console.log(\"Shutting down email worker...\");\n    if (worker) {\n      await worker.close();\n    }\n    // Disconnect all tenant Prisma clients in multi-tenant mode\n    if (isMultiTenantMode()) {\n      await disconnectAllTenantClients();\n    }\n    process.exit(0);\n  });\n};\n\n// Run the worker if this file is executed directly (works with both ESM and CommonJS)\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  (typeof import.meta === \"undefined\" ||\n    (import.meta as any).url === undefined)\n) {\n  console.log(\"Email worker running...\");\n  startWorker().catch((err) => {\n    console.error(\"Failed to start email worker:\", err);\n    process.exit(1);\n  });\n}\n\nexport default worker;\n", "import IORedis from \"ioredis\";\n\n// Check if we should skip Valkey connection (useful during build)\nconst skipConnection = process.env.SKIP_VALKEY_CONNECTION === \"true\";\n\n// Get Valkey URL from environment\nconst valkeyUrl = process.env.VALKEY_URL;\n\nif (!valkeyUrl && !skipConnection) {\n  // Log an error, but maybe don't throw immediately\n  // depending on whether Valkey is strictly required at startup\n  console.error(\n    \"VALKEY_URL environment variable is not set. Background jobs may fail.\"\n  );\n  // Optional: throw new Error('VALKEY_URL environment variable is not set.');\n}\n\n// Configure the connection options\nconst connectionOptions = {\n  maxRetriesPerRequest: null, // Required by BullMQ\n  enableReadyCheck: false, // Optional: Sometimes helps with startup race conditions\n};\n\nlet valkeyConnection: IORedis | null = null;\n\nif (valkeyUrl && !skipConnection) {\n  // Convert valkey:// to redis:// for ioredis compatibility\n  // ioredis expects redis:// protocol but we're connecting to Valkey\n  const connectionUrl = valkeyUrl.replace(/^valkey:\\/\\//, 'redis://');\n  \n  // Create and export the connection instance only if URL is provided\n  valkeyConnection = new IORedis(connectionUrl, connectionOptions);\n\n  valkeyConnection.on(\"connect\", () => {\n    console.log(\"Successfully connected to Valkey.\");\n  });\n\n  valkeyConnection.on(\"error\", (err) => {\n    console.error(\"Valkey connection error:\", err);\n  });\n} else {\n  console.warn(\"Valkey URL not provided. Valkey connection not established.\");\n}\n\nexport default valkeyConnection;", "import { Queue } from \"bullmq\";\nimport valkeyConnection from \"./valkey\";\nimport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n  AUDIT_LOG_QUEUE_NAME,\n} from \"./queueNames\";\n\n// Re-export queue names for backward compatibility\nexport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n  AUDIT_LOG_QUEUE_NAME,\n};\n\n// Lazy-initialized queue instances\nlet _forecastQueue: Queue | null = null;\nlet _notificationQueue: Queue | null = null;\nlet _emailQueue: Queue | null = null;\nlet _syncQueue: Queue | null = null;\nlet _testmoImportQueue: Queue | null = null;\nlet _elasticsearchReindexQueue: Queue | null = null;\nlet _auditLogQueue: Queue | null = null;\n\n/**\n * Get the forecast queue instance (lazy initialization)\n * Only creates the queue when first accessed\n */\nexport function getForecastQueue(): Queue | null {\n  if (_forecastQueue) return _forecastQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${FORECAST_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _forecastQueue = new Queue(FORECAST_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${FORECAST_QUEUE_NAME}\" initialized.`);\n\n  _forecastQueue.on(\"error\", (error) => {\n    console.error(`Queue ${FORECAST_QUEUE_NAME} error:`, error);\n  });\n\n  return _forecastQueue;\n}\n\n/**\n * Get the notification queue instance (lazy initialization)\n */\nexport function getNotificationQueue(): Queue | null {\n  if (_notificationQueue) return _notificationQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${NOTIFICATION_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _notificationQueue = new Queue(NOTIFICATION_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${NOTIFICATION_QUEUE_NAME}\" initialized.`);\n\n  _notificationQueue.on(\"error\", (error) => {\n    console.error(`Queue ${NOTIFICATION_QUEUE_NAME} error:`, error);\n  });\n\n  return _notificationQueue;\n}\n\n/**\n * Get the email queue instance (lazy initialization)\n */\nexport function getEmailQueue(): Queue | null {\n  if (_emailQueue) return _emailQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${EMAIL_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _emailQueue = new Queue(EMAIL_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 5,\n      backoff: {\n        type: \"exponential\",\n        delay: 10000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 5000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${EMAIL_QUEUE_NAME}\" initialized.`);\n\n  _emailQueue.on(\"error\", (error) => {\n    console.error(`Queue ${EMAIL_QUEUE_NAME} error:`, error);\n  });\n\n  return _emailQueue;\n}\n\n/**\n * Get the sync queue instance (lazy initialization)\n */\nexport function getSyncQueue(): Queue | null {\n  if (_syncQueue) return _syncQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${SYNC_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _syncQueue = new Queue(SYNC_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 3,\n        count: 500,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 7,\n      },\n    },\n  });\n\n  console.log(`Queue \"${SYNC_QUEUE_NAME}\" initialized.`);\n\n  _syncQueue.on(\"error\", (error) => {\n    console.error(`Queue ${SYNC_QUEUE_NAME} error:`, error);\n  });\n\n  return _syncQueue;\n}\n\n/**\n * Get the Testmo import queue instance (lazy initialization)\n */\nexport function getTestmoImportQueue(): Queue | null {\n  if (_testmoImportQueue) return _testmoImportQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _testmoImportQueue = new Queue(TESTMO_IMPORT_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 100,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" initialized.`);\n\n  _testmoImportQueue.on(\"error\", (error) => {\n    console.error(`Queue ${TESTMO_IMPORT_QUEUE_NAME} error:`, error);\n  });\n\n  return _testmoImportQueue;\n}\n\n/**\n * Get the Elasticsearch reindex queue instance (lazy initialization)\n */\nexport function getElasticsearchReindexQueue(): Queue | null {\n  if (_elasticsearchReindexQueue) return _elasticsearchReindexQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _elasticsearchReindexQueue = new Queue(ELASTICSEARCH_REINDEX_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 50,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" initialized.`);\n\n  _elasticsearchReindexQueue.on(\"error\", (error) => {\n    console.error(`Queue ${ELASTICSEARCH_REINDEX_QUEUE_NAME} error:`, error);\n  });\n\n  return _elasticsearchReindexQueue;\n}\n\n/**\n * Get the audit log queue instance (lazy initialization)\n * Used for async audit log processing to avoid blocking mutations\n */\nexport function getAuditLogQueue(): Queue | null {\n  if (_auditLogQueue) return _auditLogQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${AUDIT_LOG_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _auditLogQueue = new Queue(AUDIT_LOG_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      // Long retention for audit logs - keep completed jobs for 1 year\n      removeOnComplete: {\n        age: 3600 * 24 * 365, // 1 year\n        count: 100000,\n      },\n      // Keep failed jobs for investigation\n      removeOnFail: {\n        age: 3600 * 24 * 90, // 90 days\n      },\n    },\n  });\n\n  console.log(`Queue \"${AUDIT_LOG_QUEUE_NAME}\" initialized.`);\n\n  _auditLogQueue.on(\"error\", (error) => {\n    console.error(`Queue ${AUDIT_LOG_QUEUE_NAME} error:`, error);\n  });\n\n  return _auditLogQueue;\n}\n\n/**\n * Get all queues (initializes all of them)\n * Use this only when you need access to all queues (e.g., admin dashboard)\n */\nexport function getAllQueues() {\n  return {\n    forecastQueue: getForecastQueue(),\n    notificationQueue: getNotificationQueue(),\n    emailQueue: getEmailQueue(),\n    syncQueue: getSyncQueue(),\n    testmoImportQueue: getTestmoImportQueue(),\n    elasticsearchReindexQueue: getElasticsearchReindexQueue(),\n    auditLogQueue: getAuditLogQueue(),\n  };\n}\n", "// Queue name constants - no initialization, just names\nexport const FORECAST_QUEUE_NAME = \"forecast-updates\";\nexport const NOTIFICATION_QUEUE_NAME = \"notifications\";\nexport const EMAIL_QUEUE_NAME = \"emails\";\nexport const SYNC_QUEUE_NAME = \"issue-sync\";\nexport const TESTMO_IMPORT_QUEUE_NAME = \"testmo-imports\";\nexport const ELASTICSEARCH_REINDEX_QUEUE_NAME = \"elasticsearch-reindex\";\nexport const AUDIT_LOG_QUEUE_NAME = \"audit-logs\";\n", "import nodemailer from \"nodemailer\";\nimport { renderEmailTemplate } from \"./template-service\";\n\ninterface NotificationEmailData {\n  to: string;\n  userId: string;\n  userName: string;\n  notificationTitle: string;\n  notificationMessage: string;\n  notificationUrl?: string;\n  locale?: string;\n  translations?: Record<string, string>;\n  htmlMessage?: string;\n  baseUrl?: string;\n  additionalInfo?: string;\n}\n\ninterface DigestEmailData {\n  to: string;\n  userId: string;\n  userName: string;\n  notifications: Array<{\n    id: string;\n    title: string;\n    message: string;\n    createdAt: Date;\n    url?: string;\n  }>;\n  locale?: string;\n  translations?: Record<string, string>;\n  baseUrl?: string;\n}\n\nconst getTransporter = () => {\n  return nodemailer.createTransport({\n    host: process.env.EMAIL_SERVER_HOST,\n    port: Number(process.env.EMAIL_SERVER_PORT) || 0,\n    auth: {\n      user: process.env.EMAIL_SERVER_USER,\n      pass: process.env.EMAIL_SERVER_PASSWORD,\n    },\n    from: `\"TestPlanIt\" <${process.env.EMAIL_FROM}>`,\n  });\n};\n\nexport async function sendNotificationEmail(data: NotificationEmailData) {\n  const transporter = getTransporter();\n\n  // Render the email using Handlebars template\n  const { html, subject } = await renderEmailTemplate('notification', {\n    userName: data.userName,\n    notification: {\n      title: data.notificationTitle,\n      message: data.notificationMessage,\n      htmlMessage: data.htmlMessage,\n      createdAt: new Date(),\n    },\n    notificationUrl: data.notificationUrl,\n    appUrl: data.baseUrl || process.env.NEXTAUTH_URL || 'http://localhost:3000',\n    locale: data.locale || 'en-US',\n    userId: data.userId,\n    currentYear: new Date().getFullYear(),\n    subject: `TestPlanIt: ${data.notificationTitle}`,\n    translations: data.translations || {},\n    additionalInfo: data.additionalInfo,\n  });\n\n  const emailData = {\n    from: `\"TestPlanIt\" <${process.env.EMAIL_FROM}>`,\n    to: data.to,\n    subject,\n    html,\n  };\n\n  try {\n    await transporter.sendMail(emailData);\n  } catch (error) {\n    console.error(\"Failed to send notification email:\", error);\n    throw error;\n  }\n}\n\nexport async function sendDigestEmail(data: DigestEmailData) {\n  const transporter = getTransporter();\n\n  // Render the email using Handlebars template\n  const { html, subject } = await renderEmailTemplate('daily-digest', {\n    userName: data.userName,\n    notifications: data.notifications,\n    appUrl: data.baseUrl || process.env.NEXTAUTH_URL || 'http://localhost:3000',\n    locale: data.locale || 'en-US',\n    userId: data.userId,\n    currentYear: new Date().getFullYear(),\n    subject: `TestPlanIt Daily Digest - ${data.notifications.length} notifications`,\n    translations: data.translations || {},\n  });\n\n  const emailData = {\n    from: `\"TestPlanIt\" <${process.env.EMAIL_FROM}>`,\n    to: data.to,\n    subject,\n    html,\n  };\n\n  try {\n    await transporter.sendMail(emailData);\n  } catch (error) {\n    console.error(\"Failed to send digest email:\", error);\n    throw error;\n  }\n}", "import Handlebars from 'handlebars';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { formatEmailDate, formatEmailDateTime } from '../server-date-formatter';\n\n// Get the current directory (works in both ESM and CommonJS after build)\n \n// @ts-ignore - __dirname is available in CommonJS after build\nconst currentDir = typeof __dirname !== 'undefined' ? __dirname : path.dirname(fileURLToPath(import.meta.url));\n\n// Template cache to avoid reading files multiple times\nconst templateCache = new Map<string, HandlebarsTemplateDelegate<any>>();\nconst compiledLayouts = new Map<string, HandlebarsTemplateDelegate<any>>();\n\n// Register Handlebars helpers\nHandlebars.registerHelper('formatDate', function(this: any, date: Date | string) {\n  const locale = this.locale || 'en-US';\n  return formatEmailDate(date, locale);\n});\n\nHandlebars.registerHelper('formatDateTime', function(this: any, date: Date | string) {\n  const locale = this.locale || 'en-US';\n  return formatEmailDateTime(date, locale);\n});\n\nHandlebars.registerHelper('eq', (a: any, b: any) => a === b);\nHandlebars.registerHelper('ne', (a: any, b: any) => a !== b);\nHandlebars.registerHelper('gt', (a: any, b: any) => a > b);\nHandlebars.registerHelper('gte', (a: any, b: any) => a >= b);\nHandlebars.registerHelper('lt', (a: any, b: any) => a < b);\nHandlebars.registerHelper('lte', (a: any, b: any) => a <= b);\n\n// Helper to get translation\nHandlebars.registerHelper('t', function(this: any, key: string, options?: any) {\n  // Access translations from root context to handle nested contexts (e.g., inside {{#each}})\n  const translations = (options?.data?.root?.translations || this.translations) || {};\n  const value = translations[key] || key;\n\n  // Handle replacements if options.hash exists\n  if (options && options.hash) {\n    return value.replace(/\\{(\\w+)\\}/g, (match: string, param: string) => {\n      return options.hash[param] !== undefined ? options.hash[param] : match;\n    });\n  }\n\n  return value;\n});\n\n// Helper to load and compile a template\nasync function loadTemplate(templatePath: string): Promise<HandlebarsTemplateDelegate<any>> {\n  const cached = templateCache.get(templatePath);\n  if (cached) {\n    return cached;\n  }\n\n  const templateContent = await fs.readFile(templatePath, 'utf-8');\n  const compiled = Handlebars.compile(templateContent);\n  templateCache.set(templatePath, compiled);\n  return compiled;\n}\n\n// Helper to load and compile layout\nasync function loadLayout(layoutName: string): Promise<HandlebarsTemplateDelegate<any>> {\n  const cached = compiledLayouts.get(layoutName);\n  if (cached) {\n    return cached;\n  }\n\n  const layoutPath = path.join(currentDir, 'templates', 'layouts', `${layoutName}.hbs`);\n  const layoutContent = await fs.readFile(layoutPath, 'utf-8');\n  const compiled = Handlebars.compile(layoutContent);\n  compiledLayouts.set(layoutName, compiled);\n  return compiled;\n}\n\n// Register partials on startup\nexport async function registerPartials() {\n  const partialsDir = path.join(currentDir, 'templates', 'partials');\n  \n  try {\n    const files = await fs.readdir(partialsDir);\n    \n    for (const file of files) {\n      if (file.endsWith('.hbs')) {\n        const partialName = path.basename(file, '.hbs');\n        const partialPath = path.join(partialsDir, file);\n        const partialContent = await fs.readFile(partialPath, 'utf-8');\n        Handlebars.registerPartial(partialName, partialContent);\n      }\n    }\n  } catch (error) {\n    console.warn('No partials directory found or error loading partials:', error);\n  }\n}\n\nexport interface EmailTemplateData {\n  [key: string]: any;\n}\n\nexport interface EmailRenderOptions {\n  layout?: string;\n  subject?: string;\n}\n\n/**\n * Renders an email template with the given data\n * @param templateName Name of the template file (without .hbs extension)\n * @param data Template data\n * @param options Rendering options\n * @returns Rendered HTML string\n */\nexport async function renderEmailTemplate(\n  templateName: string,\n  data: EmailTemplateData,\n  options: EmailRenderOptions = {}\n): Promise<{ html: string; subject: string }> {\n  // Default layout\n  const layoutName = options.layout || 'main';\n  \n  // Load template\n  const templatePath = path.join(currentDir, 'templates', `${templateName}.hbs`);\n  const template = await loadTemplate(templatePath);\n  \n  // Render template content\n  const content = template(data);\n  \n  // Load and render layout with content\n  const layout = await loadLayout(layoutName);\n  const html = layout({\n    ...data,\n    content,\n    subject: options.subject || data.subject || 'TestPlanIt Notification',\n  });\n  \n  return {\n    html,\n    subject: options.subject || data.subject || 'TestPlanIt Notification',\n  };\n}\n\n// Initialize partials when the module is imported\nregisterPartials().catch(console.error);", "import { format } from \"date-fns\";\nimport { enUS } from \"date-fns/locale/en-US\";\nimport { es } from \"date-fns/locale/es\";\nimport { fr } from \"date-fns/locale/fr\";\nimport { Locale } from \"date-fns\";\n\n// Map locales to date-fns locales\nconst localeMap: Record<string, Locale> = {\n  \"en-US\": enUS,\n  \"en_US\": enUS,\n  \"es-ES\": es,\n  \"es_ES\": es,\n  \"fr-FR\": fr,\n  \"fr_FR\": fr,\n};\n\n/**\n * Get date-fns locale from locale string\n */\nexport function getServerDateFnsLocale(locale: string): Locale {\n  // Normalize locale format\n  const normalizedLocale = locale.replace('_', '-');\n  return localeMap[normalizedLocale] || localeMap[locale] || enUS;\n}\n\n/**\n * Format date with locale support\n */\nexport function formatDateWithLocale(\n  date: Date | string,\n  formatString: string,\n  locale: string\n): string {\n  const dateObj = typeof date === 'string' ? new Date(date) : date;\n  const dateLocale = getServerDateFnsLocale(locale);\n  \n  return format(dateObj, formatString, { locale: dateLocale });\n}\n\n/**\n * Format date for display in emails\n */\nexport function formatEmailDate(date: Date | string, locale: string): string {\n  return formatDateWithLocale(date, 'MMMM d, yyyy', locale);\n}\n\n/**\n * Format date and time for display in emails\n */\nexport function formatEmailDateTime(date: Date | string, locale: string): string {\n  // Use localized \"at\" word for different languages\n  const atWordMap: Record<string, string> = {\n    'en': 'at',\n    'es': 'a las',\n    'fr': '\u00E0',\n  };\n\n  const langCode = locale.substring(0, 2);\n  const atWord = atWordMap[langCode] || 'at';\n\n  return formatDateWithLocale(date, `MMMM d, yyyy '${atWord}' hh:mm a`, locale);\n}", "import fs from 'fs/promises';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\n// Get the current directory (works in both ESM and CommonJS after build)\n \n// @ts-ignore - __dirname is available in CommonJS after build\nconst currentDir = typeof __dirname !== 'undefined' ? __dirname : path.dirname(fileURLToPath(import.meta.url));\n\n// Cache for loaded translations\nconst translationCache = new Map<string, any>();\n\n/**\n * Load translations for a specific locale\n */\nasync function loadTranslations(locale: string): Promise<any> {\n  // Normalize locale format (es_ES -> es-ES)\n  const normalizedLocale = locale.replace('_', '-');\n  \n  // Check cache first\n  if (translationCache.has(normalizedLocale)) {\n    return translationCache.get(normalizedLocale);\n  }\n\n  try {\n    // Load the translation file\n    const translationPath = path.join(currentDir, '..', 'messages', `${normalizedLocale}.json`);\n    const translationContent = await fs.readFile(translationPath, 'utf-8');\n    const translations = JSON.parse(translationContent);\n    \n    // Cache the translations\n    translationCache.set(normalizedLocale, translations);\n    \n    return translations;\n  } catch (error) {\n    console.error(`Failed to load translations for locale ${normalizedLocale}:`, error);\n    // Fall back to en-US if locale not found\n    if (normalizedLocale !== 'en-US') {\n      return loadTranslations('en-US');\n    }\n    throw error;\n  }\n}\n\n/**\n * Get a translation value by key path\n */\nfunction getTranslation(translations: any, keyPath: string): string {\n  const keys = keyPath.split('.');\n  let value = translations;\n  \n  for (const key of keys) {\n    if (value && typeof value === 'object' && key in value) {\n      value = value[key];\n    } else {\n      return keyPath; // Return the key if translation not found\n    }\n  }\n  \n  return value;\n}\n\n/**\n * Replace placeholders in translation string\n */\nfunction replacePlaceholders(text: string, values: Record<string, any>): string {\n  return text.replace(/\\{(\\w+)\\}/g, (match, key) => {\n    return values[key] !== undefined ? String(values[key]) : match;\n  });\n}\n\n/**\n * Handle pluralization\n */\nfunction handlePluralization(text: string, values: Record<string, any>): string {\n  // Handle ICU MessageFormat plural syntax\n  // This needs to match patterns like: {count, plural, =1 {# case} other {# cases}} in\n  \n  // Find plural blocks by looking for the pattern and matching braces\n  let result = text;\n  let startIndex = 0;\n  \n  while (true) {\n    const pluralStart = result.indexOf('{', startIndex);\n    if (pluralStart === -1) break;\n    \n    // Check if this is a plural pattern\n    const pluralMatch = result.substring(pluralStart).match(/^\\{(\\w+),\\s*plural,/);\n    if (!pluralMatch) {\n      startIndex = pluralStart + 1;\n      continue;\n    }\n    \n    const varName = pluralMatch[1];\n    const count = values[varName];\n    if (count === undefined) {\n      startIndex = pluralStart + 1;\n      continue;\n    }\n    \n    // Find the matching closing brace\n    let braceCount = 1;\n    let i = pluralStart + pluralMatch[0].length;\n    let pluralEnd = -1;\n    \n    while (i < result.length && braceCount > 0) {\n      if (result[i] === '{') braceCount++;\n      else if (result[i] === '}') {\n        braceCount--;\n        if (braceCount === 0) {\n          pluralEnd = i;\n          break;\n        }\n      }\n      i++;\n    }\n    \n    if (pluralEnd === -1) {\n      startIndex = pluralStart + 1;\n      continue;\n    }\n    \n    // Extract the plural content\n    const pluralContent = result.substring(pluralStart + pluralMatch[0].length, pluralEnd);\n    \n    // Parse the rules\n    const rulesMap = new Map<string, string>();\n    const rulePattern = /(=\\d+|zero|one|two|few|many|other)\\s*\\{([^}]*)\\}/g;\n    let ruleMatch;\n    \n    while ((ruleMatch = rulePattern.exec(pluralContent)) !== null) {\n      rulesMap.set(ruleMatch[1], ruleMatch[2]);\n    }\n    \n    // Apply the appropriate rule\n    let replacement = '';\n    if (rulesMap.has(`=${count}`)) {\n      replacement = rulesMap.get(`=${count}`)!.replace(/#/g, String(count));\n    } else if (count === 0 && rulesMap.has('zero')) {\n      replacement = rulesMap.get('zero')!.replace(/#/g, String(count));\n    } else if (count === 1 && rulesMap.has('one')) {\n      replacement = rulesMap.get('one')!.replace(/#/g, String(count));\n    } else if (rulesMap.has('other')) {\n      replacement = rulesMap.get('other')!.replace(/#/g, String(count));\n    }\n    \n    // Check if there's text after the plural block but still within the content\n    // Look for text after the last rule's closing brace\n    const lastRuleEnd = pluralContent.lastIndexOf('}');\n    if (lastRuleEnd !== -1 && lastRuleEnd < pluralContent.length - 1) {\n      const followingText = pluralContent.substring(lastRuleEnd + 1);\n      replacement += followingText;\n    }\n    \n    // Replace the entire plural block with the result\n    result = result.substring(0, pluralStart) + replacement + result.substring(pluralEnd + 1);\n    \n    // Update startIndex to continue searching after this replacement\n    startIndex = pluralStart + replacement.length;\n  }\n  \n  return result;\n}\n\n/**\n * Server-side translation function\n */\nexport async function getServerTranslation(\n  locale: string,\n  key: string,\n  values?: Record<string, any>\n): Promise<string> {\n  try {\n    const translations = await loadTranslations(locale);\n    let text = getTranslation(translations, key);\n    \n    if (values) {\n      // Handle pluralization first\n      text = handlePluralization(text, values);\n      // Then replace simple placeholders\n      text = replacePlaceholders(text, values);\n    }\n    \n    return text;\n  } catch (error) {\n    console.error(`Failed to get translation for ${key}:`, error);\n    return key;\n  }\n}\n\n/**\n * Get multiple translations at once\n */\nexport async function getServerTranslations(\n  locale: string,\n  keys: string[]\n): Promise<Record<string, string>> {\n  const translations = await loadTranslations(locale);\n  const result: Record<string, string> = {};\n  \n  for (const key of keys) {\n    result[key] = getTranslation(translations, key);\n  }\n  \n  return result;\n}\n\n/**\n * Format locale for use in URLs\n */\nexport function formatLocaleForUrl(locale: string): string {\n  // Convert underscore to dash for URL compatibility\n  return locale.replace('_', '-');\n}", "// Extensions that are safe for email rendering - defined as a plain object to avoid importing extensions on client\nconst extensionConfig = {\n  starterKit: {\n    link: false, // We'll configure this separately\n  },\n  link: {\n    openOnClick: false,\n    HTMLAttributes: {\n      target: \"_blank\",\n      rel: \"noopener noreferrer\",\n    },\n  },\n  image: {\n    inline: true,\n    allowBase64: true,\n    HTMLAttributes: {\n      style: 'max-width: 100%; height: auto;',\n    },\n  },\n};\n\n/**\n * Minimal HTML generation fallback for when TipTap fails\n */\nexport function generateHTMLFallback(content: any): string {\n  if (!content || !content.content) {\n    return '<div></div>';\n  }\n\n  function processNode(node: any): string {\n    if (!node) return '';\n\n    switch (node.type) {\n      case 'doc':\n        return node.content?.map(processNode).join('') || '';\n\n      case 'paragraph':\n        const pContent = node.content?.map(processNode).join('') || '';\n        return `<p>${pContent}</p>`;\n\n      case 'text':\n        let text = node.text || '';\n        if (node.marks) {\n          for (const mark of node.marks) {\n            switch (mark.type) {\n              case 'bold':\n                text = `<strong>${text}</strong>`;\n                break;\n              case 'italic':\n                text = `<em>${text}</em>`;\n                break;\n              case 'link':\n                const href = mark.attrs?.href || '#';\n                const target = mark.attrs?.target || '_blank';\n                text = `<a href=\"${href}\" target=\"${target}\" rel=\"noopener noreferrer\">${text}</a>`;\n                break;\n            }\n          }\n        }\n        return text;\n\n      case 'heading':\n        const level = node.attrs?.level || 1;\n        const hContent = node.content?.map(processNode).join('') || '';\n        return `<h${level}>${hContent}</h${level}>`;\n\n      case 'bulletList':\n        const ulContent = node.content?.map(processNode).join('') || '';\n        return `<ul>${ulContent}</ul>`;\n\n      case 'listItem':\n        const liContent = node.content?.map(processNode).join('') || '';\n        return `<li>${liContent}</li>`;\n\n      case 'image':\n        const src = node.attrs?.src || '';\n        const alt = node.attrs?.alt || '';\n        return `<img src=\"${src}\" alt=\"${alt}\" style=\"max-width: 100%; height: auto;\" />`;\n\n      default:\n        return node.content?.map(processNode).join('') || '';\n    }\n  }\n\n  return processNode(content);\n}\n\n// Server-side functionality moved to separate file to avoid bundling server dependencies\n\n/**\n * Client-safe TipTap to HTML conversion\n * Uses fallback implementation that works in browser environments\n * @param json - The TipTap JSON content\n * @returns HTML string\n */\nexport function tiptapToHtml(json: any): string {\n  try {\n    // If it's already a string, try to parse it as JSON\n    let content;\n    if (typeof json === \"string\") {\n      try {\n        content = JSON.parse(json);\n      } catch {\n        // If JSON parsing fails, treat as plain text\n        return `<p>${json}</p>`;\n      }\n    } else {\n      content = json;\n    }\n\n    // Use fallback HTML generation for client-side\n    const html = generateHTMLFallback(content);\n\n    // Add some basic styling for email compatibility\n    return `<div style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333;\">${html}</div>`;\n  } catch (error) {\n    console.error(\"Failed to convert TipTap to HTML:\", error);\n    // Return plain text fallback\n    return `<p>${String(json)}</p>`;\n  }\n}\n\n/**\n * Checks if content is TipTap JSON\n */\nexport function isTipTapContent(content: any): boolean {\n  try {\n    const parsed = typeof content === \"string\" ? JSON.parse(content) : content;\n    return !!(parsed && typeof parsed === \"object\" && (parsed.type === \"doc\" || parsed.content));\n  } catch {\n    return false;\n  }\n}", "// lib/multiTenantPrisma.ts\n// Multi-tenant Prisma client factory for shared worker containers\n\nimport { PrismaClient } from \"@prisma/client\";\nimport * as fs from \"fs\";\n\n/**\n * Tenant configuration interface\n */\nexport interface TenantConfig {\n  tenantId: string;\n  databaseUrl: string;\n  elasticsearchNode?: string;\n  elasticsearchIndex?: string;\n  baseUrl?: string;\n}\n\n/**\n * Check if multi-tenant mode is enabled\n */\nexport function isMultiTenantMode(): boolean {\n  return process.env.MULTI_TENANT_MODE === \"true\";\n}\n\n/**\n * Get the current instance's tenant ID\n * In multi-tenant deployments, each web app instance belongs to a single tenant.\n * Set via INSTANCE_TENANT_ID environment variable.\n *\n * Note: This returns the tenant ID whenever INSTANCE_TENANT_ID is set,\n * regardless of whether MULTI_TENANT_MODE is enabled. This allows web app\n * instances to include their tenant ID in queued jobs, which the shared\n * worker (running with MULTI_TENANT_MODE=true) can then use to route\n * database operations to the correct tenant.\n *\n * Returns undefined if INSTANCE_TENANT_ID is not configured.\n */\nexport function getCurrentTenantId(): string | undefined {\n  return process.env.INSTANCE_TENANT_ID;\n}\n\n/**\n * Cache of Prisma clients per tenant to avoid creating new connections for each job\n * Stores both the client and the database URL used to create it (for credential change detection)\n */\ninterface CachedClient {\n  client: PrismaClient;\n  databaseUrl: string;\n}\nconst tenantClients: Map<string, CachedClient> = new Map();\n\n/**\n * Tenant configurations loaded from environment or config file\n */\nlet tenantConfigs: Map<string, TenantConfig> | null = null;\n\n/**\n * Path to the tenant config file (can be set via TENANT_CONFIG_FILE env var)\n */\nconst TENANT_CONFIG_FILE = process.env.TENANT_CONFIG_FILE || \"/config/tenants.json\";\n\n/**\n * Load tenant configurations from file\n */\nfunction loadTenantsFromFile(filePath: string): Map<string, TenantConfig> {\n  const configs = new Map<string, TenantConfig>();\n\n  try {\n    if (fs.existsSync(filePath)) {\n      const fileContent = fs.readFileSync(filePath, \"utf-8\");\n      const parsed = JSON.parse(fileContent) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(parsed)) {\n        configs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n          baseUrl: config.baseUrl,\n        });\n      }\n      console.log(`Loaded ${configs.size} tenant configurations from ${filePath}`);\n    }\n  } catch (error) {\n    console.error(`Failed to load tenant configs from ${filePath}:`, error);\n  }\n\n  return configs;\n}\n\n/**\n * Reload tenant configurations from file (for dynamic updates)\n * This allows adding new tenants without restarting workers\n */\nexport function reloadTenantConfigs(): Map<string, TenantConfig> {\n  // Clear cached configs\n  tenantConfigs = null;\n  // Reload\n  return loadTenantConfigs();\n}\n\n/**\n * Load tenant configurations from:\n * 1. Config file (TENANT_CONFIG_FILE env var or /config/tenants.json)\n * 2. TENANT_CONFIGS environment variable (JSON string)\n * 3. Individual environment variables: TENANT_<ID>_DATABASE_URL, etc.\n */\nexport function loadTenantConfigs(): Map<string, TenantConfig> {\n  if (tenantConfigs) {\n    return tenantConfigs;\n  }\n\n  tenantConfigs = new Map();\n\n  // Priority 1: Load from config file\n  const fileConfigs = loadTenantsFromFile(TENANT_CONFIG_FILE);\n  for (const [tenantId, config] of fileConfigs) {\n    tenantConfigs.set(tenantId, config);\n  }\n\n  // Priority 2: Load from TENANT_CONFIGS env var (can override file configs)\n  const configJson = process.env.TENANT_CONFIGS;\n  if (configJson) {\n    try {\n      const configs = JSON.parse(configJson) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(configs)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n          baseUrl: config.baseUrl,\n        });\n      }\n      console.log(`Loaded ${Object.keys(configs).length} tenant configurations from TENANT_CONFIGS env var`);\n    } catch (error) {\n      console.error(\"Failed to parse TENANT_CONFIGS:\", error);\n    }\n  }\n\n  // Priority 3: Individual tenant environment variables\n  // Format: TENANT_<TENANT_ID>_DATABASE_URL, TENANT_<TENANT_ID>_ELASTICSEARCH_NODE, TENANT_<TENANT_ID>_BASE_URL\n  for (const [key, value] of Object.entries(process.env)) {\n    const match = key.match(/^TENANT_([A-Z0-9_]+)_DATABASE_URL$/);\n    if (match && value) {\n      const tenantId = match[1].toLowerCase();\n      if (!tenantConfigs.has(tenantId)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: value,\n          elasticsearchNode: process.env[`TENANT_${match[1]}_ELASTICSEARCH_NODE`],\n          elasticsearchIndex: process.env[`TENANT_${match[1]}_ELASTICSEARCH_INDEX`],\n          baseUrl: process.env[`TENANT_${match[1]}_BASE_URL`],\n        });\n      }\n    }\n  }\n\n  if (tenantConfigs.size === 0) {\n    console.warn(\"No tenant configurations found. Multi-tenant mode will not work without configurations.\");\n  }\n\n  return tenantConfigs;\n}\n\n/**\n * Get tenant configuration by ID\n */\nexport function getTenantConfig(tenantId: string): TenantConfig | undefined {\n  const configs = loadTenantConfigs();\n  return configs.get(tenantId);\n}\n\n/**\n * Get all tenant IDs\n */\nexport function getAllTenantIds(): string[] {\n  const configs = loadTenantConfigs();\n  return Array.from(configs.keys());\n}\n\n/**\n * Create a Prisma client for a specific tenant\n */\nfunction createTenantPrismaClient(config: TenantConfig): PrismaClient {\n  const client = new PrismaClient({\n    datasources: {\n      db: {\n        url: config.databaseUrl,\n      },\n    },\n    errorFormat: \"pretty\",\n  });\n\n  return client;\n}\n\n/**\n * Get or create a Prisma client for a specific tenant\n * Caches clients to reuse connections\n * Supports dynamic tenant addition by reloading configs if tenant not found\n * Automatically invalidates cached clients when credentials change\n */\nexport function getTenantPrismaClient(tenantId: string): PrismaClient {\n  // Always reload config from file to get latest credentials\n  reloadTenantConfigs();\n  const config = getTenantConfig(tenantId);\n\n  if (!config) {\n    throw new Error(`No configuration found for tenant: ${tenantId}`);\n  }\n\n  // Check cache - but invalidate if credentials have changed\n  const cached = tenantClients.get(tenantId);\n  if (cached) {\n    if (cached.databaseUrl === config.databaseUrl) {\n      // Credentials unchanged, reuse cached client\n      return cached.client;\n    } else {\n      // Credentials changed - disconnect old client and create new one\n      console.log(`Credentials changed for tenant ${tenantId}, invalidating cached client...`);\n      cached.client.$disconnect().catch((err) => {\n        console.error(`Error disconnecting stale client for tenant ${tenantId}:`, err);\n      });\n      tenantClients.delete(tenantId);\n    }\n  }\n\n  // Create and cache new client\n  const client = createTenantPrismaClient(config);\n  tenantClients.set(tenantId, { client, databaseUrl: config.databaseUrl });\n  console.log(`Created Prisma client for tenant: ${tenantId}`);\n\n  return client;\n}\n\n/**\n * Get a Prisma client based on job data\n * In single-tenant mode, returns the default client\n * In multi-tenant mode, returns tenant-specific client\n */\nexport function getPrismaClientForJob(jobData: { tenantId?: string }): PrismaClient {\n  if (!isMultiTenantMode()) {\n    // Single-tenant mode: use lightweight Prisma client (no ES sync extensions)\n    // Import lazily to avoid circular dependencies\n    const { prisma } = require(\"./prismaBase\");\n    return prisma;\n  }\n\n  // Multi-tenant mode: require tenantId\n  if (!jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n\n  return getTenantPrismaClient(jobData.tenantId);\n}\n\n/**\n * Disconnect all tenant clients (for graceful shutdown)\n */\nexport async function disconnectAllTenantClients(): Promise<void> {\n  const disconnectPromises: Promise<void>[] = [];\n\n  for (const [tenantId, cached] of tenantClients) {\n    console.log(`Disconnecting Prisma client for tenant: ${tenantId}`);\n    disconnectPromises.push(cached.client.$disconnect());\n  }\n\n  await Promise.all(disconnectPromises);\n  tenantClients.clear();\n  console.log(\"All tenant Prisma clients disconnected\");\n}\n\n/**\n * Base interface for job data that supports multi-tenancy\n */\nexport interface MultiTenantJobData {\n  tenantId?: string; // Optional in single-tenant mode, required in multi-tenant mode\n}\n\n/**\n * Validate job data for multi-tenant mode\n */\nexport function validateMultiTenantJobData(jobData: MultiTenantJobData): void {\n  if (isMultiTenantMode() && !jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_bullmq", "IORedis", "path", "Handlebars", "fs", "nodemailer", "import_promises", "import_path", "import_url", "import_meta", "currentDir", "path", "fs", "import_client", "fs", "prisma", "import_meta", "prisma"]
}
