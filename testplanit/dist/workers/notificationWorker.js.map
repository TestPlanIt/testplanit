{
  "version": 3,
  "sources": ["../../workers/notificationWorker.ts", "../../lib/valkey.ts", "../../lib/queues.ts", "../../lib/queueNames.ts"],
  "sourcesContent": ["import { Worker, Job } from \"bullmq\";\nimport valkeyConnection from \"../lib/valkey\";\nimport { NOTIFICATION_QUEUE_NAME, getEmailQueue } from \"../lib/queues\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { pathToFileURL } from \"node:url\";\n\nconst prisma = new PrismaClient();\n\n// Define job data structures\ninterface CreateNotificationJobData {\n  userId: string;\n  type: string;\n  title: string;\n  message: string;\n  relatedEntityId?: string;\n  relatedEntityType?: string;\n  data?: any;\n}\n\ninterface ProcessUserNotificationsJobData {\n  userId: string;\n}\n\n// Define job names\nexport const JOB_CREATE_NOTIFICATION = \"create-notification\";\nexport const JOB_PROCESS_USER_NOTIFICATIONS = \"process-user-notifications\";\nexport const JOB_SEND_DAILY_DIGEST = \"send-daily-digest\";\n\nconst processor = async (job: Job) => {\n  console.log(`Processing notification job ${job.id} of type ${job.name}`);\n\n  switch (job.name) {\n    case JOB_CREATE_NOTIFICATION:\n      const createData = job.data as CreateNotificationJobData;\n\n      try {\n        // Check user preferences first\n        const userPreferences = await prisma.userPreferences.findUnique({\n          where: { userId: createData.userId },\n        });\n\n        // Get global notification settings from AppConfig\n        const globalSettings = await prisma.appConfig.findUnique({\n          where: { key: \"notificationSettings\" },\n        });\n\n        // Determine notification mode\n        let notificationMode =\n          userPreferences?.notificationMode || \"USE_GLOBAL\";\n        if (notificationMode === \"USE_GLOBAL\") {\n          const settingsValue = globalSettings?.value as {\n            defaultMode?: string;\n          } | null;\n          notificationMode = (settingsValue?.defaultMode || \"IN_APP\") as any;\n        }\n\n        // Skip notification creation if user has notifications set to NONE\n        if (notificationMode === \"NONE\") {\n          console.log(\n            `Skipping notification for user ${createData.userId} - notifications disabled`\n          );\n          return;\n        }\n\n        // Create the in-app notification (for all modes except NONE)\n        const notification = await prisma.notification.create({\n          data: {\n            userId: createData.userId,\n            type: createData.type as any,\n            title: createData.title,\n            message: createData.message,\n            relatedEntityId: createData.relatedEntityId,\n            relatedEntityType: createData.relatedEntityType,\n            data: createData.data,\n          },\n        });\n\n        // Queue email if needed based on notification mode\n        if (notificationMode === \"IN_APP_EMAIL_IMMEDIATE\") {\n          await getEmailQueue()?.add(\"send-notification-email\", {\n            notificationId: notification.id,\n            userId: createData.userId,\n            immediate: true,\n          });\n        }\n\n        console.log(\n          `Created notification ${notification.id} for user ${createData.userId} with mode ${notificationMode}`\n        );\n      } catch (error) {\n        console.error(`Failed to create notification:`, error);\n        throw error;\n      }\n      break;\n\n    case JOB_PROCESS_USER_NOTIFICATIONS:\n      const processData = job.data as ProcessUserNotificationsJobData;\n\n      try {\n        // Get unread notifications for the user\n        const notifications = await prisma.notification.findMany({\n          where: {\n            userId: processData.userId,\n            isRead: false,\n            isDeleted: false,\n          },\n          orderBy: { createdAt: \"desc\" },\n        });\n\n        console.log(\n          `Processing ${notifications.length} notifications for user ${processData.userId}`\n        );\n      } catch (error) {\n        console.error(`Failed to process user notifications:`, error);\n        throw error;\n      }\n      break;\n\n    case JOB_SEND_DAILY_DIGEST:\n      try {\n        // Get global settings from AppConfig\n        const globalSettings = await prisma.appConfig.findUnique({\n          where: { key: \"notificationSettings\" },\n        });\n        const settingsValue = globalSettings?.value as {\n          defaultMode?: string;\n        } | null;\n        const globalDefaultMode = settingsValue?.defaultMode || \"IN_APP\";\n\n        // Get all users with IN_APP_EMAIL_DAILY preference or USE_GLOBAL where global is daily\n        const users = await prisma.userPreferences.findMany({\n          where: {\n            OR: [\n              { notificationMode: \"IN_APP_EMAIL_DAILY\" },\n              {\n                notificationMode: \"USE_GLOBAL\",\n                ...(globalDefaultMode === \"IN_APP_EMAIL_DAILY\"\n                  ? {}\n                  : { id: \"none\" }), // Only include if global is daily\n              },\n            ],\n          },\n          include: {\n            user: true,\n          },\n        });\n\n        for (const userPref of users) {\n          // Get unread notifications from the last 24 hours\n          const yesterday = new Date();\n          yesterday.setDate(yesterday.getDate() - 1);\n\n          const notifications = await prisma.notification.findMany({\n            where: {\n              userId: userPref.userId,\n              isRead: false,\n              isDeleted: false,\n              createdAt: { gte: yesterday },\n            },\n            orderBy: { createdAt: \"desc\" },\n          });\n\n          if (notifications.length > 0) {\n            await getEmailQueue()?.add(\"send-digest-email\", {\n              userId: userPref.userId,\n              notifications: notifications.map((n) => ({\n                id: n.id,\n                title: n.title,\n                message: n.message,\n                createdAt: n.createdAt,\n              })),\n            });\n          }\n        }\n\n        console.log(`Processed daily digest for ${users.length} users`);\n      } catch (error) {\n        console.error(`Failed to send daily digest:`, error);\n        throw error;\n      }\n      break;\n\n    default:\n      throw new Error(`Unknown job type: ${job.name}`);\n  }\n};\n\nlet worker: Worker | null = null;\n\n// Function to start the worker\nconst startWorker = async () => {\n  if (valkeyConnection) {\n    worker = new Worker(NOTIFICATION_QUEUE_NAME, processor, {\n      connection: valkeyConnection,\n      concurrency: 5,\n    });\n\n    worker.on(\"completed\", (job) => {\n      console.log(`Job ${job.id} completed successfully.`);\n    });\n\n    worker.on(\"failed\", (job, err) => {\n      console.error(`Job ${job?.id} failed:`, err);\n    });\n\n    worker.on(\"error\", (err) => {\n      console.error(\"Worker error:\", err);\n    });\n\n    console.log(\n      `Notification worker started for queue \"${NOTIFICATION_QUEUE_NAME}\".`\n    );\n  } else {\n    console.warn(\n      \"Valkey connection not available. Notification worker not started.\"\n    );\n  }\n\n  // Allow graceful shutdown\n  process.on(\"SIGINT\", async () => {\n    console.log(\"Shutting down notification worker...\");\n    if (worker) {\n      await worker.close();\n    }\n    await prisma.$disconnect();\n    process.exit(0);\n  });\n};\n\n// Run the worker if this file is executed directly (works with both ESM and CommonJS)\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  (typeof import.meta === \"undefined\" ||\n    (import.meta as any).url === undefined)\n) {\n  console.log(\"Notification worker running...\");\n  startWorker().catch((err) => {\n    console.error(\"Failed to start notification worker:\", err);\n    process.exit(1);\n  });\n}\n\nexport default worker;\nexport { processor };\n", "import IORedis from \"ioredis\";\n\n// Check if we should skip Valkey connection (useful during build)\nconst skipConnection = process.env.SKIP_VALKEY_CONNECTION === \"true\";\n\n// Get Valkey URL from environment\nconst valkeyUrl = process.env.VALKEY_URL;\n\nif (!valkeyUrl && !skipConnection) {\n  // Log an error, but maybe don't throw immediately\n  // depending on whether Valkey is strictly required at startup\n  console.error(\n    \"VALKEY_URL environment variable is not set. Background jobs may fail.\"\n  );\n  // Optional: throw new Error('VALKEY_URL environment variable is not set.');\n}\n\n// Configure the connection options\nconst connectionOptions = {\n  maxRetriesPerRequest: null, // Required by BullMQ\n  enableReadyCheck: false, // Optional: Sometimes helps with startup race conditions\n};\n\nlet valkeyConnection: IORedis | null = null;\n\nif (valkeyUrl && !skipConnection) {\n  // Convert valkey:// to redis:// for ioredis compatibility\n  // ioredis expects redis:// protocol but we're connecting to Valkey\n  const connectionUrl = valkeyUrl.replace(/^valkey:\\/\\//, 'redis://');\n  \n  // Create and export the connection instance only if URL is provided\n  valkeyConnection = new IORedis(connectionUrl, connectionOptions);\n\n  valkeyConnection.on(\"connect\", () => {\n    console.log(\"Successfully connected to Valkey.\");\n  });\n\n  valkeyConnection.on(\"error\", (err) => {\n    console.error(\"Valkey connection error:\", err);\n  });\n} else {\n  console.warn(\"Valkey URL not provided. Valkey connection not established.\");\n}\n\nexport default valkeyConnection;", "import { Queue } from \"bullmq\";\nimport valkeyConnection from \"./valkey\";\nimport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n} from \"./queueNames\";\n\n// Re-export queue names for backward compatibility\nexport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n};\n\n// Lazy-initialized queue instances\nlet _forecastQueue: Queue | null = null;\nlet _notificationQueue: Queue | null = null;\nlet _emailQueue: Queue | null = null;\nlet _syncQueue: Queue | null = null;\nlet _testmoImportQueue: Queue | null = null;\nlet _elasticsearchReindexQueue: Queue | null = null;\n\n/**\n * Get the forecast queue instance (lazy initialization)\n * Only creates the queue when first accessed\n */\nexport function getForecastQueue(): Queue | null {\n  if (_forecastQueue) return _forecastQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${FORECAST_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _forecastQueue = new Queue(FORECAST_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${FORECAST_QUEUE_NAME}\" initialized.`);\n\n  _forecastQueue.on(\"error\", (error) => {\n    console.error(`Queue ${FORECAST_QUEUE_NAME} error:`, error);\n  });\n\n  return _forecastQueue;\n}\n\n/**\n * Get the notification queue instance (lazy initialization)\n */\nexport function getNotificationQueue(): Queue | null {\n  if (_notificationQueue) return _notificationQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${NOTIFICATION_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _notificationQueue = new Queue(NOTIFICATION_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${NOTIFICATION_QUEUE_NAME}\" initialized.`);\n\n  _notificationQueue.on(\"error\", (error) => {\n    console.error(`Queue ${NOTIFICATION_QUEUE_NAME} error:`, error);\n  });\n\n  return _notificationQueue;\n}\n\n/**\n * Get the email queue instance (lazy initialization)\n */\nexport function getEmailQueue(): Queue | null {\n  if (_emailQueue) return _emailQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${EMAIL_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _emailQueue = new Queue(EMAIL_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 5,\n      backoff: {\n        type: \"exponential\",\n        delay: 10000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 5000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${EMAIL_QUEUE_NAME}\" initialized.`);\n\n  _emailQueue.on(\"error\", (error) => {\n    console.error(`Queue ${EMAIL_QUEUE_NAME} error:`, error);\n  });\n\n  return _emailQueue;\n}\n\n/**\n * Get the sync queue instance (lazy initialization)\n */\nexport function getSyncQueue(): Queue | null {\n  if (_syncQueue) return _syncQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${SYNC_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _syncQueue = new Queue(SYNC_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 3,\n        count: 500,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 7,\n      },\n    },\n  });\n\n  console.log(`Queue \"${SYNC_QUEUE_NAME}\" initialized.`);\n\n  _syncQueue.on(\"error\", (error) => {\n    console.error(`Queue ${SYNC_QUEUE_NAME} error:`, error);\n  });\n\n  return _syncQueue;\n}\n\n/**\n * Get the Testmo import queue instance (lazy initialization)\n */\nexport function getTestmoImportQueue(): Queue | null {\n  if (_testmoImportQueue) return _testmoImportQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _testmoImportQueue = new Queue(TESTMO_IMPORT_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 100,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" initialized.`);\n\n  _testmoImportQueue.on(\"error\", (error) => {\n    console.error(`Queue ${TESTMO_IMPORT_QUEUE_NAME} error:`, error);\n  });\n\n  return _testmoImportQueue;\n}\n\n/**\n * Get the Elasticsearch reindex queue instance (lazy initialization)\n */\nexport function getElasticsearchReindexQueue(): Queue | null {\n  if (_elasticsearchReindexQueue) return _elasticsearchReindexQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _elasticsearchReindexQueue = new Queue(ELASTICSEARCH_REINDEX_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 50,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" initialized.`);\n\n  _elasticsearchReindexQueue.on(\"error\", (error) => {\n    console.error(`Queue ${ELASTICSEARCH_REINDEX_QUEUE_NAME} error:`, error);\n  });\n\n  return _elasticsearchReindexQueue;\n}\n\n/**\n * Get all queues (initializes all of them)\n * Use this only when you need access to all queues (e.g., admin dashboard)\n */\nexport function getAllQueues() {\n  return {\n    forecastQueue: getForecastQueue(),\n    notificationQueue: getNotificationQueue(),\n    emailQueue: getEmailQueue(),\n    syncQueue: getSyncQueue(),\n    testmoImportQueue: getTestmoImportQueue(),\n    elasticsearchReindexQueue: getElasticsearchReindexQueue(),\n  };\n}\n", "// Queue name constants - no initialization, just names\nexport const FORECAST_QUEUE_NAME = \"forecast-updates\";\nexport const NOTIFICATION_QUEUE_NAME = \"notifications\";\nexport const EMAIL_QUEUE_NAME = \"emails\";\nexport const SYNC_QUEUE_NAME = \"issue-sync\";\nexport const TESTMO_IMPORT_QUEUE_NAME = \"testmo-imports\";\nexport const ELASTICSEARCH_REINDEX_QUEUE_NAME = \"elasticsearch-reindex\";\n"],
  "mappings": "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",
  "names": ["import_bullmq", "IORedis"]
}
