{
  "version": 3,
  "sources": ["../../lib/prismaBase.ts", "../../workers/syncWorker.ts", "../../lib/valkey.ts", "../../lib/queueNames.ts", "../../lib/queues.ts", "../../lib/integrations/cache/IssueCache.ts", "../../lib/integrations/IntegrationManager.ts", "../../lib/integrations/adapters/BaseAdapter.ts", "../../lib/integrations/adapters/JiraAdapter.ts", "../../lib/integrations/adapters/GitHubAdapter.ts", "../../lib/integrations/adapters/AzureDevOpsAdapter.ts", "../../lib/integrations/adapters/SimpleUrlAdapter.ts", "../../utils/encryption.ts", "../../lib/integrations/services/SyncService.ts", "../../services/elasticsearchService.ts", "../../env.js", "../../services/unifiedElasticsearchService.ts", "../../services/issueSearch.ts", "../../utils/extractTextFromJson.ts", "../../lib/multiTenantPrisma.ts"],
  "sourcesContent": ["/**\n * Lightweight Prisma client for workers and services that don't need ES sync extensions.\n * This avoids loading heavy dependencies and creating multiple PrismaClient instances.\n *\n * Use this for:\n * - Workers (forecastWorker, syncWorker, etc.)\n * - Services called by workers (forecastService, issueSearch, etc.)\n * - Integration adapters and managers\n *\n * Use lib/prisma.ts for:\n * - Next.js app routes and server actions (needs ES sync extensions)\n */\n\nimport { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  var prismaBase: PrismaClient | undefined;\n}\n\nlet prismaClient: PrismaClient;\n\nif (process.env.NODE_ENV === \"production\") {\n  prismaClient = new PrismaClient({\n    errorFormat: \"pretty\",\n  });\n} else {\n  // In development, reuse the client to avoid too many connections\n  if (!global.prismaBase) {\n    global.prismaBase = new PrismaClient({\n      errorFormat: \"colorless\",\n    });\n  }\n  prismaClient = global.prismaBase;\n}\n\nexport const prisma = prismaClient;\n", "import { Worker, Job } from \"bullmq\";\nimport valkeyConnection from \"../lib/valkey\";\nimport { SYNC_QUEUE_NAME } from \"../lib/queueNames\";\nimport { syncService, SyncJobData } from \"../lib/integrations/services/SyncService\";\nimport { pathToFileURL } from \"node:url\";\nimport {\n  getPrismaClientForJob,\n  isMultiTenantMode,\n  MultiTenantJobData,\n  disconnectAllTenantClients,\n  validateMultiTenantJobData,\n} from \"../lib/multiTenantPrisma\";\n\n// Extend SyncJobData with multi-tenant support\ninterface MultiTenantSyncJobData extends SyncJobData, MultiTenantJobData {}\n\nconst processor = async (job: Job) => {\n  console.log(`Processing sync job ${job.id} of type ${job.name}${job.data.tenantId ? ` for tenant ${job.data.tenantId}` : \"\"}`);\n\n  // Validate multi-tenant job data if in multi-tenant mode\n  validateMultiTenantJobData(job.data);\n\n  // Get the appropriate Prisma client (tenant-specific or default)\n  const prisma = getPrismaClientForJob(job.data);\n  const serviceOptions = { prismaClient: prisma };\n\n  const jobData = job.data as MultiTenantSyncJobData;\n\n  switch (job.name) {\n    case \"sync-issues\":\n      try {\n        const result = await syncService.performSync(\n          jobData.userId,\n          jobData.integrationId,\n          jobData.projectId,\n          jobData.data,\n          job, // Pass job for progress reporting\n          serviceOptions\n        );\n\n        if (result.errors.length > 0) {\n          console.warn(\n            `Sync completed with ${result.errors.length} errors:`,\n            result.errors\n          );\n        }\n\n        console.log(`Synced ${result.synced} issues successfully`);\n        return result;\n      } catch (error) {\n        console.error(\"Failed to sync issues:\", error);\n        throw error;\n      }\n\n    case \"sync-project-issues\":\n      try {\n        if (!jobData.projectId) {\n          throw new Error(\"Project ID is required for project sync\");\n        }\n\n        const result = await syncService.performSync(\n          jobData.userId,\n          jobData.integrationId,\n          jobData.projectId,\n          jobData.data,\n          job, // Pass job for progress reporting\n          serviceOptions\n        );\n\n        if (result.errors.length > 0) {\n          console.warn(\n            `Project sync completed with ${result.errors.length} errors:`,\n            result.errors\n          );\n        }\n\n        console.log(`Synced ${result.synced} issues from project successfully`);\n        return result;\n      } catch (error) {\n        console.error(\"Failed to sync project issues:\", error);\n        throw error;\n      }\n\n    case \"refresh-issue\":\n      try {\n        if (!jobData.issueId) {\n          throw new Error(\"Issue ID is required for issue refresh\");\n        }\n\n        const result = await syncService.performIssueRefresh(\n          jobData.userId,\n          jobData.integrationId,\n          jobData.issueId,\n          serviceOptions\n        );\n\n        if (!result.success) {\n          throw new Error(result.error || \"Failed to refresh issue\");\n        }\n\n        console.log(`Refreshed issue ${jobData.issueId} successfully`);\n        return result;\n      } catch (error) {\n        console.error(`Failed to refresh issue ${jobData.issueId}:`, error);\n        throw error;\n      }\n\n    case \"create-issue\":\n      try {\n        if (!jobData.data) {\n          throw new Error(\"Issue data is required for issue creation\");\n        }\n\n        // TODO: Implement issue creation via adapter\n        console.log(\"Issue creation not yet implemented in worker\");\n        return { success: false, error: \"Not implemented\" };\n      } catch (error) {\n        console.error(\"Failed to create issue:\", error);\n        throw error;\n      }\n\n    case \"update-issue\":\n      try {\n        if (!jobData.issueId || !jobData.data) {\n          throw new Error(\"Issue ID and data are required for issue update\");\n        }\n\n        // TODO: Implement issue update via adapter\n        console.log(\"Issue update not yet implemented in worker\");\n        return { success: false, error: \"Not implemented\" };\n      } catch (error) {\n        console.error(\"Failed to update issue:\", error);\n        throw error;\n      }\n\n    default:\n      throw new Error(`Unknown job type: ${job.name}`);\n  }\n};\n\nlet worker: Worker | null = null;\n\n// Function to start the worker\nconst startWorker = async () => {\n  // Log multi-tenant mode status\n  if (isMultiTenantMode()) {\n    console.log(\"Sync worker starting in MULTI-TENANT mode\");\n  } else {\n    console.log(\"Sync worker starting in SINGLE-TENANT mode\");\n  }\n\n  if (valkeyConnection) {\n    worker = new Worker(SYNC_QUEUE_NAME, processor, {\n      connection: valkeyConnection,\n      concurrency: 1, // Process 1 sync job at a time to manage memory usage\n      lockDuration: 21600000, // 6 hours - allows for very large issue syncs\n      maxStalledCount: 1, // Reduce automatic stalled job retries\n      stalledInterval: 300000, // Check for stalled jobs every 5 minutes\n    });\n\n    worker.on(\"completed\", (job) => {\n      console.log(`Sync job ${job.id} completed successfully.`);\n    });\n\n    worker.on(\"failed\", (job, err) => {\n      console.error(`Sync job ${job?.id} failed:`, err);\n    });\n\n    worker.on(\"error\", (err) => {\n      console.error(\"Sync worker error:\", err);\n    });\n\n    console.log(`Sync worker started for queue \"${SYNC_QUEUE_NAME}\".`);\n  } else {\n    console.warn(\"Valkey connection not available. Sync worker not started.\");\n  }\n\n  // Allow graceful shutdown\n  process.on(\"SIGINT\", async () => {\n    console.log(\"Shutting down sync worker...\");\n    if (worker) {\n      await worker.close();\n    }\n    // Disconnect all tenant Prisma clients in multi-tenant mode\n    if (isMultiTenantMode()) {\n      await disconnectAllTenantClients();\n    }\n    process.exit(0);\n  });\n};\n\n// Run the worker if this file is executed directly (works with both ESM and CommonJS)\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  (typeof import.meta === \"undefined\" ||\n    (import.meta as any).url === undefined)\n) {\n  console.log(\"Sync worker running...\");\n  startWorker().catch((err) => {\n    console.error(\"Failed to start sync worker:\", err);\n    process.exit(1);\n  });\n}\n\nexport default worker;\n", "import IORedis from \"ioredis\";\n\n// Check if we should skip Valkey connection (useful during build)\nconst skipConnection = process.env.SKIP_VALKEY_CONNECTION === \"true\";\n\n// Get Valkey URL from environment\nconst valkeyUrl = process.env.VALKEY_URL;\n\nif (!valkeyUrl && !skipConnection) {\n  // Log an error, but maybe don't throw immediately\n  // depending on whether Valkey is strictly required at startup\n  console.error(\n    \"VALKEY_URL environment variable is not set. Background jobs may fail.\"\n  );\n  // Optional: throw new Error('VALKEY_URL environment variable is not set.');\n}\n\n// Configure the connection options\nconst connectionOptions = {\n  maxRetriesPerRequest: null, // Required by BullMQ\n  enableReadyCheck: false, // Optional: Sometimes helps with startup race conditions\n};\n\nlet valkeyConnection: IORedis | null = null;\n\nif (valkeyUrl && !skipConnection) {\n  // Convert valkey:// to redis:// for ioredis compatibility\n  // ioredis expects redis:// protocol but we're connecting to Valkey\n  const connectionUrl = valkeyUrl.replace(/^valkey:\\/\\//, 'redis://');\n  \n  // Create and export the connection instance only if URL is provided\n  valkeyConnection = new IORedis(connectionUrl, connectionOptions);\n\n  valkeyConnection.on(\"connect\", () => {\n    console.log(\"Successfully connected to Valkey.\");\n  });\n\n  valkeyConnection.on(\"error\", (err) => {\n    console.error(\"Valkey connection error:\", err);\n  });\n} else {\n  console.warn(\"Valkey URL not provided. Valkey connection not established.\");\n}\n\nexport default valkeyConnection;", "// Queue name constants - no initialization, just names\nexport const FORECAST_QUEUE_NAME = \"forecast-updates\";\nexport const NOTIFICATION_QUEUE_NAME = \"notifications\";\nexport const EMAIL_QUEUE_NAME = \"emails\";\nexport const SYNC_QUEUE_NAME = \"issue-sync\";\nexport const TESTMO_IMPORT_QUEUE_NAME = \"testmo-imports\";\nexport const ELASTICSEARCH_REINDEX_QUEUE_NAME = \"elasticsearch-reindex\";\n", "import { Queue } from \"bullmq\";\nimport valkeyConnection from \"./valkey\";\nimport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n} from \"./queueNames\";\n\n// Re-export queue names for backward compatibility\nexport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n};\n\n// Lazy-initialized queue instances\nlet _forecastQueue: Queue | null = null;\nlet _notificationQueue: Queue | null = null;\nlet _emailQueue: Queue | null = null;\nlet _syncQueue: Queue | null = null;\nlet _testmoImportQueue: Queue | null = null;\nlet _elasticsearchReindexQueue: Queue | null = null;\n\n/**\n * Get the forecast queue instance (lazy initialization)\n * Only creates the queue when first accessed\n */\nexport function getForecastQueue(): Queue | null {\n  if (_forecastQueue) return _forecastQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${FORECAST_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _forecastQueue = new Queue(FORECAST_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${FORECAST_QUEUE_NAME}\" initialized.`);\n\n  _forecastQueue.on(\"error\", (error) => {\n    console.error(`Queue ${FORECAST_QUEUE_NAME} error:`, error);\n  });\n\n  return _forecastQueue;\n}\n\n/**\n * Get the notification queue instance (lazy initialization)\n */\nexport function getNotificationQueue(): Queue | null {\n  if (_notificationQueue) return _notificationQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${NOTIFICATION_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _notificationQueue = new Queue(NOTIFICATION_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${NOTIFICATION_QUEUE_NAME}\" initialized.`);\n\n  _notificationQueue.on(\"error\", (error) => {\n    console.error(`Queue ${NOTIFICATION_QUEUE_NAME} error:`, error);\n  });\n\n  return _notificationQueue;\n}\n\n/**\n * Get the email queue instance (lazy initialization)\n */\nexport function getEmailQueue(): Queue | null {\n  if (_emailQueue) return _emailQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${EMAIL_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _emailQueue = new Queue(EMAIL_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 5,\n      backoff: {\n        type: \"exponential\",\n        delay: 10000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 5000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${EMAIL_QUEUE_NAME}\" initialized.`);\n\n  _emailQueue.on(\"error\", (error) => {\n    console.error(`Queue ${EMAIL_QUEUE_NAME} error:`, error);\n  });\n\n  return _emailQueue;\n}\n\n/**\n * Get the sync queue instance (lazy initialization)\n */\nexport function getSyncQueue(): Queue | null {\n  if (_syncQueue) return _syncQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${SYNC_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _syncQueue = new Queue(SYNC_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 3,\n        count: 500,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 7,\n      },\n    },\n  });\n\n  console.log(`Queue \"${SYNC_QUEUE_NAME}\" initialized.`);\n\n  _syncQueue.on(\"error\", (error) => {\n    console.error(`Queue ${SYNC_QUEUE_NAME} error:`, error);\n  });\n\n  return _syncQueue;\n}\n\n/**\n * Get the Testmo import queue instance (lazy initialization)\n */\nexport function getTestmoImportQueue(): Queue | null {\n  if (_testmoImportQueue) return _testmoImportQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _testmoImportQueue = new Queue(TESTMO_IMPORT_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 100,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" initialized.`);\n\n  _testmoImportQueue.on(\"error\", (error) => {\n    console.error(`Queue ${TESTMO_IMPORT_QUEUE_NAME} error:`, error);\n  });\n\n  return _testmoImportQueue;\n}\n\n/**\n * Get the Elasticsearch reindex queue instance (lazy initialization)\n */\nexport function getElasticsearchReindexQueue(): Queue | null {\n  if (_elasticsearchReindexQueue) return _elasticsearchReindexQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _elasticsearchReindexQueue = new Queue(ELASTICSEARCH_REINDEX_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 50,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" initialized.`);\n\n  _elasticsearchReindexQueue.on(\"error\", (error) => {\n    console.error(`Queue ${ELASTICSEARCH_REINDEX_QUEUE_NAME} error:`, error);\n  });\n\n  return _elasticsearchReindexQueue;\n}\n\n/**\n * Get all queues (initializes all of them)\n * Use this only when you need access to all queues (e.g., admin dashboard)\n */\nexport function getAllQueues() {\n  return {\n    forecastQueue: getForecastQueue(),\n    notificationQueue: getNotificationQueue(),\n    emailQueue: getEmailQueue(),\n    syncQueue: getSyncQueue(),\n    testmoImportQueue: getTestmoImportQueue(),\n    elasticsearchReindexQueue: getElasticsearchReindexQueue(),\n  };\n}\n", "import { Redis } from \"ioredis\"; // ioredis client type (compatible with Valkey)\nimport valkeyConnection from \"../../valkey\"; // Valkey connection\nimport { IssueData } from \"../adapters/IssueAdapter\";\n\nexport interface CachedIssue extends IssueData {\n  cachedAt: Date;\n  integrationId: number;\n}\n\nexport class IssueCache {\n  private valkey: Redis | null; // Valkey connection instance\n  private defaultTTL: number = 3600; // 1 hour default TTL\n\n  constructor() {\n    // Use a duplicate connection to avoid conflicts with BullMQ\n    this.valkey = valkeyConnection ? valkeyConnection.duplicate() : null;\n  }\n\n  private getCacheKey(integrationId: number, externalId: string): string {\n    return `issue:${integrationId}:${externalId}`;\n  }\n\n  private getBulkCacheKey(integrationId: number, projectId?: string): string {\n    return projectId\n      ? `issues:${integrationId}:project:${projectId}`\n      : `issues:${integrationId}:all`;\n  }\n\n  private getMetadataCacheKey(integrationId: number): string {\n    return `issue-metadata:${integrationId}`;\n  }\n\n  private getProjectCacheKey(integrationId: number): string {\n    return `projects:${integrationId}`;\n  }\n\n  async get(\n    integrationId: number,\n    externalId: string\n  ): Promise<CachedIssue | null> {\n    if (!this.valkey) return null;\n\n    const key = this.getCacheKey(integrationId, externalId);\n    const cached = await this.valkey.get(key);\n\n    if (!cached) {\n      return null;\n    }\n\n    try {\n      const data = JSON.parse(cached);\n      return {\n        ...data,\n        createdAt: new Date(data.createdAt),\n        updatedAt: new Date(data.updatedAt),\n        cachedAt: new Date(data.cachedAt),\n      } as CachedIssue;\n    } catch (error) {\n      console.error(\"Failed to parse cached issue:\", error);\n      await this.valkey.del(key); // Remove corrupted cache\n      return null;\n    }\n  }\n\n  async set(\n    integrationId: number,\n    externalId: string,\n    issue: IssueData,\n    ttl?: number\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getCacheKey(integrationId, externalId);\n    const cachedIssue: CachedIssue = {\n      ...issue,\n      integrationId,\n      cachedAt: new Date(),\n    };\n    const value = JSON.stringify(cachedIssue);\n    const cacheTTL = ttl ?? this.defaultTTL;\n\n    await this.valkey.setex(key, cacheTTL, value);\n  }\n\n  async getBulk(\n    integrationId: number,\n    projectId?: string\n  ): Promise<CachedIssue[]> {\n    if (!this.valkey) return [];\n\n    const key = this.getBulkCacheKey(integrationId, projectId);\n    const cached = await this.valkey.get(key);\n\n    if (!cached) {\n      return [];\n    }\n\n    try {\n      const data = JSON.parse(cached);\n      return data.map((item: any) => ({\n        ...item,\n        createdAt: new Date(item.createdAt),\n        updatedAt: new Date(item.updatedAt),\n        cachedAt: new Date(item.cachedAt),\n      })) as CachedIssue[];\n    } catch (error) {\n      console.error(\"Failed to parse cached issues:\", error);\n      await this.valkey.del(key);\n      return [];\n    }\n  }\n\n  async setBulk(\n    integrationId: number,\n    issues: IssueData[],\n    projectId?: string,\n    ttl?: number\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getBulkCacheKey(integrationId, projectId);\n    const cachedIssues = issues.map((issue) => ({\n      ...issue,\n      integrationId,\n      cachedAt: new Date(),\n    }));\n    const value = JSON.stringify(cachedIssues);\n    const cacheTTL = ttl ?? this.defaultTTL;\n\n    await this.valkey.setex(key, cacheTTL, value);\n\n    // Also cache individual issues\n    const pipeline = this.valkey.pipeline();\n    for (const issue of issues) {\n      const issueKey = this.getCacheKey(integrationId, issue.id);\n      const cachedIssue: CachedIssue = {\n        ...issue,\n        integrationId,\n        cachedAt: new Date(),\n      };\n      pipeline.setex(issueKey, cacheTTL, JSON.stringify(cachedIssue));\n    }\n    await pipeline.exec();\n  }\n\n  async invalidate(integrationId: number, externalId?: string): Promise<void> {\n    if (!this.valkey) return;\n\n    if (externalId) {\n      // Invalidate specific issue\n      const key = this.getCacheKey(integrationId, externalId);\n      await this.valkey.del(key);\n    } else {\n      // Invalidate all issues for integration using scan for better performance\n      const stream = this.valkey.scanStream({\n        match: `issue:${integrationId}:*`,\n        count: 100,\n      });\n\n      const pipeline = this.valkey.pipeline();\n      stream.on(\"data\", (keys: string[]) => {\n        if (keys.length) {\n          keys.forEach((key) => pipeline.del(key));\n        }\n      });\n\n      stream.on(\"end\", async () => {\n        await pipeline.exec();\n      });\n\n      // Also invalidate bulk caches\n      const bulkStream = this.valkey.scanStream({\n        match: `issues:${integrationId}:*`,\n        count: 100,\n      });\n\n      const bulkPipeline = this.valkey.pipeline();\n      bulkStream.on(\"data\", (keys: string[]) => {\n        if (keys.length) {\n          keys.forEach((key) => bulkPipeline.del(key));\n        }\n      });\n\n      bulkStream.on(\"end\", async () => {\n        await bulkPipeline.exec();\n      });\n    }\n  }\n\n  async invalidateProject(\n    integrationId: number,\n    projectId: string\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getBulkCacheKey(integrationId, projectId);\n    await this.valkey.del(key);\n  }\n\n  async getMetadata(\n    integrationId: number\n  ): Promise<Record<string, any> | null> {\n    if (!this.valkey) return null;\n\n    const key = this.getMetadataCacheKey(integrationId);\n    const cached = await this.valkey.get(key);\n\n    if (!cached) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(cached);\n    } catch (error) {\n      console.error(\"Failed to parse cached metadata:\", error);\n      await this.valkey.del(key);\n      return null;\n    }\n  }\n\n  async setMetadata(\n    integrationId: number,\n    metadata: Record<string, any>,\n    ttl: number = 7200 // 2 hours for metadata\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getMetadataCacheKey(integrationId);\n    const value = JSON.stringify(metadata);\n    await this.valkey.setex(key, ttl, value);\n  }\n\n  async getProjects(\n    integrationId: number\n  ): Promise<Array<{ id: string; key: string; name: string }> | null> {\n    if (!this.valkey) return null;\n\n    const key = this.getProjectCacheKey(integrationId);\n    const cached = await this.valkey.get(key);\n\n    if (!cached) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(cached);\n    } catch (error) {\n      console.error(\"Failed to parse cached projects:\", error);\n      await this.valkey.del(key);\n      return null;\n    }\n  }\n\n  async setProjects(\n    integrationId: number,\n    projects: Array<{ id: string; key: string; name: string }>,\n    ttl: number = 86400 // 24 hours for project list\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getProjectCacheKey(integrationId);\n    const value = JSON.stringify(projects);\n    await this.valkey.setex(key, ttl, value);\n  }\n\n  async getCacheTTL(\n    integrationId: number,\n    externalId: string\n  ): Promise<number> {\n    if (!this.valkey) return -1;\n\n    const key = this.getCacheKey(integrationId, externalId);\n    return await this.valkey.ttl(key);\n  }\n\n  async warmCache(\n    integrationId: number,\n    fetchFn: () => Promise<IssueData[]>,\n    projectId?: string\n  ): Promise<void> {\n    try {\n      const issues = await fetchFn();\n      await this.setBulk(integrationId, issues, projectId);\n    } catch (error) {\n      console.error(\"Failed to warm cache:\", error);\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.valkey) {\n      this.valkey.disconnect();\n    }\n  }\n}\n\nexport const issueCache = new IssueCache();\n", "import { prisma } from \"@/lib/prismaBase\";\nimport type { Integration, IntegrationProvider } from \"@prisma/client\";\nimport { IssueAdapter } from \"./adapters/IssueAdapter\";\nimport { JiraAdapter } from \"./adapters/JiraAdapter\";\nimport { GitHubAdapter } from \"./adapters/GitHubAdapter\";\nimport { AzureDevOpsAdapter } from \"./adapters/AzureDevOpsAdapter\";\nimport { SimpleUrlAdapter } from \"./adapters/SimpleUrlAdapter\";\nimport { EncryptionService, getMasterKey } from \"@/utils/encryption\";\n\n/**\n * Central service for managing integrations and their adapters\n */\nexport class IntegrationManager {\n  private static instance: IntegrationManager;\n  private adapterRegistry: Map<\n    IntegrationProvider,\n    new (config: any) => IssueAdapter\n  > = new Map();\n  private adapterCache: Map<string, IssueAdapter> = new Map();\n\n  private constructor() {\n    // Initialize with built-in adapters\n    this.registerAdapters();\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): IntegrationManager {\n    if (!IntegrationManager.instance) {\n      IntegrationManager.instance = new IntegrationManager();\n    }\n    return IntegrationManager.instance;\n  }\n\n  /**\n   * Register built-in adapters\n   */\n  private registerAdapters(): void {\n    // Register Jira adapter\n    this.registerAdapter(\"JIRA\", JiraAdapter);\n\n    // Register GitHub adapter\n    this.registerAdapter(\"GITHUB\", GitHubAdapter);\n\n    // Register Azure DevOps adapter\n    this.registerAdapter(\"AZURE_DEVOPS\", AzureDevOpsAdapter);\n\n    // Register Simple URL adapter\n    this.registerAdapter(\"SIMPLE_URL\", SimpleUrlAdapter);\n  }\n\n  /**\n   * Register a new adapter type\n   */\n  registerAdapter(\n    type: IntegrationProvider,\n    adapterClass: new (config: any) => IssueAdapter\n  ): void {\n    this.adapterRegistry.set(type, adapterClass);\n  }\n\n  /**\n   * Get adapter for a specific integration\n   */\n  async getAdapter(integrationId: string): Promise<IssueAdapter | null> {\n    // Check cache first\n    if (this.adapterCache.has(integrationId)) {\n      return this.adapterCache.get(integrationId)!;\n    }\n\n    // Fetch integration from database\n    const integration = await prisma.integration.findUnique({\n      where: { id: parseInt(integrationId) },\n      include: {\n        userIntegrationAuths: {\n          where: { isActive: true },\n          orderBy: { updatedAt: \"desc\" },\n          take: 1,\n        },\n      },\n    });\n\n    if (!integration) {\n      throw new Error(`Integration not found: ${integrationId}`);\n    }\n\n    if (integration.status !== \"ACTIVE\") {\n      throw new Error(`Integration is not active: ${integrationId}`);\n    }\n\n    const AdapterClass = this.adapterRegistry.get(integration.provider);\n    if (!AdapterClass) {\n      throw new Error(\n        `No adapter registered for integration provider: ${integration.provider}`\n      );\n    }\n\n    // Create adapter instance with configuration\n    const config = await this.buildAdapterConfig(integration);\n    const adapter = new AdapterClass(config);\n\n    const masterKey = getMasterKey();\n    const authData: any = {\n      type: this.mapAuthType(integration.authType),\n    };\n\n    // Handle API key or PAT authentication\n    if ((integration.authType === \"API_KEY\" || integration.authType === \"PERSONAL_ACCESS_TOKEN\") && integration.credentials) {\n      let credentials = integration.credentials as any;\n\n      // Check if credentials are encrypted\n      if (typeof credentials === \"object\" && \"encrypted\" in credentials) {\n        // Decrypt credentials\n        const decrypted = EncryptionService.decrypt(\n          credentials.encrypted as string,\n          masterKey\n        );\n        credentials = JSON.parse(decrypted);\n      }\n\n      // Add API key auth data from credentials\n      if (credentials.email) authData.email = credentials.email;\n      if (credentials.apiToken) authData.apiToken = credentials.apiToken;\n      // For GitHub PAT authentication\n      if (credentials.personalAccessToken) authData.apiKey = credentials.personalAccessToken;\n\n      // Add baseUrl from settings\n      if (integration.settings && typeof integration.settings === \"object\") {\n        const settings = integration.settings as Record<string, any>;\n        if (settings.baseUrl) authData.baseUrl = settings.baseUrl;\n      }\n\n      await adapter.authenticate(authData);\n    } \n    // Handle OAuth authentication\n    else if (integration.userIntegrationAuths.length > 0) {\n      const auth = integration.userIntegrationAuths[0];\n      authData.expiresAt = auth.tokenExpiresAt || undefined;\n\n      // Decrypt sensitive fields\n      if (auth.accessToken) {\n        authData.accessToken = EncryptionService.decrypt(\n          auth.accessToken,\n          masterKey\n        );\n      }\n      if (auth.refreshToken) {\n        authData.refreshToken = EncryptionService.decrypt(\n          auth.refreshToken,\n          masterKey\n        );\n      }\n\n      await adapter.authenticate(authData);\n    }\n\n    // Cache the adapter\n    this.adapterCache.set(integrationId, adapter);\n\n    return adapter;\n  }\n\n  /**\n   * Map IntegrationAuthType enum to authentication type string\n   */\n  private mapAuthType(authType: string): \"oauth\" | \"api_key\" | \"basic\" {\n    switch (authType) {\n      case \"OAUTH2\":\n        return \"oauth\";\n      case \"PERSONAL_ACCESS_TOKEN\":\n      case \"API_KEY\":\n        return \"api_key\";\n      default:\n        return \"basic\";\n    }\n  }\n\n  /**\n   * Build adapter configuration from integration data\n   */\n  private async buildAdapterConfig(integration: Integration): Promise<any> {\n    const config: any = {\n      integrationId: integration.id,\n      name: integration.name,\n      provider: integration.provider,\n    };\n\n    // Add provider-specific settings\n    if (integration.settings && typeof integration.settings === \"object\") {\n      Object.assign(config, integration.settings);\n    }\n\n    return config;\n  }\n\n  /**\n   * Clear adapter from cache\n   */\n  clearAdapter(integrationId: string): void {\n    this.adapterCache.delete(integrationId);\n  }\n\n  /**\n   * Clear all cached adapters\n   */\n  clearAllAdapters(): void {\n    this.adapterCache.clear();\n  }\n\n  /**\n   * Get all registered adapter types\n   */\n  getRegisteredTypes(): IntegrationProvider[] {\n    return Array.from(this.adapterRegistry.keys());\n  }\n\n  /**\n   * Check if adapter type is registered\n   */\n  isTypeRegistered(type: IntegrationProvider): boolean {\n    return this.adapterRegistry.has(type);\n  }\n\n  /**\n   * Get adapter capabilities for a specific integration\n   */\n  async getCapabilities(\n    integrationId: string\n  ): Promise<ReturnType<IssueAdapter[\"getCapabilities\"]> | null> {\n    const adapter = await this.getAdapter(integrationId);\n    return adapter ? adapter.getCapabilities() : null;\n  }\n\n  /**\n   * Validate integration configuration\n   */\n  async validateIntegration(\n    integrationId: string\n  ): Promise<{ valid: boolean; errors?: string[] }> {\n    try {\n      const adapter = await this.getAdapter(integrationId);\n      if (!adapter) {\n        return { valid: false, errors: [\"Adapter not found\"] };\n      }\n\n      // Check authentication\n      const isAuthenticated = await adapter.isAuthenticated();\n      if (!isAuthenticated) {\n        return { valid: false, errors: [\"Authentication failed\"] };\n      }\n\n      // Run adapter-specific validation if available\n      if (adapter.validateConfiguration) {\n        return await adapter.validateConfiguration();\n      }\n\n      return { valid: true };\n    } catch (error) {\n      return {\n        valid: false,\n        errors: [error instanceof Error ? error.message : \"Unknown error\"],\n      };\n    }\n  }\n}\n\n// Export singleton instance\nexport const integrationManager = IntegrationManager.getInstance();\n", "import {\n  IssueAdapter,\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n  WebhookData,\n  FieldMapping,\n} from \"./IssueAdapter\";\n\n/**\n * Base abstract class implementing common functionality for all issue tracking adapters\n */\nexport abstract class BaseAdapter implements IssueAdapter {\n  protected config: any;\n  protected authData?: AuthenticationData;\n  protected authenticated: boolean = false;\n\n  // Rate limiting configuration\n  protected rateLimitDelay: number = 1000; // Default 1 second between requests\n  protected lastRequestTime: number = 0;\n\n  // Retry configuration\n  protected maxRetries: number = 3;\n  protected retryDelay: number = 1000;\n\n  constructor(config: any) {\n    this.config = config;\n  }\n\n  /**\n   * Get the capabilities of this adapter\n   */\n  abstract getCapabilities(): IssueAdapterCapabilities;\n\n  /**\n   * Authenticate with the issue tracking system\n   */\n  async authenticate(authData: AuthenticationData): Promise<void> {\n    this.authData = authData;\n    await this.performAuthentication(authData);\n    this.authenticated = true;\n  }\n\n  /**\n   * Perform adapter-specific authentication\n   */\n  protected abstract performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void>;\n\n  /**\n   * Check if the current authentication is valid\n   */\n  async isAuthenticated(): Promise<boolean> {\n    if (!this.authenticated || !this.authData) {\n      return false;\n    }\n\n    // Check if token has expired\n    if (this.authData.expiresAt && this.authData.expiresAt < new Date()) {\n      this.authenticated = false;\n      return false;\n    }\n\n    // Perform adapter-specific validation if needed\n    return this.validateAuthentication();\n  }\n\n  /**\n   * Validate authentication (can be overridden by adapters)\n   */\n  protected async validateAuthentication(): Promise<boolean> {\n    return true;\n  }\n\n  /**\n   * Create a new issue\n   */\n  abstract createIssue(data: CreateIssueData): Promise<IssueData>;\n\n  /**\n   * Update an existing issue\n   */\n  abstract updateIssue(\n    issueId: string,\n    data: UpdateIssueData\n  ): Promise<IssueData>;\n\n  /**\n   * Get a single issue by ID\n   */\n  abstract getIssue(issueId: string): Promise<IssueData>;\n\n  /**\n   * Search for issues\n   */\n  abstract searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }>;\n\n  /**\n   * Link an issue to a test case\n   */\n  async linkToTestCase(\n    issueId: string,\n    testCaseId: string,\n    metadata?: any\n  ): Promise<void> {\n    // Default implementation adds a comment to the issue\n    const comment = `Linked to test case: ${testCaseId}${metadata ? \"\\nMetadata: \" + JSON.stringify(metadata) : \"\"}`;\n    await this.addComment(issueId, comment);\n  }\n\n  /**\n   * Add a comment to an issue (should be implemented by adapters that support it)\n   */\n  protected async addComment(issueId: string, comment: string): Promise<void> {\n    throw new Error(\"Adding comments is not supported by this adapter\");\n  }\n\n  /**\n   * Sync issue data from the external system\n   */\n  async syncIssue(issueId: string): Promise<IssueData> {\n    return this.getIssue(issueId);\n  }\n\n  /**\n   * Apply rate limiting\n   */\n  protected async applyRateLimit(): Promise<void> {\n    const now = Date.now();\n    const timeSinceLastRequest = now - this.lastRequestTime;\n\n    if (timeSinceLastRequest < this.rateLimitDelay) {\n      const delay = this.rateLimitDelay - timeSinceLastRequest;\n      await this.sleep(delay);\n    }\n\n    this.lastRequestTime = Date.now();\n  }\n\n  /**\n   * Execute request with retry logic\n   */\n  protected async executeWithRetry<T>(\n    operation: () => Promise<T>,\n    retries: number = this.maxRetries\n  ): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let i = 0; i <= retries; i++) {\n      try {\n        await this.applyRateLimit();\n        return await operation();\n      } catch (error) {\n        lastError = error as Error;\n\n        if (i < retries) {\n          const delay = this.retryDelay * Math.pow(2, i); // Exponential backoff\n          console.warn(`Request failed, retrying in ${delay}ms...`, error);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    throw lastError || new Error(\"Operation failed after retries\");\n  }\n\n  /**\n   * Sleep for specified milliseconds\n   */\n  protected sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Make HTTP request with authentication headers\n   */\n  protected async makeRequest<T>(\n    url: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    if (!this.authData) {\n      throw new Error(\"Not authenticated\");\n    }\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      ...((options.headers as Record<string, string>) || {}),\n    };\n\n    // Add authentication headers based on auth type\n    switch (this.authData.type) {\n      case \"oauth\":\n        headers[\"Authorization\"] = `Bearer ${this.authData.accessToken}`;\n        break;\n      case \"api_key\":\n        // Some APIs use Authorization header with token prefix\n        if (this.authData.apiKey) {\n          if (this.config.provider === \"AZURE_DEVOPS\") {\n            // Azure DevOps uses Basic auth with PAT\n            const credentials = Buffer.from(\n              `:${this.authData.apiKey}`\n            ).toString(\"base64\");\n            headers[\"Authorization\"] = `Basic ${credentials}`;\n          } else if (this.config.provider === \"GITHUB\") {\n            // GitHub: token prefix works with both classic and fine-grained PATs\n            headers[\"Authorization\"] = `token ${this.authData.apiKey}`;\n          } else {\n            // Default to X-API-Key header\n            headers[\"X-API-Key\"] = this.authData.apiKey;\n          }\n        }\n        break;\n      case \"basic\":\n        const credentials = Buffer.from(\n          `${this.authData.username}:${this.authData.password}`\n        ).toString(\"base64\");\n        headers[\"Authorization\"] = `Basic ${credentials}`;\n        break;\n    }\n\n    const response = await this.executeWithRetry(() =>\n      fetch(url, {\n        ...options,\n        headers,\n      })\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`HTTP ${response.status}: ${errorText}`);\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Build full URL from base URL and path\n   */\n  protected buildUrl(path: string): string {\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      throw new Error(\"Base URL not configured\");\n    }\n\n    // Ensure base URL doesn't end with slash and path starts with slash\n    const cleanBaseUrl = baseUrl.replace(/\\/$/, \"\");\n    const cleanPath = path.startsWith(\"/\") ? path : `/${path}`;\n\n    return `${cleanBaseUrl}${cleanPath}`;\n  }\n\n  /**\n   * Default implementation for webhook registration (not supported by default)\n   */\n  async registerWebhook?(\n    url: string,\n    events: string[],\n    secret?: string\n  ): Promise<WebhookData> {\n    throw new Error(\"Webhook registration is not supported by this adapter\");\n  }\n\n  /**\n   * Default implementation for webhook unregistration\n   */\n  async unregisterWebhook?(webhookId: string): Promise<void> {\n    throw new Error(\"Webhook unregistration is not supported by this adapter\");\n  }\n\n  /**\n   * Default implementation for webhook processing\n   */\n  async processWebhook?(payload: any, signature?: string): Promise<void> {\n    throw new Error(\"Webhook processing is not supported by this adapter\");\n  }\n\n  /**\n   * Get field mappings (can be overridden by adapters)\n   */\n  getFieldMappings?(): FieldMapping[] {\n    return [];\n  }\n\n  /**\n   * Validate configuration (can be overridden by adapters)\n   */\n  async validateConfiguration?(): Promise<{\n    valid: boolean;\n    errors?: string[];\n  }> {\n    const errors: string[] = [];\n\n    if (!this.authData) {\n      errors.push(\"No authentication data provided\");\n    }\n\n    if (!this.config.baseUrl && !this.authData?.baseUrl) {\n      errors.push(\"Base URL is required\");\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n}\n", "import { BaseAdapter } from \"./BaseAdapter\";\nimport {\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n} from \"./IssueAdapter\";\n\n/**\n * Jira integration adapter implementing OAuth authentication\n */\nexport class JiraAdapter extends BaseAdapter {\n  public supportsOAuth = true;\n\n  private clientId: string;\n  private clientSecret: string;\n  private redirectUri: string;\n  private cloudId?: string;\n  private apiEmail?: string;\n  private apiToken?: string;\n  private baseUrl?: string;\n\n  constructor(config: any) {\n    super(config);\n\n    // OAuth configuration\n    this.clientId = process.env.JIRA_CLIENT_ID || \"\";\n    this.clientSecret = process.env.JIRA_CLIENT_SECRET || \"\";\n    this.redirectUri = process.env.JIRA_REDIRECT_URI || \"\";\n\n    // Base URL from config if provided\n    if (config.baseUrl) {\n      this.baseUrl = config.baseUrl;\n    }\n  }\n\n  getCapabilities(): IssueAdapterCapabilities {\n    return {\n      createIssue: true,\n      updateIssue: true,\n      linkIssue: true,\n      syncIssue: true,\n      searchIssues: true,\n      webhooks: true,\n      customFields: true,\n      attachments: true,\n    };\n  }\n\n  protected async performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void> {\n    if (authData.type === \"api_key\") {\n      // Handle API key authentication\n      if (!authData.email || !authData.apiToken || !authData.baseUrl) {\n        throw new Error(\n          \"API key authentication requires email, apiToken, and baseUrl\"\n        );\n      }\n\n      this.apiEmail = authData.email;\n      this.apiToken = authData.apiToken;\n      this.baseUrl = authData.baseUrl;\n\n      // Test the connection\n      const response = await fetch(`${this.baseUrl}/rest/api/3/myself`, {\n        headers: {\n          Authorization: `Basic ${Buffer.from(`${this.apiEmail}:${this.apiToken}`).toString(\"base64\")}`,\n          Accept: \"application/json\",\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          `Jira API authentication failed: ${response.statusText}`\n        );\n      }\n    } else if (authData.type === \"oauth\") {\n      // OAuth authentication\n      if (!this.clientId || !this.clientSecret || !this.redirectUri) {\n        throw new Error(\n          \"Jira OAuth configuration is incomplete. Please check environment variables.\"\n        );\n      }\n\n      // Get accessible resources to determine the cloud ID\n      if (!this.cloudId) {\n        const resources = await this.getAccessibleResources(\n          authData.accessToken!\n        );\n        if (resources.length === 0) {\n          throw new Error(\"No accessible Jira resources found\");\n        }\n        this.cloudId = resources[0].id;\n      }\n    } else {\n      throw new Error(\n        \"Jira adapter only supports OAuth and API key authentication\"\n      );\n    }\n  }\n\n  /**\n   * Get available projects\n   */\n  async getProjects(): Promise<\n    Array<{ id: string; key: string; name: string }>\n  > {\n    if (this.apiEmail && this.apiToken && this.baseUrl) {\n      // API key authentication\n      const response = await fetch(\n        `${this.baseUrl}/rest/api/3/project/search`,\n        {\n          headers: {\n            Authorization: `Basic ${Buffer.from(`${this.apiEmail}:${this.apiToken}`).toString(\"base64\")}`,\n            Accept: \"application/json\",\n          },\n        }\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch projects: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return (data.values || []).map((project: any) => ({\n        id: project.id,\n        key: project.key,\n        name: project.name,\n      }));\n    } else if (this.authData?.accessToken && this.cloudId) {\n      // OAuth authentication\n      const response = await this.makeRequest<any>(\n        `https://api.atlassian.com/ex/jira/${this.cloudId}/rest/api/3/project/search`\n      );\n\n      return (response.values || []).map((project: any) => ({\n        id: project.id,\n        key: project.key,\n        name: project.name,\n      }));\n    } else {\n      throw new Error(\"Not authenticated\");\n    }\n  }\n\n  /**\n   * Get OAuth authorization URL\n   */\n  getAuthorizationUrl(state: string): string {\n    const params = new URLSearchParams({\n      audience: \"api.atlassian.com\",\n      client_id: this.clientId,\n      scope: \"read:jira-work write:jira-work read:jira-user offline_access\",\n      redirect_uri: this.redirectUri,\n      state: state,\n      response_type: \"code\",\n      prompt: \"consent\",\n    });\n\n    return `https://auth.atlassian.com/authorize?${params.toString()}`;\n  }\n\n  /**\n   * Exchange authorization code for tokens\n   */\n  async exchangeCodeForTokens(code: string): Promise<{\n    accessToken: string;\n    refreshToken?: string;\n    expiresAt?: Date;\n  }> {\n    const response = await fetch(\"https://auth.atlassian.com/oauth/token\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        grant_type: \"authorization_code\",\n        client_id: this.clientId,\n        client_secret: this.clientSecret,\n        code: code,\n        redirect_uri: this.redirectUri,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to exchange code for tokens: ${error}`);\n    }\n\n    const data = await response.json();\n\n    return {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token,\n      expiresAt: data.expires_in\n        ? new Date(Date.now() + data.expires_in * 1000)\n        : undefined,\n    };\n  }\n\n  /**\n   * Refresh OAuth tokens\n   */\n  async refreshTokens(refreshToken: string): Promise<{\n    accessToken: string;\n    refreshToken?: string;\n    expiresAt?: Date;\n  }> {\n    const response = await fetch(\"https://auth.atlassian.com/oauth/token\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        grant_type: \"refresh_token\",\n        client_id: this.clientId,\n        client_secret: this.clientSecret,\n        refresh_token: refreshToken,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to refresh tokens: ${error}`);\n    }\n\n    const data = await response.json();\n\n    return {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token || refreshToken,\n      expiresAt: data.expires_in\n        ? new Date(Date.now() + data.expires_in * 1000)\n        : undefined,\n    };\n  }\n\n  /**\n   * Get accessible Jira resources\n   */\n  private async getAccessibleResources(accessToken: string): Promise<\n    Array<{\n      id: string;\n      url: string;\n      name: string;\n      scopes: string[];\n    }>\n  > {\n    const response = await fetch(\n      \"https://api.atlassian.com/oauth/token/accessible-resources\",\n      {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          Accept: \"application/json\",\n        },\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(\"Failed to get accessible resources\");\n    }\n\n    return response.json();\n  }\n\n  protected buildUrl(path: string): string {\n    // For API key auth, use the base URL directly\n    if (this.apiEmail && this.apiToken && this.baseUrl) {\n      return `${this.baseUrl}${path}`;\n    }\n\n    // For OAuth, use cloud ID\n    if (!this.cloudId) {\n      throw new Error(\"Cloud ID not set. Please authenticate first.\");\n    }\n    return `https://api.atlassian.com/ex/jira/${this.cloudId}${path}`;\n  }\n\n  /**\n   * Override makeRequest to handle Jira's API key authentication\n   */\n  protected async makeRequest<T = any>(\n    url: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    // If using API key auth, bypass the base class and handle it directly\n    if (this.apiEmail && this.apiToken) {\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        ...((options.headers as any) || {}),\n      };\n\n      // Jira uses Basic auth with email:apiToken\n      const credentials = Buffer.from(\n        `${this.apiEmail}:${this.apiToken}`\n      ).toString(\"base64\");\n      headers[\"Authorization\"] = `Basic ${credentials}`;\n\n      const response = await fetch(url, {\n        ...options,\n        headers,\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`HTTP ${response.status}: ${errorText}`);\n      }\n\n      return response.json();\n    }\n\n    // Otherwise use the base class implementation for OAuth\n    return super.makeRequest<T>(url, options);\n  }\n\n  async createIssue(data: CreateIssueData): Promise<IssueData> {\n    // Determine if projectId is a key (e.g., \"TPI\") or an ID (numeric)\n    const projectField = isNaN(Number(data.projectId))\n      ? { key: data.projectId } // It's a project key\n      : { id: data.projectId }; // It's a project ID\n\n    // Convert description to ADF format\n    let descriptionField;\n    if (data.description) {\n      // console.log('[JiraAdapter] Raw description:', data.description);\n\n      // Check if description is TipTap JSON\n      if (\n        typeof data.description === \"object\" &&\n        data.description &&\n        \"type\" in data.description &&\n        data.description.type === \"doc\"\n      ) {\n        // Direct TipTap JSON to ADF conversion\n        descriptionField = this.tiptapToAdf(data.description);\n        // console.log('[JiraAdapter] Converted ADF from TipTap:', JSON.stringify(descriptionField, null, 2));\n      } else if (\n        typeof data.description === \"string\" &&\n        data.description.includes(\"<\") &&\n        data.description.includes(\">\")\n      ) {\n        // HTML string - use HTML to ADF converter\n        descriptionField = this.htmlToAdf(data.description);\n        // console.log('[JiraAdapter] Converted ADF from HTML:', JSON.stringify(descriptionField, null, 2));\n      } else if (typeof data.description === \"string\") {\n        // Plain text\n        descriptionField = {\n          type: \"doc\",\n          version: 1,\n          content: [\n            {\n              type: \"paragraph\",\n              content: [\n                {\n                  type: \"text\",\n                  text: data.description,\n                },\n              ],\n            },\n          ],\n        };\n      }\n    } else {\n      descriptionField = null;\n    }\n\n    // Extract reporter from customFields if present\n    const { reporter, ...otherCustomFields } = data.customFields || {};\n\n    // console.log(\"[JiraAdapter] Incoming data.customFields:\", JSON.stringify(data.customFields, null, 2));\n    // console.log(\"[JiraAdapter] Extracted reporter:\", JSON.stringify(reporter, null, 2));\n    // console.log(\"[JiraAdapter] Other custom fields:\", JSON.stringify(otherCustomFields, null, 2));\n\n    const jiraPayload = {\n      fields: {\n        project: projectField,\n        summary: data.title,\n        description: descriptionField,\n        issuetype: { id: data.issueType || \"10001\" }, // Default to Task\n        priority: data.priority ? { id: data.priority } : undefined,\n        assignee: data.assigneeId ? { id: data.assigneeId } : undefined,\n        reporter: reporter || undefined, // Reporter is a system field, not custom\n        labels: data.labels || [],\n        ...otherCustomFields,\n      },\n    };\n\n    // console.log(\"[JiraAdapter] Creating issue with payload:\", JSON.stringify(jiraPayload, null, 2));\n    // console.log(\"[JiraAdapter] Reporter field in payload:\", jiraPayload.fields.reporter);\n\n    try {\n      const response = await this.makeRequest<any>(\n        this.buildUrl(\"/rest/api/3/issue\"),\n        {\n          method: \"POST\",\n          body: JSON.stringify(jiraPayload),\n        }\n      );\n\n      // console.log(\"[JiraAdapter] Create issue response:\", JSON.stringify(response, null, 2));\n\n      // The create response only contains id, key, and self\n      // We need to fetch the full issue details\n      if (response.key) {\n        const fullIssue = await this.getIssue(response.key);\n        // console.log(\"[JiraAdapter] Created issue reporter:\", fullIssue.reporter);\n        return fullIssue;\n      }\n\n      throw new Error(\"Failed to create issue - no key returned\");\n    } catch (error) {\n      console.error(\"[JiraAdapter] Failed to create issue:\", error);\n      if (error instanceof Error) {\n        throw error;\n      }\n      throw new Error(\"Failed to create issue in Jira\");\n    }\n  }\n\n  async updateIssue(\n    issueId: string,\n    data: UpdateIssueData\n  ): Promise<IssueData> {\n    const updatePayload: any = { fields: {} };\n\n    if (data.title !== undefined) {\n      updatePayload.fields.summary = data.title;\n    }\n\n    if (data.description !== undefined) {\n      // Check if description is TipTap JSON\n      if (\n        typeof data.description === \"object\" &&\n        data.description &&\n        \"type\" in data.description &&\n        data.description.type === \"doc\"\n      ) {\n        // Direct TipTap JSON to ADF conversion\n        updatePayload.fields.description = this.tiptapToAdf(data.description);\n      } else if (\n        typeof data.description === \"string\" &&\n        data.description.includes(\"<\") &&\n        data.description.includes(\">\")\n      ) {\n        // HTML string - use HTML to ADF converter\n        updatePayload.fields.description = this.htmlToAdf(data.description);\n      } else if (typeof data.description === \"string\") {\n        // Plain text\n        updatePayload.fields.description = {\n          type: \"doc\",\n          version: 1,\n          content: [\n            {\n              type: \"paragraph\",\n              content: [\n                {\n                  type: \"text\",\n                  text: data.description,\n                },\n              ],\n            },\n          ],\n        };\n      }\n    }\n\n    if (data.priority !== undefined) {\n      updatePayload.fields.priority = { id: data.priority };\n    }\n\n    if (data.assigneeId !== undefined) {\n      updatePayload.fields.assignee = { id: data.assigneeId };\n    }\n\n    if (data.labels !== undefined) {\n      updatePayload.fields.labels = data.labels;\n    }\n\n    if (data.customFields) {\n      Object.assign(updatePayload.fields, data.customFields);\n    }\n\n    await this.makeRequest<any>(this.buildUrl(`/rest/api/3/issue/${issueId}`), {\n      method: \"PUT\",\n      body: JSON.stringify(updatePayload),\n    });\n\n    // Handle status transition separately if provided\n    if (data.status !== undefined) {\n      await this.transitionIssue(issueId, data.status);\n    }\n\n    return this.getIssue(issueId);\n  }\n\n  async getIssue(issueId: string): Promise<IssueData> {\n    // Explicitly request all fields we need, including issuetype with iconUrl\n    const params = new URLSearchParams({\n      fields:\n        \"summary,description,status,priority,issuetype,assignee,reporter,labels,created,updated\",\n      expand: \"names,schema\",\n    });\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/rest/api/3/issue/${issueId}?${params.toString()}`)\n    );\n\n    return this.mapJiraIssue(response);\n  }\n\n  async searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const jql: string[] = [];\n\n    if (options.projectId) {\n      jql.push(`project = ${options.projectId}`);\n    }\n\n    if (options.query) {\n      const query = options.query.trim();\n      const jqlConditions: string[] = [];\n\n      // Check if the query looks like a complete issue key (contains hyphen and follows pattern)\n      if (/^[A-Za-z]+-\\d+$/.test(query)) {\n        // Complete issue key - use exact match\n        jqlConditions.push(`key = \"${query.toUpperCase()}\"`);\n      }\n\n      // Always include text search in summary and description\n      jqlConditions.push(`summary ~ \"${query}*\"`);\n      jqlConditions.push(`description ~ \"${query}*\"`);\n\n      jql.push(`(${jqlConditions.join(\" OR \")})`);\n    }\n\n    if (options.status && options.status.length > 0) {\n      jql.push(`status IN (${options.status.map((s) => `\"${s}\"`).join(\", \")})`);\n    }\n\n    if (options.assignee) {\n      jql.push(`assignee = ${options.assignee}`);\n    }\n\n    if (options.labels && options.labels.length > 0) {\n      jql.push(`labels IN (${options.labels.map((l) => `\"${l}\"`).join(\", \")})`);\n    }\n\n    // Ensure the query is always bounded - Jira rejects unbounded queries\n    let jqlString: string;\n    if (jql.length > 0) {\n      jqlString = jql.join(\" AND \") + \" ORDER BY created DESC\";\n    } else if (options.fullSync) {\n      // Manual full sync without project filter - sync last year of issues\n      // Jira requires bounded queries, so we use a generous 1-year window\n      jqlString = \"created >= -365d ORDER BY created DESC\";\n    } else {\n      // Automatic/incremental sync - limit to last 30 days\n      jqlString = \"created >= -30d ORDER BY created DESC\";\n    }\n    const params = new URLSearchParams({\n      jql: jqlString,\n      startAt: (options.offset || 0).toString(),\n      maxResults: (options.limit || 50).toString(),\n      fields:\n        \"summary,description,status,priority,issuetype,assignee,reporter,labels,created,updated\",\n      expand: \"names,schema\",\n    });\n\n    const searchUrl = this.buildUrl(\n      `/rest/api/3/search/jql?${params.toString()}`\n    );\n\n    const response = await this.makeRequest<any>(searchUrl);\n\n    return {\n      issues: response.issues.map((issue: any) => this.mapJiraIssue(issue)),\n      total: response.total,\n      hasMore: response.startAt + response.issues.length < response.total,\n    };\n  }\n\n  protected async addComment(issueId: string, comment: string): Promise<void> {\n    await this.makeRequest(\n      this.buildUrl(`/rest/api/3/issue/${issueId}/comment`),\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          body: {\n            type: \"doc\",\n            version: 1,\n            content: [\n              {\n                type: \"paragraph\",\n                content: [\n                  {\n                    type: \"text\",\n                    text: comment,\n                  },\n                ],\n              },\n            ],\n          },\n        }),\n      }\n    );\n  }\n\n  private async transitionIssue(\n    issueId: string,\n    targetStatus: string\n  ): Promise<void> {\n    // Get available transitions\n    const transitions = await this.makeRequest<any>(\n      this.buildUrl(`/rest/api/3/issue/${issueId}/transitions`)\n    );\n\n    // Find the transition that leads to the target status\n    const transition = transitions.transitions.find(\n      (t: any) => t.to.name.toLowerCase() === targetStatus.toLowerCase()\n    );\n\n    if (!transition) {\n      throw new Error(`No transition available to status: ${targetStatus}`);\n    }\n\n    // Execute the transition\n    await this.makeRequest(\n      this.buildUrl(`/rest/api/3/issue/${issueId}/transitions`),\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          transition: { id: transition.id },\n        }),\n      }\n    );\n  }\n\n  private mapJiraIssue(jiraIssue: any): IssueData {\n    // Validate that we have the required data structure\n    if (!jiraIssue) {\n      throw new Error(\"Invalid Jira issue: issue object is null or undefined\");\n    }\n    if (!jiraIssue.fields) {\n      throw new Error(\n        `Invalid Jira issue ${jiraIssue.key || jiraIssue.id}: missing fields object`\n      );\n    }\n\n    const fields = jiraIssue.fields;\n\n    // Validate required fields\n    if (!fields.summary) {\n      throw new Error(\n        `Invalid Jira issue ${jiraIssue.key || jiraIssue.id}: missing summary field`\n      );\n    }\n    if (!fields.status) {\n      throw new Error(\n        `Invalid Jira issue ${jiraIssue.key || jiraIssue.id}: missing status field`\n      );\n    }\n\n    return {\n      id: jiraIssue.id,\n      key: jiraIssue.key,\n      title: fields.summary,\n      description: this.extractDescription(fields.description),\n      status: fields.status.name,\n      priority: fields.priority?.name,\n      issueType: fields.issuetype\n        ? {\n            id: fields.issuetype.id,\n            name: fields.issuetype.name,\n            iconUrl: fields.issuetype.iconUrl,\n          }\n        : undefined,\n      assignee: fields.assignee\n        ? {\n            id: fields.assignee.accountId,\n            name: fields.assignee.displayName,\n            email: fields.assignee.emailAddress,\n          }\n        : undefined,\n      reporter: fields.reporter\n        ? {\n            id: fields.reporter.accountId,\n            name: fields.reporter.displayName,\n            email: fields.reporter.emailAddress,\n          }\n        : undefined,\n      labels: fields.labels || [],\n      customFields: this.extractCustomFields(fields),\n      createdAt: new Date(fields.created),\n      updatedAt: new Date(fields.updated),\n      url: `${jiraIssue.self.split(\"/rest/\")[0]}/browse/${jiraIssue.key}`,\n    };\n  }\n\n  private extractDescription(description: any): string | undefined {\n    if (!description) return undefined;\n\n    // Handle ADF (Atlassian Document Format)\n    if (description.type === \"doc\" && description.content) {\n      return this.adfToHtml(description.content);\n    }\n\n    // Handle plain text\n    return description.toString();\n  }\n\n  private adfToHtml(content: any[]): string {\n    let html = \"\";\n\n    for (const node of content) {\n      html += this.convertAdfNodeToHtml(node);\n    }\n\n    return html.trim();\n  }\n\n  private convertAdfNodeToHtml(node: any): string {\n    if (!node) return \"\";\n\n    switch (node.type) {\n      case \"paragraph\":\n        let paragraphContent = \"\";\n        if (node.content) {\n          paragraphContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<p>${paragraphContent}</p>`;\n\n      case \"heading\":\n        let headingContent = \"\";\n        if (node.content) {\n          headingContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        const level = Math.min(node.attrs?.level || 1, 6);\n        return `<h${level}>${headingContent}</h${level}>`;\n\n      case \"bulletList\":\n        let bulletListContent = \"\";\n        if (node.content) {\n          bulletListContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<ul>${bulletListContent}</ul>`;\n\n      case \"orderedList\":\n        let orderedListContent = \"\";\n        if (node.content) {\n          orderedListContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<ol>${orderedListContent}</ol>`;\n\n      case \"listItem\":\n        let itemContent = \"\";\n        if (node.content) {\n          // For list items, we need to handle nested content properly\n          itemContent = node.content\n            .map((child: any) => {\n              // If it's a paragraph inside a list item, don't wrap it in <p> tags\n              if (child.type === \"paragraph\") {\n                return child.content\n                  ? child.content\n                      .map((grandChild: any) =>\n                        this.convertAdfNodeToHtml(grandChild)\n                      )\n                      .join(\"\")\n                  : \"\";\n              }\n              return this.convertAdfNodeToHtml(child);\n            })\n            .join(\"\");\n        }\n        return `<li>${itemContent}</li>`;\n\n      case \"blockquote\":\n        let quoteContent = \"\";\n        if (node.content) {\n          quoteContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<blockquote>${quoteContent}</blockquote>`;\n\n      case \"codeBlock\":\n        let codeContent = \"\";\n        if (node.content) {\n          codeContent = node.content\n            .map((child: any) => {\n              if (child.type === \"text\") {\n                return child.text || \"\";\n              }\n              return this.convertAdfNodeToHtml(child);\n            })\n            .join(\"\");\n        }\n        const language = node.attrs?.language || \"\";\n        return `<pre><code${language ? ` class=\"language-${language}\"` : \"\"}>${this.escapeHtml(codeContent)}</code></pre>`;\n\n      case \"text\":\n        let textContent = node.text || \"\";\n\n        // Escape HTML entities first\n        textContent = this.escapeHtml(textContent);\n\n        // Apply marks (formatting)\n        if (node.marks && Array.isArray(node.marks)) {\n          for (const mark of node.marks) {\n            switch (mark.type) {\n              case \"strong\":\n                textContent = `<strong>${textContent}</strong>`;\n                break;\n              case \"em\":\n                textContent = `<em>${textContent}</em>`;\n                break;\n              case \"underline\":\n                textContent = `<u>${textContent}</u>`;\n                break;\n              case \"strike\":\n                textContent = `<s>${textContent}</s>`;\n                break;\n              case \"code\":\n                textContent = `<code>${textContent}</code>`;\n                break;\n              case \"link\":\n                const href = this.escapeHtml(mark.attrs?.href || \"\");\n                textContent = `<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${textContent}</a>`;\n                break;\n            }\n          }\n        }\n\n        return textContent;\n\n      case \"hardBreak\":\n        return \"<br>\";\n\n      case \"rule\":\n        return \"<hr>\";\n\n      case \"mention\":\n        // Handle user mentions\n        const mentionText =\n          node.attrs?.text || node.attrs?.displayName || \"@user\";\n        return `<span class=\"mention\">${this.escapeHtml(mentionText)}</span>`;\n\n      case \"emoji\":\n        // Handle emojis\n        const emojiText = node.attrs?.shortName || node.attrs?.text || \"\";\n        return this.escapeHtml(emojiText);\n\n      case \"table\":\n        let tableContent = \"\";\n        if (node.content) {\n          tableContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<table>${tableContent}</table>`;\n\n      case \"tableRow\":\n        let rowContent = \"\";\n        if (node.content) {\n          rowContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<tr>${rowContent}</tr>`;\n\n      case \"tableCell\":\n      case \"tableHeader\":\n        let cellContent = \"\";\n        if (node.content) {\n          cellContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        const tag = node.type === \"tableHeader\" ? \"th\" : \"td\";\n        return `<${tag}>${cellContent}</${tag}>`;\n\n      default:\n        // For unknown types, try to extract content from children\n        if (node.content) {\n          return node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        // If it has text directly, return it escaped\n        if (node.text) {\n          return this.escapeHtml(node.text);\n        }\n        return \"\";\n    }\n  }\n\n  private escapeHtml(text: string): string {\n    const map: { [key: string]: string } = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&#39;\",\n    };\n    return text.replace(/[&<>\"']/g, (m) => map[m]);\n  }\n\n  async getIssueTypes(\n    projectKey: string\n  ): Promise<Array<{ id: string; name: string }>> {\n    try {\n      // First, get the project details to get available issue types\n      const projectUrl = this.buildUrl(`/rest/api/3/project/${projectKey}`);\n      const project = await this.makeRequest<any>(projectUrl);\n\n      // Extract issue types from the project\n      const issueTypes = project.issueTypes || [];\n\n      return issueTypes.map((type: any) => ({\n        id: type.id,\n        name: type.name,\n      }));\n    } catch (error) {\n      console.error(\"Failed to fetch issue types:\", error);\n      // If that fails, try to get all issue types and filter by project\n      try {\n        const allTypesUrl = this.buildUrl(`/rest/api/3/issuetype`);\n        const allTypes = await this.makeRequest<any[]>(allTypesUrl);\n\n        // For now, return all non-subtask issue types as a fallback\n        return allTypes\n          .filter((type: any) => !type.subtask)\n          .map((type: any) => ({\n            id: type.id,\n            name: type.name,\n          }));\n      } catch (fallbackError) {\n        console.error(\"Failed to fetch issue types (fallback):\", fallbackError);\n        throw new Error(\"Failed to fetch issue types from Jira\");\n      }\n    }\n  }\n\n  async getIssueTypeFields(\n    projectKey: string,\n    issueTypeId: string\n  ): Promise<any[]> {\n    try {\n      // Get create issue metadata for the specific issue type\n      const url = this.buildUrl(\n        `/rest/api/3/issue/createmeta?projectKeys=${projectKey}&issuetypeIds=${issueTypeId}&expand=projects.issuetypes.fields`\n      );\n\n      const metadata = await this.makeRequest<any>(url);\n\n      // Extract fields from the response\n      const project = metadata.projects?.[0];\n      const issueType = project?.issuetypes?.[0];\n\n      if (!issueType?.fields) {\n        return [];\n      }\n\n      // Convert fields object to array and filter out system fields we handle separately\n      const fields = Object.entries(issueType.fields)\n        .filter(([key]) => {\n          // Exclude fields we already handle in the UI\n          const excludedFields = [\n            \"summary\",\n            \"description\",\n            \"issuetype\",\n            \"project\",\n            \"reporter\",\n          ];\n          return !excludedFields.includes(key);\n        })\n        .map(([key, field]: [string, any]) => ({\n          key,\n          name: field.name,\n          required: field.required || false,\n          schema: field.schema,\n          allowedValues: field.allowedValues,\n          hasDefaultValue: field.hasDefaultValue || false,\n          defaultValue: field.defaultValue,\n          autoCompleteUrl: field.autoCompleteUrl,\n        }));\n\n      return fields;\n    } catch (error) {\n      console.error(\"Failed to fetch issue type fields:\", error);\n      return [];\n    }\n  }\n\n  private extractCustomFields(fields: any): Record<string, any> {\n    const customFields: Record<string, any> = {};\n\n    // Extract fields that start with \"customfield_\"\n    for (const [key, value] of Object.entries(fields)) {\n      if (key.startsWith(\"customfield_\") && value !== null) {\n        customFields[key] = value;\n      }\n    }\n\n    return customFields;\n  }\n\n  private tiptapToAdf(tiptapJson: any): any {\n    // Convert TipTap JSON directly to Atlassian Document Format (ADF)\n    const doc: any = {\n      type: \"doc\",\n      version: 1,\n      content: [],\n    };\n\n    if (!tiptapJson || !tiptapJson.content) {\n      return doc;\n    }\n\n    // Process each node in the TipTap content\n    tiptapJson.content.forEach((node: any) => {\n      const adfNode = this.convertTiptapNodeToAdf(node);\n      if (adfNode) {\n        doc.content.push(adfNode);\n      }\n    });\n\n    // If no content was added, add empty paragraph\n    if (doc.content.length === 0) {\n      doc.content.push({\n        type: \"paragraph\",\n        content: [],\n      });\n    }\n\n    return doc;\n  }\n\n  private convertTiptapNodeToAdf(node: any): any {\n    if (!node) return null;\n\n    switch (node.type) {\n      case \"paragraph\":\n        return {\n          type: \"paragraph\",\n          content: this.convertTiptapMarks(node.content || []),\n        };\n\n      case \"heading\":\n        return {\n          type: \"heading\",\n          attrs: {\n            level: node.attrs?.level || 1,\n          },\n          content: this.convertTiptapMarks(node.content || []),\n        };\n\n      case \"bulletList\":\n        return {\n          type: \"bulletList\",\n          content: (node.content || [])\n            .map((item: any) => this.convertTiptapNodeToAdf(item))\n            .filter(Boolean),\n        };\n\n      case \"orderedList\":\n        return {\n          type: \"orderedList\",\n          content: (node.content || [])\n            .map((item: any) => this.convertTiptapNodeToAdf(item))\n            .filter(Boolean),\n        };\n\n      case \"listItem\":\n        return {\n          type: \"listItem\",\n          content: (node.content || [])\n            .map((item: any) => this.convertTiptapNodeToAdf(item))\n            .filter(Boolean),\n        };\n\n      case \"blockquote\":\n        return {\n          type: \"blockquote\",\n          content: (node.content || [])\n            .map((item: any) => this.convertTiptapNodeToAdf(item))\n            .filter(Boolean),\n        };\n\n      case \"codeBlock\":\n        return {\n          type: \"codeBlock\",\n          attrs: {\n            language: node.attrs?.language || null,\n          },\n          content: [\n            {\n              type: \"text\",\n              text: node.content?.map((c: any) => c.text || \"\").join(\"\") || \"\",\n            },\n          ],\n        };\n\n      case \"horizontalRule\":\n        return {\n          type: \"rule\",\n        };\n\n      case \"hardBreak\":\n        return {\n          type: \"hardBreak\",\n        };\n\n      case \"text\":\n        // Text nodes are handled by convertTiptapMarks\n        return null;\n\n      default:\n        // For unknown types, try to extract text content\n        if (node.content) {\n          return {\n            type: \"paragraph\",\n            content: this.convertTiptapMarks(node.content),\n          };\n        }\n        return null;\n    }\n  }\n\n  private convertTiptapMarks(content: any[]): any[] {\n    if (!content || !Array.isArray(content)) return [];\n\n    const result: any[] = [];\n\n    content.forEach((node: any) => {\n      if (node.type === \"text\") {\n        const textNode: any = {\n          type: \"text\",\n          text: node.text || \"\",\n        };\n\n        // Convert TipTap marks to ADF marks\n        if (node.marks && Array.isArray(node.marks)) {\n          const adfMarks: any[] = [];\n\n          node.marks.forEach((mark: any) => {\n            switch (mark.type) {\n              case \"bold\":\n              case \"strong\":\n                adfMarks.push({ type: \"strong\" });\n                break;\n              case \"italic\":\n              case \"em\":\n                adfMarks.push({ type: \"em\" });\n                break;\n              case \"underline\":\n                adfMarks.push({ type: \"underline\" });\n                break;\n              case \"strike\":\n                adfMarks.push({ type: \"strike\" });\n                break;\n              case \"code\":\n                adfMarks.push({ type: \"code\" });\n                break;\n              case \"link\":\n                adfMarks.push({\n                  type: \"link\",\n                  attrs: {\n                    href: mark.attrs?.href || \"\",\n                  },\n                });\n                break;\n            }\n          });\n\n          if (adfMarks.length > 0) {\n            textNode.marks = adfMarks;\n          }\n        }\n\n        result.push(textNode);\n      } else {\n        // Handle nested nodes\n        const converted = this.convertTiptapNodeToAdf(node);\n        if (converted) {\n          result.push(converted);\n        }\n      }\n    });\n\n    return result;\n  }\n\n  private htmlToAdf(html: string): any {\n    // Enhanced HTML to ADF conversion for TipTap output\n    const doc: any = {\n      type: \"doc\",\n      version: 1,\n      content: [],\n    };\n\n    // Parse HTML more carefully to preserve formatting\n    // Split by paragraphs first\n    const paragraphs = html.split(/<\\/p>|<\\/h[1-6]>|<\\/li>|<\\/blockquote>/);\n\n    paragraphs.forEach((paragraph) => {\n      if (!paragraph.trim()) return;\n\n      // Handle headings\n      const headingMatch = paragraph.match(/<h([1-6])>/);\n      if (headingMatch) {\n        const level = parseInt(headingMatch[1]);\n        const text = paragraph.replace(/<[^>]*>/g, \"\").trim();\n        if (text) {\n          doc.content.push({\n            type: \"heading\",\n            attrs: { level: Math.min(level, 6) },\n            content: [\n              {\n                type: \"text\",\n                text: text,\n              },\n            ],\n          });\n        }\n        return;\n      }\n\n      // Handle lists\n      if (paragraph.includes(\"<ul>\") || paragraph.includes(\"<ol>\")) {\n        const listType = paragraph.includes(\"<ul>\")\n          ? \"bulletList\"\n          : \"orderedList\";\n        const listItems = paragraph.split(/<\\/li>/);\n        const listContent: any[] = [];\n\n        listItems.forEach((item) => {\n          const itemText = item.replace(/<[^>]*>/g, \"\").trim();\n          if (itemText) {\n            listContent.push({\n              type: \"listItem\",\n              content: [\n                {\n                  type: \"paragraph\",\n                  content: [\n                    {\n                      type: \"text\",\n                      text: itemText,\n                    },\n                  ],\n                },\n              ],\n            });\n          }\n        });\n\n        if (listContent.length > 0) {\n          doc.content.push({\n            type: listType,\n            content: listContent,\n          });\n        }\n        return;\n      }\n\n      // Handle blockquotes\n      if (paragraph.includes(\"<blockquote>\")) {\n        const text = paragraph.replace(/<[^>]*>/g, \"\").trim();\n        if (text) {\n          doc.content.push({\n            type: \"blockquote\",\n            content: [\n              {\n                type: \"paragraph\",\n                content: [\n                  {\n                    type: \"text\",\n                    text: text,\n                  },\n                ],\n              },\n            ],\n          });\n        }\n        return;\n      }\n\n      // Handle regular paragraphs with inline formatting\n      const cleanedParagraph = paragraph.replace(/<p[^>]*>/, \"\");\n      if (!cleanedParagraph.trim()) return;\n\n      const paragraphContent: any[] = [];\n      let remainingText = cleanedParagraph;\n\n      // Process inline formatting\n      while (remainingText.length > 0) {\n        // Check for bold\n        const boldMatch = remainingText.match(\n          /<(strong|b)>(.*?)<\\/(strong|b)>/\n        );\n        if (boldMatch) {\n          const beforeText = remainingText\n            .substring(0, boldMatch.index)\n            .replace(/<[^>]*>/g, \"\");\n          if (beforeText) {\n            paragraphContent.push({ type: \"text\", text: beforeText });\n          }\n          paragraphContent.push({\n            type: \"text\",\n            text: boldMatch[2],\n            marks: [{ type: \"strong\" }],\n          });\n          remainingText = remainingText.substring(\n            boldMatch.index! + boldMatch[0].length\n          );\n          continue;\n        }\n\n        // Check for italic\n        const italicMatch = remainingText.match(/<(em|i)>(.*?)<\\/(em|i)>/);\n        if (italicMatch) {\n          const beforeText = remainingText\n            .substring(0, italicMatch.index)\n            .replace(/<[^>]*>/g, \"\");\n          if (beforeText) {\n            paragraphContent.push({ type: \"text\", text: beforeText });\n          }\n          paragraphContent.push({\n            type: \"text\",\n            text: italicMatch[2],\n            marks: [{ type: \"em\" }],\n          });\n          remainingText = remainingText.substring(\n            italicMatch.index! + italicMatch[0].length\n          );\n          continue;\n        }\n\n        // Check for underline\n        const underlineMatch = remainingText.match(/<u>(.*?)<\\/u>/);\n        if (underlineMatch) {\n          const beforeText = remainingText\n            .substring(0, underlineMatch.index)\n            .replace(/<[^>]*>/g, \"\");\n          if (beforeText) {\n            paragraphContent.push({ type: \"text\", text: beforeText });\n          }\n          paragraphContent.push({\n            type: \"text\",\n            text: underlineMatch[1],\n            marks: [{ type: \"underline\" }],\n          });\n          remainingText = remainingText.substring(\n            underlineMatch.index! + underlineMatch[0].length\n          );\n          continue;\n        }\n\n        // Check for code\n        const codeMatch = remainingText.match(/<code>(.*?)<\\/code>/);\n        if (codeMatch) {\n          const beforeText = remainingText\n            .substring(0, codeMatch.index)\n            .replace(/<[^>]*>/g, \"\");\n          if (beforeText) {\n            paragraphContent.push({ type: \"text\", text: beforeText });\n          }\n          paragraphContent.push({\n            type: \"text\",\n            text: codeMatch[1],\n            marks: [{ type: \"code\" }],\n          });\n          remainingText = remainingText.substring(\n            codeMatch.index! + codeMatch[0].length\n          );\n          continue;\n        }\n\n        // No more formatting, add the rest as plain text\n        const plainText = remainingText.replace(/<[^>]*>/g, \"\").trim();\n        if (plainText) {\n          paragraphContent.push({ type: \"text\", text: plainText });\n        }\n        break;\n      }\n\n      if (paragraphContent.length > 0) {\n        doc.content.push({\n          type: \"paragraph\",\n          content: paragraphContent,\n        });\n      }\n    });\n\n    // If no content was added, add empty paragraph\n    if (doc.content.length === 0) {\n      doc.content.push({\n        type: \"paragraph\",\n        content: [],\n      });\n    }\n\n    return doc;\n  }\n\n  async searchUsers(\n    query: string,\n    projectKey?: string,\n    startAt: number = 0,\n    maxResults: number = 50\n  ): Promise<\n    | Array<{\n        accountId: string;\n        displayName: string;\n        emailAddress?: string;\n        avatarUrls?: any;\n      }>\n    | {\n        users: Array<{\n          accountId: string;\n          displayName: string;\n          emailAddress?: string;\n          avatarUrls?: any;\n        }>;\n        total: number;\n      }\n  > {\n    try {\n      // console.log(`[JiraAdapter.searchUsers] Query: \"${query}\", ProjectKey: \"${projectKey}\", StartAt: ${startAt}, MaxResults: ${maxResults}`);\n\n      // Check if query looks like an email address\n      const isEmail = query.includes(\"@\");\n      // console.log(`[JiraAdapter.searchUsers] Is email search: ${isEmail}`);\n\n      // Try multiple search approaches for better user matching\n      const allUsers: any[] = [];\n\n      // 1. First try email search if it's an email\n      if (isEmail) {\n        try {\n          // Try the user/search endpoint with email\n          const emailSearchUrl = this.buildUrl(\n            `/rest/api/3/user/search?query=${encodeURIComponent(query)}&startAt=${startAt}&maxResults=${maxResults}`\n          );\n          // console.log(`[JiraAdapter.searchUsers] Trying email search: ${emailSearchUrl}`);\n          const emailUsers = await this.makeRequest<any[]>(emailSearchUrl);\n          allUsers.push(...emailUsers);\n\n          // Also try searching by accountId with the email (sometimes works)\n          const accountSearchUrl = this.buildUrl(\n            `/rest/api/3/user/search?accountId=${encodeURIComponent(query)}`\n          );\n          // console.log(`[JiraAdapter.searchUsers] Trying account search with email: ${accountSearchUrl}`);\n          try {\n            const accountUsers =\n              await this.makeRequest<any[]>(accountSearchUrl);\n            allUsers.push(...accountUsers);\n          } catch (e) {\n            // This might fail, that's ok\n            // console.log(`[JiraAdapter.searchUsers] Account search failed (expected): ${e}`);\n          }\n        } catch (error) {\n          // console.log(`[JiraAdapter.searchUsers] Email search error: ${error}`);\n        }\n      }\n\n      // 2. Try general search\n      let endpoint: string;\n      if (projectKey && !isEmail) {\n        // Search assignable users for the project\n        endpoint = `/rest/api/3/user/assignable/search?project=${projectKey}&query=${encodeURIComponent(query)}&startAt=${startAt}&maxResults=${maxResults}`;\n      } else {\n        // General user search\n        endpoint = `/rest/api/3/user/search?query=${encodeURIComponent(query)}&startAt=${startAt}&maxResults=${maxResults}`;\n      }\n\n      // console.log(`[JiraAdapter.searchUsers] Using general endpoint: ${endpoint}`);\n      const url = this.buildUrl(endpoint);\n      const generalUsers = await this.makeRequest<any[]>(url);\n      allUsers.push(...generalUsers);\n\n      // Deduplicate users by accountId\n      const uniqueUsers = new Map<string, any>();\n      allUsers.forEach((user) => {\n        if (user.accountId && !uniqueUsers.has(user.accountId)) {\n          uniqueUsers.set(user.accountId, user);\n        }\n      });\n\n      const users = Array.from(uniqueUsers.values());\n      // console.log(`[JiraAdapter.searchUsers] Total unique users found: ${users.length}`);\n\n      const mappedUsers = users.map((user: any) => {\n        const mapped = {\n          accountId: user.accountId,\n          displayName: user.displayName,\n          emailAddress: user.emailAddress,\n          avatarUrls: user.avatarUrls,\n        };\n        // console.log(`[JiraAdapter.searchUsers] User: ${mapped.displayName} (${mapped.accountId}) - Email: ${mapped.emailAddress || 'NOT AVAILABLE'}`);\n        return mapped;\n      });\n\n      // Return paginated result with total\n      // Jira doesn't return total, so we estimate: if we got fewer than maxResults, we're at the end\n      // Otherwise, assume there might be more pages\n      const hasMore = mappedUsers.length >= maxResults;\n      const estimatedTotal = hasMore\n        ? startAt + mappedUsers.length + 1\n        : startAt + mappedUsers.length;\n\n      return {\n        users: mappedUsers,\n        total: estimatedTotal,\n      };\n    } catch (error) {\n      console.error(\"[JiraAdapter.searchUsers] Failed to search users:\", error);\n      return { users: [], total: 0 };\n    }\n  }\n\n  async getCurrentUser(): Promise<{\n    accountId: string;\n    displayName: string;\n    emailAddress?: string;\n  } | null> {\n    try {\n      // console.log(`[JiraAdapter.getCurrentUser] Getting current authenticated user`);\n      const url = this.buildUrl(\"/rest/api/3/myself\");\n      const user = await this.makeRequest<any>(url);\n\n      // console.log(`[JiraAdapter.getCurrentUser] Current user: ${user.displayName} (${user.accountId}) - Email: ${user.emailAddress || 'NOT AVAILABLE'}`);\n\n      return {\n        accountId: user.accountId,\n        displayName: user.displayName,\n        emailAddress: user.emailAddress,\n      };\n    } catch (error) {\n      console.error(\n        \"[JiraAdapter.getCurrentUser] Failed to get current user:\",\n        error\n      );\n      return null;\n    }\n  }\n}\n", "import { BaseAdapter } from \"./BaseAdapter\";\nimport {\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n} from \"./IssueAdapter\";\n\n/**\n * GitHub integration adapter using Personal Access Token authentication\n */\nexport class GitHubAdapter extends BaseAdapter {\n  private owner?: string;\n  private repo?: string;\n  private baseUrl = \"https://api.github.com\";\n\n  constructor(config: any) {\n    super(config);\n\n    // GitHub repository can be specified in settings\n    if (config.repository) {\n      const [owner, repo] = config.repository.split(\"/\");\n      this.owner = owner;\n      this.repo = repo;\n    }\n  }\n\n  getCapabilities(): IssueAdapterCapabilities {\n    return {\n      createIssue: true,\n      updateIssue: true,\n      linkIssue: true,\n      syncIssue: true,\n      searchIssues: true,\n      webhooks: true,\n      customFields: false, // GitHub doesn't have custom fields like Jira\n      attachments: false, // GitHub doesn't support direct attachments on issues\n    };\n  }\n\n  protected async performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void> {\n    if (authData.type !== \"api_key\") {\n      throw new Error(\n        \"GitHub adapter only supports Personal Access Token authentication\"\n      );\n    }\n\n    if (!authData.apiKey) {\n      throw new Error(\n        \"Personal Access Token is required for GitHub authentication\"\n      );\n    }\n\n    // Validate the token by making a test request\n    try {\n      await this.makeRequest(`${this.baseUrl}/user`);\n    } catch (error) {\n      throw new Error(\"Invalid GitHub Personal Access Token\");\n    }\n  }\n\n  protected buildUrl(path: string): string {\n    if (path.startsWith(\"/repos/\") && this.owner && this.repo) {\n      // Replace placeholder with actual owner/repo\n      return `${this.baseUrl}${path.replace(\"{owner}/{repo}\", `${this.owner}/${this.repo}`)}`;\n    }\n    return `${this.baseUrl}${path}`;\n  }\n\n  async createIssue(data: CreateIssueData): Promise<IssueData> {\n    // Ensure we have owner/repo from either config or projectId\n    if (!this.owner || !this.repo) {\n      if (data.projectId.includes(\"/\")) {\n        const [owner, repo] = data.projectId.split(\"/\");\n        this.owner = owner;\n        this.repo = repo;\n      } else {\n        throw new Error(\n          \"GitHub repository not configured. Expected format: owner/repo\"\n        );\n      }\n    }\n\n    const githubPayload = {\n      title: data.title,\n      body: data.description || \"\",\n      labels: data.labels || [],\n      assignees: data.assigneeId ? [data.assigneeId] : undefined,\n    };\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/repos/{owner}/{repo}/issues`),\n      {\n        method: \"POST\",\n        body: JSON.stringify(githubPayload),\n      }\n    );\n\n    return this.mapGitHubIssue(response);\n  }\n\n  async updateIssue(\n    issueId: string,\n    data: UpdateIssueData\n  ): Promise<IssueData> {\n    const updatePayload: any = {};\n\n    if (data.title !== undefined) {\n      updatePayload.title = data.title;\n    }\n\n    if (data.description !== undefined) {\n      updatePayload.body = data.description;\n    }\n\n    if (data.status !== undefined) {\n      updatePayload.state = this.mapStatusToGitHub(data.status);\n    }\n\n    if (data.labels !== undefined) {\n      updatePayload.labels = data.labels;\n    }\n\n    if (data.assigneeId !== undefined) {\n      updatePayload.assignees = [data.assigneeId];\n    }\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/repos/{owner}/{repo}/issues/${issueId}`),\n      {\n        method: \"PATCH\",\n        body: JSON.stringify(updatePayload),\n      }\n    );\n\n    return this.mapGitHubIssue(response);\n  }\n\n  async getIssue(issueId: string): Promise<IssueData> {\n    // For GitHub, issueId could be just a number (e.g., \"123\") or include repo context (e.g., \"owner/repo#123\")\n    let owner = this.owner;\n    let repo = this.repo;\n    let issueNumber = issueId;\n\n    // Check if issueId includes repo context (format: \"owner/repo#123\")\n    const repoIssueMatch = issueId.match(/^([^/]+)\\/([^#]+)#(\\d+)$/);\n    if (repoIssueMatch) {\n      owner = repoIssueMatch[1];\n      repo = repoIssueMatch[2];\n      issueNumber = repoIssueMatch[3];\n    } else if (issueId.startsWith(\"#\")) {\n      // Just a number with # prefix\n      issueNumber = issueId.substring(1);\n    }\n\n    if (!owner || !repo) {\n      throw new Error(\n        \"GitHub repository not configured. Cannot fetch issue without owner/repo context.\"\n      );\n    }\n\n    const response = await this.makeRequest<any>(\n      `${this.baseUrl}/repos/${owner}/${repo}/issues/${issueNumber}`\n    );\n\n    return this.mapGitHubIssue(response);\n  }\n\n  async searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const searchQuery: string[] = [];\n\n    // Always add is:issue to filter out pull requests (required by GitHub API)\n    searchQuery.push(\"is:issue\");\n\n    // Add repo filter\n    if (this.owner && this.repo) {\n      searchQuery.push(`repo:${this.owner}/${this.repo}`);\n    } else if (options.projectId) {\n      searchQuery.push(`repo:${options.projectId}`);\n    }\n\n    // Add search query\n    if (options.query) {\n      searchQuery.push(options.query);\n    }\n\n    // Add status filter\n    if (options.status && options.status.length > 0) {\n      const states = options.status.map((s) => this.mapStatusToGitHub(s));\n      searchQuery.push(`is:${states.join(\" is:\")}`);\n    }\n\n    // Add assignee filter\n    if (options.assignee) {\n      searchQuery.push(`assignee:${options.assignee}`);\n    }\n\n    // Add label filter\n    if (options.labels && options.labels.length > 0) {\n      searchQuery.push(options.labels.map((l) => `label:\"${l}\"`).join(\" \"));\n    }\n\n    const params = new URLSearchParams({\n      q: searchQuery.join(\" \"),\n      per_page: (options.limit || 30).toString(),\n      page: Math.floor(\n        (options.offset || 0) / (options.limit || 30) + 1\n      ).toString(),\n      sort: \"created\",\n      order: \"desc\",\n    });\n\n    const response = await this.makeRequest<any>(\n      `${this.baseUrl}/search/issues?${params.toString()}`\n    );\n\n    return {\n      issues: response.items.map((issue: any) => this.mapGitHubIssue(issue)),\n      total: response.total_count,\n      hasMore:\n        response.incomplete_results ||\n        response.total_count > (options.offset || 0) + response.items.length,\n    };\n  }\n\n  protected async addComment(issueId: string, comment: string): Promise<void> {\n    await this.makeRequest(\n      this.buildUrl(`/repos/{owner}/{repo}/issues/${issueId}/comments`),\n      {\n        method: \"POST\",\n        body: JSON.stringify({ body: comment }),\n      }\n    );\n  }\n\n  /**\n   * Get available repositories for the authenticated user\n   */\n  async getProjects(): Promise<\n    Array<{ id: string; key: string; name: string }>\n  > {\n    const repos = await this.makeRequest<any[]>(\n      `${this.baseUrl}/user/repos?per_page=100&sort=updated`\n    );\n\n    return repos.map((repo) => ({\n      id: repo.full_name,\n      key: repo.name,\n      name: repo.full_name,\n    }));\n  }\n\n  /**\n   * Get available labels for a repository\n   */\n  async getLabels(): Promise<\n    Array<{ id: string; name: string; color: string }>\n  > {\n    if (!this.owner || !this.repo) {\n      throw new Error(\"Repository not configured\");\n    }\n\n    const labels = await this.makeRequest<any[]>(\n      this.buildUrl(`/repos/{owner}/{repo}/labels`)\n    );\n\n    return labels.map((label) => ({\n      id: label.name,\n      name: label.name,\n      color: label.color,\n    }));\n  }\n\n  /**\n   * Get available milestones for a repository\n   */\n  async getMilestones(): Promise<\n    Array<{ id: string; title: string; state: string }>\n  > {\n    if (!this.owner || !this.repo) {\n      throw new Error(\"Repository not configured\");\n    }\n\n    const milestones = await this.makeRequest<any[]>(\n      this.buildUrl(`/repos/{owner}/{repo}/milestones`)\n    );\n\n    return milestones.map((milestone) => ({\n      id: milestone.number.toString(),\n      title: milestone.title,\n      state: milestone.state,\n    }));\n  }\n\n  private mapStatusToGitHub(status: string): string {\n    const lowerStatus = status.toLowerCase();\n    if (\n      lowerStatus === \"closed\" ||\n      lowerStatus === \"done\" ||\n      lowerStatus === \"resolved\"\n    ) {\n      return \"closed\";\n    }\n    return \"open\";\n  }\n\n  private mapGitHubIssue(githubIssue: any): IssueData {\n    // Extract owner/repo from repository_url (for search results) or html_url\n    let owner = this.owner;\n    let repo = this.repo;\n\n    if (githubIssue.repository_url) {\n      // Format: https://api.github.com/repos/owner/repo\n      const match = githubIssue.repository_url.match(/\\/repos\\/([^/]+)\\/([^/]+)$/);\n      if (match) {\n        owner = match[1];\n        repo = match[2];\n      }\n    } else if (githubIssue.html_url) {\n      // Format: https://github.com/owner/repo/issues/123\n      const match = githubIssue.html_url.match(/github\\.com\\/([^/]+)\\/([^/]+)\\/issues/);\n      if (match) {\n        owner = match[1];\n        repo = match[2];\n      }\n    }\n\n    return {\n      id: githubIssue.number.toString(),\n      key: `#${githubIssue.number}`,\n      title: githubIssue.title,\n      description: githubIssue.body,\n      status: githubIssue.state,\n      priority: undefined, // GitHub doesn't have priority\n      assignee: githubIssue.assignee\n        ? {\n            id: githubIssue.assignee.login,\n            name: githubIssue.assignee.login,\n            email: githubIssue.assignee.email,\n          }\n        : undefined,\n      reporter: githubIssue.user\n        ? {\n            id: githubIssue.user.login,\n            name: githubIssue.user.login,\n            email: githubIssue.user.email,\n          }\n        : undefined,\n      labels: githubIssue.labels.map((label: any) => label.name),\n      // Store repo context in customFields for sync support\n      customFields: {\n        _github_owner: owner,\n        _github_repo: repo,\n      },\n      createdAt: new Date(githubIssue.created_at),\n      updatedAt: new Date(githubIssue.updated_at),\n      url: githubIssue.html_url,\n    };\n  }\n\n  async linkToTestCase(\n    issueId: string,\n    testCaseId: string,\n    metadata?: any\n  ): Promise<void> {\n    const comment = `Linked to test case: ${testCaseId}${\n      metadata ? `\\n\\nMetadata: ${JSON.stringify(metadata, null, 2)}` : \"\"\n    }`;\n    await this.addComment(issueId, comment);\n  }\n\n  async syncIssue(issueId: string): Promise<IssueData> {\n    return this.getIssue(issueId);\n  }\n}\n", "import { BaseAdapter } from \"./BaseAdapter\";\nimport {\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n} from \"./IssueAdapter\";\n\n/**\n * Azure DevOps integration adapter using Personal Access Token authentication\n */\nexport class AzureDevOpsAdapter extends BaseAdapter {\n  private organizationUrl?: string;\n  private project?: string;\n  private apiVersion = \"7.0\";\n\n  constructor(config: any) {\n    super(config);\n\n    // Azure DevOps configuration from settings\n    this.organizationUrl = config.organizationUrl;\n    this.project = config.project;\n  }\n\n  getCapabilities(): IssueAdapterCapabilities {\n    return {\n      createIssue: true,\n      updateIssue: true,\n      linkIssue: true,\n      syncIssue: true,\n      searchIssues: true,\n      webhooks: true,\n      customFields: true,\n      attachments: true,\n    };\n  }\n\n  protected async performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void> {\n    if (authData.type !== \"api_key\") {\n      throw new Error(\n        \"Azure DevOps adapter only supports Personal Access Token authentication\"\n      );\n    }\n\n    if (!authData.apiKey) {\n      throw new Error(\n        \"Personal Access Token is required for Azure DevOps authentication\"\n      );\n    }\n\n    if (!this.organizationUrl) {\n      throw new Error(\"Organization URL is required for Azure DevOps\");\n    }\n\n    // Validate the token by making a test request\n    try {\n      await this.makeRequest(\n        `${this.organizationUrl}/_apis/projects?api-version=${this.apiVersion}`\n      );\n    } catch (error) {\n      throw new Error(\n        \"Invalid Azure DevOps Personal Access Token or Organization URL\"\n      );\n    }\n  }\n\n  protected buildUrl(path: string): string {\n    if (!this.organizationUrl) {\n      throw new Error(\"Organization URL not configured\");\n    }\n\n    // Handle project-specific paths\n    if (path.includes(\"{project}\") && this.project) {\n      path = path.replace(\"{project}\", encodeURIComponent(this.project));\n    }\n\n    return `${this.organizationUrl}${path}`;\n  }\n\n  async createIssue(data: CreateIssueData): Promise<IssueData> {\n    // Ensure we have a project\n    if (!this.project && data.projectId) {\n      this.project = data.projectId;\n    }\n\n    if (!this.project) {\n      throw new Error(\"Azure DevOps project not configured\");\n    }\n\n    // Build work item patch document\n    const patchDocument = [\n      {\n        op: \"add\",\n        path: \"/fields/System.Title\",\n        value: data.title,\n      },\n    ];\n\n    if (data.description) {\n      // Convert TipTap JSON to HTML if needed\n      let descriptionValue: string;\n      if (typeof data.description === 'object' && data.description && 'type' in data.description && data.description.type === 'doc') {\n        // For now, extract plain text from TipTap JSON\n        // Azure DevOps expects HTML or plain text\n        descriptionValue = this.extractTextFromTiptap(data.description);\n      } else {\n        descriptionValue = data.description as string;\n      }\n      \n      patchDocument.push({\n        op: \"add\",\n        path: \"/fields/System.Description\",\n        value: descriptionValue,\n      });\n    }\n\n    if (data.priority) {\n      patchDocument.push({\n        op: \"add\",\n        path: \"/fields/Microsoft.VSTS.Common.Priority\",\n        value: parseInt(data.priority),\n      } as any);\n    }\n\n    if (data.assigneeId) {\n      patchDocument.push({\n        op: \"add\",\n        path: \"/fields/System.AssignedTo\",\n        value: data.assigneeId,\n      });\n    }\n\n    if (data.labels && data.labels.length > 0) {\n      patchDocument.push({\n        op: \"add\",\n        path: \"/fields/System.Tags\",\n        value: data.labels.join(\"; \"),\n      });\n    }\n\n    // Add custom fields\n    if (data.customFields) {\n      for (const [field, value] of Object.entries(data.customFields)) {\n        patchDocument.push({\n          op: \"add\",\n          path: `/fields/${field}`,\n          value: value,\n        });\n      }\n    }\n\n    const workItemType = data.issueType || \"Bug\";\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/{project}/_apis/wit/workitems/$${workItemType}?api-version=${this.apiVersion}`\n      ),\n      {\n        method: \"POST\",\n        body: JSON.stringify(patchDocument),\n        headers: {\n          \"Content-Type\": \"application/json-patch+json\",\n        },\n      }\n    );\n\n    return this.mapAzureDevOpsWorkItem(response);\n  }\n\n  async updateIssue(\n    issueId: string,\n    data: UpdateIssueData\n  ): Promise<IssueData> {\n    const patchDocument = [];\n\n    if (data.title !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.Title\",\n        value: data.title,\n      });\n    }\n\n    if (data.description !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.Description\",\n        value: data.description,\n      });\n    }\n\n    if (data.status !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.State\",\n        value: data.status,\n      });\n    }\n\n    if (data.priority !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/Microsoft.VSTS.Common.Priority\",\n        value: parseInt(data.priority),\n      } as any);\n    }\n\n    if (data.assigneeId !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.AssignedTo\",\n        value: data.assigneeId,\n      });\n    }\n\n    if (data.labels !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.Tags\",\n        value: data.labels.join(\"; \"),\n      });\n    }\n\n    // Update custom fields\n    if (data.customFields) {\n      for (const [field, value] of Object.entries(data.customFields)) {\n        patchDocument.push({\n          op: \"replace\",\n          path: `/fields/${field}`,\n          value: value,\n        });\n      }\n    }\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/workitems/${issueId}?api-version=${this.apiVersion}`\n      ),\n      {\n        method: \"PATCH\",\n        body: JSON.stringify(patchDocument),\n        headers: {\n          \"Content-Type\": \"application/json-patch+json\",\n        },\n      }\n    );\n\n    return this.mapAzureDevOpsWorkItem(response);\n  }\n\n  async getIssue(issueId: string): Promise<IssueData> {\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/workitems/${issueId}?api-version=${this.apiVersion}&$expand=all`\n      )\n    );\n\n    return this.mapAzureDevOpsWorkItem(response);\n  }\n\n  async searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    // Build WIQL query\n    const conditions: string[] = [];\n\n    if (this.project) {\n      conditions.push(`[System.TeamProject] = '${this.project}'`);\n    } else if (options.projectId) {\n      conditions.push(`[System.TeamProject] = '${options.projectId}'`);\n    }\n\n    if (options.query) {\n      conditions.push(\n        `([System.Title] CONTAINS '${options.query}' OR [System.Description] CONTAINS '${options.query}')`\n      );\n    }\n\n    if (options.status && options.status.length > 0) {\n      const statusCondition = options.status\n        .map((s) => `[System.State] = '${s}'`)\n        .join(\" OR \");\n      conditions.push(`(${statusCondition})`);\n    }\n\n    if (options.assignee) {\n      conditions.push(`[System.AssignedTo] = '${options.assignee}'`);\n    }\n\n    if (options.labels && options.labels.length > 0) {\n      const labelConditions = options.labels.map(\n        (l) => `[System.Tags] CONTAINS '${l}'`\n      );\n      conditions.push(`(${labelConditions.join(\" OR \")})`);\n    }\n\n    const whereClause =\n      conditions.length > 0 ? `WHERE ${conditions.join(\" AND \")}` : \"\";\n    const wiql = `SELECT [System.Id] FROM WorkItems ${whereClause} ORDER BY [System.CreatedDate] DESC`;\n\n    const wiqlResponse = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/wiql?api-version=${this.apiVersion}&$top=${options.limit || 200}`\n      ),\n      {\n        method: \"POST\",\n        body: JSON.stringify({ query: wiql }),\n      }\n    );\n\n    if (!wiqlResponse.workItems || wiqlResponse.workItems.length === 0) {\n      return {\n        issues: [],\n        total: 0,\n        hasMore: false,\n      };\n    }\n\n    // Get the work items details\n    const ids = wiqlResponse.workItems\n      .slice(options.offset || 0, (options.offset || 0) + (options.limit || 50))\n      .map((item: any) => item.id);\n\n    if (ids.length === 0) {\n      return {\n        issues: [],\n        total: wiqlResponse.workItems.length,\n        hasMore: false,\n      };\n    }\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/workitems?ids=${ids.join(\",\")}&api-version=${this.apiVersion}&$expand=all`\n      )\n    );\n\n    return {\n      issues: response.value.map((item: any) =>\n        this.mapAzureDevOpsWorkItem(item)\n      ),\n      total: wiqlResponse.workItems.length,\n      hasMore:\n        (options.offset || 0) + ids.length < wiqlResponse.workItems.length,\n    };\n  }\n\n  protected async addComment(issueId: string, comment: string): Promise<void> {\n    await this.makeRequest(\n      this.buildUrl(\n        `/_apis/wit/workitems/${issueId}/comments?api-version=${this.apiVersion}-preview`\n      ),\n      {\n        method: \"POST\",\n        body: JSON.stringify({ text: comment }),\n      }\n    );\n  }\n\n  /**\n   * Get available projects\n   */\n  async getProjects(): Promise<\n    Array<{ id: string; key: string; name: string }>\n  > {\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/_apis/projects?api-version=${this.apiVersion}`)\n    );\n\n    return response.value.map((project: any) => ({\n      id: project.id,\n      key: project.name,\n      name: project.name,\n    }));\n  }\n\n  /**\n   * Get work item types for a project\n   */\n  async getIssueTypes(\n    projectId: string\n  ): Promise<Array<{ id: string; name: string }>> {\n    const project = projectId || this.project;\n    if (!project) {\n      throw new Error(\"Project not specified\");\n    }\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/${project}/_apis/wit/workitemtypes?api-version=${this.apiVersion}`\n      )\n    );\n\n    return response.value.map((type: any) => ({\n      id: type.name,\n      name: type.name,\n    }));\n  }\n\n  /**\n   * Get available states for work items\n   */\n  async getStatuses(): Promise<Array<{ id: string; name: string }>> {\n    // Azure DevOps states are defined per work item type and process\n    // Return common states\n    return [\n      { id: \"New\", name: \"New\" },\n      { id: \"Active\", name: \"Active\" },\n      { id: \"Resolved\", name: \"Resolved\" },\n      { id: \"Closed\", name: \"Closed\" },\n      { id: \"Removed\", name: \"Removed\" },\n    ];\n  }\n\n  /**\n   * Get priorities\n   */\n  async getPriorities(): Promise<Array<{ id: string; name: string }>> {\n    return [\n      { id: \"1\", name: \"1 - Critical\" },\n      { id: \"2\", name: \"2 - High\" },\n      { id: \"3\", name: \"3 - Medium\" },\n      { id: \"4\", name: \"4 - Low\" },\n    ];\n  }\n\n  /**\n   * Upload attachment to a work item\n   */\n  async uploadAttachment(\n    issueId: string,\n    file: Buffer,\n    filename: string\n  ): Promise<{ id: string; url: string }> {\n    // First, upload the attachment\n    const uploadResponse = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/attachments?fileName=${encodeURIComponent(filename)}&api-version=${this.apiVersion}`\n      ),\n      {\n        method: \"POST\",\n        body: file as any,\n        headers: {\n          \"Content-Type\": \"application/octet-stream\",\n        },\n      }\n    );\n\n    // Then, link it to the work item\n    const patchDocument = [\n      {\n        op: \"add\",\n        path: \"/relations/-\",\n        value: {\n          rel: \"AttachedFile\",\n          url: uploadResponse.url,\n        },\n      },\n    ];\n\n    await this.makeRequest(\n      this.buildUrl(\n        `/_apis/wit/workitems/${issueId}?api-version=${this.apiVersion}`\n      ),\n      {\n        method: \"PATCH\",\n        body: JSON.stringify(patchDocument),\n        headers: {\n          \"Content-Type\": \"application/json-patch+json\",\n        },\n      }\n    );\n\n    return {\n      id: uploadResponse.id,\n      url: uploadResponse.url,\n    };\n  }\n\n  private mapAzureDevOpsWorkItem(workItem: any): IssueData {\n    const fields = workItem.fields;\n\n    return {\n      id: workItem.id.toString(),\n      key: workItem.id.toString(),\n      title: fields[\"System.Title\"],\n      description: fields[\"System.Description\"],\n      status: fields[\"System.State\"],\n      priority: fields[\"Microsoft.VSTS.Common.Priority\"]?.toString(),\n      assignee: fields[\"System.AssignedTo\"]\n        ? {\n            id:\n              fields[\"System.AssignedTo\"].uniqueName ||\n              fields[\"System.AssignedTo\"],\n            name:\n              fields[\"System.AssignedTo\"].displayName ||\n              fields[\"System.AssignedTo\"],\n            email: fields[\"System.AssignedTo\"].uniqueName,\n          }\n        : undefined,\n      reporter: fields[\"System.CreatedBy\"]\n        ? {\n            id:\n              fields[\"System.CreatedBy\"].uniqueName ||\n              fields[\"System.CreatedBy\"],\n            name:\n              fields[\"System.CreatedBy\"].displayName ||\n              fields[\"System.CreatedBy\"],\n            email: fields[\"System.CreatedBy\"].uniqueName,\n          }\n        : undefined,\n      labels: fields[\"System.Tags\"]\n        ? fields[\"System.Tags\"].split(\";\").map((tag: string) => tag.trim())\n        : [],\n      customFields: this.extractCustomFields(fields),\n      createdAt: new Date(fields[\"System.CreatedDate\"]),\n      updatedAt: new Date(fields[\"System.ChangedDate\"]),\n      url: workItem._links?.html?.href || workItem.url,\n    };\n  }\n\n  private extractCustomFields(fields: any): Record<string, any> {\n    const customFields: Record<string, any> = {};\n    const systemFields = [\n      \"System.Id\",\n      \"System.Title\",\n      \"System.Description\",\n      \"System.State\",\n      \"System.AssignedTo\",\n      \"System.CreatedBy\",\n      \"System.CreatedDate\",\n      \"System.ChangedDate\",\n      \"System.Tags\",\n      \"System.TeamProject\",\n      \"System.WorkItemType\",\n      \"Microsoft.VSTS.Common.Priority\",\n    ];\n\n    for (const [key, value] of Object.entries(fields)) {\n      if (\n        !systemFields.includes(key) &&\n        value !== null &&\n        value !== undefined\n      ) {\n        customFields[key] = value;\n      }\n    }\n\n    return customFields;\n  }\n\n  async linkToTestCase(\n    issueId: string,\n    testCaseId: string,\n    metadata?: any\n  ): Promise<void> {\n    const comment = `Linked to test case: ${testCaseId}${\n      metadata ? `\\n\\nMetadata: ${JSON.stringify(metadata, null, 2)}` : \"\"\n    }`;\n    await this.addComment(issueId, comment);\n  }\n\n  async syncIssue(issueId: string): Promise<IssueData> {\n    return this.getIssue(issueId);\n  }\n\n  private extractTextFromTiptap(tiptapJson: any): string {\n    // Simple text extraction from TipTap JSON\n    let text = '';\n    \n    if (tiptapJson.content && Array.isArray(tiptapJson.content)) {\n      tiptapJson.content.forEach((node: any) => {\n        if (node.type === 'text') {\n          text += node.text || '';\n        } else if (node.content && Array.isArray(node.content)) {\n          text += this.extractTextFromTiptap(node) + '\\n';\n        }\n      });\n    }\n    \n    return text.trim();\n  }\n}\n", "import {\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n} from \"./IssueAdapter\";\nimport { BaseAdapter } from \"./BaseAdapter\";\nimport { prisma } from \"@/lib/prismaBase\";\n\n/**\n * Simple URL adapter for basic issue tracking integrations\n * This adapter provides basic functionality for URL-based issue tracking systems\n */\nexport class SimpleUrlAdapter extends BaseAdapter {\n  /**\n   * Get the capabilities of this adapter\n   */\n  getCapabilities(): IssueAdapterCapabilities {\n    return {\n      createIssue: false, // Simple URL adapters typically can't create issues\n      updateIssue: false, // Simple URL adapters typically can't update issues\n      linkIssue: true,    // Can link to existing issues via URL\n      syncIssue: false,   // Can't sync since no API access\n      searchIssues: true, // Can provide basic search functionality\n      webhooks: false,    // No webhook support\n      customFields: false, // No custom field support\n      attachments: false, // No attachment support\n    };\n  }\n\n  /**\n   * Perform adapter-specific authentication\n   * Simple URL adapters don't typically require authentication\n   */\n  protected async performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void> {\n    // Simple URL adapters don't require authentication\n    // Just validate that we have a base URL\n    if (!authData.baseUrl && !this.config.baseUrl) {\n      throw new Error(\"Base URL is required for Simple URL integration\");\n    }\n  }\n\n  /**\n   * Create a new issue - not supported by Simple URL adapters\n   */\n  async createIssue(_data: CreateIssueData): Promise<IssueData> {\n    throw new Error(\"Creating issues is not supported by Simple URL integration\");\n  }\n\n  /**\n   * Update an existing issue - not supported by Simple URL adapters\n   */\n  async updateIssue(\n    _issueId: string,\n    _data: UpdateIssueData\n  ): Promise<IssueData> {\n    throw new Error(\"Updating issues is not supported by Simple URL integration\");\n  }\n\n  /**\n   * Get a single issue by ID - creates a mock issue based on URL pattern\n   */\n  async getIssue(issueId: string): Promise<IssueData> {\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      throw new Error(\"Base URL not configured\");\n    }\n\n    // Generate URL by replacing {issueId} placeholder\n    const url = baseUrl.replace(\"{issueId}\", issueId).replace(\"'{issueId}'\", issueId);\n\n    return {\n      id: issueId,\n      key: issueId,\n      title: `Issue ${issueId}`,\n      description: `Issue linked via Simple URL integration`,\n      status: \"Unknown\",\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      url: url,\n    };\n  }\n\n  /**\n   * Search for issues - searches the internal database for issues linked to this integration\n   */\n  async searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const { query = \"\", limit = 10 } = options;\n    \n    // For Simple URL integrations, we search the internal TestPlanIt database\n    // for issues that are linked to this integration\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      throw new Error(\"Base URL not configured\");\n    }\n\n    // Get the integration ID from config\n    const integrationId = this.config.integrationId;\n    if (!integrationId) {\n      throw new Error(\"Integration ID not configured\");\n    }\n\n    // Search issues in the database that belong to this integration\n    const where: any = {\n      integrationId: integrationId,\n      isDeleted: false,\n    };\n\n    // Add search filter if query is provided\n    if (query.trim()) {\n      where.OR = [\n        { name: { contains: query, mode: \"insensitive\" } },\n        { title: { contains: query, mode: \"insensitive\" } },\n        { description: { contains: query, mode: \"insensitive\" } },\n        { externalId: { contains: query, mode: \"insensitive\" } },\n        { externalKey: { contains: query, mode: \"insensitive\" } },\n      ];\n    }\n\n    // Get total count for pagination\n    const total = await prisma.issue.count({ where });\n\n    // Get the actual issues\n    const dbIssues = await prisma.issue.findMany({\n      where,\n      take: limit,\n      orderBy: { createdAt: \"desc\" },\n      select: {\n        id: true,\n        name: true,\n        title: true,\n        description: true,\n        status: true,\n        priority: true,\n        externalId: true,\n        externalKey: true,\n        externalUrl: true,\n        externalStatus: true,\n        createdAt: true,\n      },\n    });\n\n    // Convert database issues to IssueData format\n    const issues: IssueData[] = dbIssues.map((dbIssue) => {\n      // Use existing external URL if available, otherwise generate from pattern\n      let url = dbIssue.externalUrl;\n      if (!url && (dbIssue.externalId || dbIssue.externalKey)) {\n        const issueId = dbIssue.externalId || dbIssue.externalKey || dbIssue.id.toString();\n        url = baseUrl.replace(\"{issueId}\", issueId).replace(\"'{issueId}'\", issueId);\n      }\n\n      return {\n        id: dbIssue.externalId || dbIssue.externalKey || dbIssue.id.toString(),\n        key: dbIssue.externalKey || dbIssue.externalId || dbIssue.name,\n        title: dbIssue.title,\n        description: dbIssue.description || undefined,\n        status: dbIssue.externalStatus || dbIssue.status || \"Unknown\",\n        priority: dbIssue.priority || undefined,\n        createdAt: dbIssue.createdAt,\n        updatedAt: dbIssue.createdAt, // Use createdAt since Issue model doesn't have updatedAt\n        url: url || undefined,\n      };\n    });\n\n    return {\n      issues,\n      total,\n      hasMore: dbIssues.length === limit && total > limit,\n    };\n  }\n\n  /**\n   * Link an issue to a test case\n   */\n  async linkToTestCase(\n    issueId: string,\n    _testCaseId: string,\n    _metadata?: any\n  ): Promise<void> {\n    // For Simple URL integrations, we just validate that we can generate a valid URL\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      throw new Error(\"Base URL not configured\");\n    }\n\n    const url = baseUrl.replace(\"{issueId}\", issueId).replace(\"'{issueId}'\", issueId);\n    \n    // Basic URL validation\n    try {\n      new URL(url);\n    } catch (error) {\n      throw new Error(`Invalid URL generated: ${url}`);\n    }\n\n    // Since we can't actually link in the external system, this is a no-op\n    // The link will be stored in the TestPlanIt database\n  }\n\n  /**\n   * Validate configuration\n   */\n  async validateConfiguration(): Promise<{\n    valid: boolean;\n    errors?: string[];\n  }> {\n    const errors: string[] = [];\n\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      errors.push(\"Base URL is required\");\n    } else {\n      // Validate URL pattern contains placeholder\n      if (!baseUrl.includes(\"{issueId}\") && !baseUrl.includes(\"'{issueId}'\")) {\n        errors.push(\"Base URL must contain {issueId} placeholder\");\n      }\n\n      // Try to validate URL format\n      try {\n        const testUrl = baseUrl.replace(\"{issueId}\", \"TEST-1\").replace(\"'{issueId}'\", \"TEST-1\");\n        new URL(testUrl);\n      } catch (error) {\n        errors.push(\"Base URL pattern is not a valid URL format\");\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n}", "import crypto from \"crypto\";\n\nconst algorithm = \"aes-256-gcm\";\nconst ivLength = 16;\nconst saltLength = 32;\nconst tagLength = 16;\nconst iterations = 100000;\nconst keyLength = 32;\n\n// Get encryption key from environment variable or generate a default one for development\nexport const getMasterKey = (): string => {\n  const key = process.env.ENCRYPTION_KEY;\n  if (!key) {\n    // In development, use a default key (DO NOT use in production)\n    console.warn(\"ENCRYPTION_KEY not set, using default key for development\");\n    return \"development-key-do-not-use-in-production-please!\";\n  }\n  return key;\n};\n\n// Alias for backward compatibility\nconst getEncryptionKey = getMasterKey;\n\n// Derive key from password using PBKDF2\nconst deriveKey = (password: string, salt: Buffer): Buffer => {\n  return crypto.pbkdf2Sync(password, salt, iterations, keyLength, \"sha256\");\n};\n\n// Encrypt a value\nexport const encrypt = async (text: string): Promise<string> => {\n  try {\n    const password = getEncryptionKey();\n    const salt = crypto.randomBytes(saltLength);\n    const key = deriveKey(password, salt);\n    const iv = crypto.randomBytes(ivLength);\n\n    const cipher = crypto.createCipheriv(algorithm, key, iv);\n\n    const encrypted = Buffer.concat([\n      cipher.update(text, \"utf8\"),\n      cipher.final(),\n    ]);\n\n    const tag = cipher.getAuthTag();\n\n    // Combine salt, iv, tag, and encrypted data\n    const combined = Buffer.concat([salt, iv, tag, encrypted]);\n\n    return combined.toString(\"base64\");\n  } catch (error) {\n    console.error(\"Encryption error:\", error);\n    throw new Error(\"Failed to encrypt data\");\n  }\n};\n\n// Decrypt a value\nexport const decrypt = async (encryptedText: string): Promise<string> => {\n  try {\n    const password = getEncryptionKey();\n    const combined = Buffer.from(encryptedText, \"base64\");\n\n    // Extract components\n    const salt = combined.slice(0, saltLength);\n    const iv = combined.slice(saltLength, saltLength + ivLength);\n    const tag = combined.slice(\n      saltLength + ivLength,\n      saltLength + ivLength + tagLength\n    );\n    const encrypted = combined.slice(saltLength + ivLength + tagLength);\n\n    const key = deriveKey(password, salt);\n\n    const decipher = crypto.createDecipheriv(algorithm, key, iv);\n    decipher.setAuthTag(tag);\n\n    const decrypted = Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final(),\n    ]);\n\n    return decrypted.toString(\"utf8\");\n  } catch (error) {\n    console.error(\"Decryption error:\", error);\n    throw new Error(\"Failed to decrypt data\");\n  }\n};\n\n// Utility to check if a string is encrypted (base64 format check)\nexport const isEncrypted = (value: string): boolean => {\n  try {\n    const decoded = Buffer.from(value, \"base64\");\n    // Check if the decoded buffer has the expected minimum length\n    return decoded.length >= saltLength + ivLength + tagLength;\n  } catch {\n    return false;\n  }\n};\n\n// EncryptionService class for object encryption/decryption\nexport class EncryptionService {\n  static encrypt(text: string, key: string): string {\n    const salt = crypto.randomBytes(saltLength);\n    const derivedKey = deriveKey(key, salt);\n    const iv = crypto.randomBytes(ivLength);\n\n    const cipher = crypto.createCipheriv(algorithm, derivedKey, iv);\n\n    const encrypted = Buffer.concat([\n      cipher.update(text, \"utf8\"),\n      cipher.final(),\n    ]);\n\n    const tag = cipher.getAuthTag();\n\n    // Combine salt, iv, tag, and encrypted data\n    const combined = Buffer.concat([salt, iv, tag, encrypted]);\n\n    return combined.toString(\"base64\");\n  }\n\n  static decrypt(encryptedText: string, key: string): string {\n    const combined = Buffer.from(encryptedText, \"base64\");\n\n    // Extract components\n    const salt = combined.slice(0, saltLength);\n    const iv = combined.slice(saltLength, saltLength + ivLength);\n    const tag = combined.slice(\n      saltLength + ivLength,\n      saltLength + ivLength + tagLength\n    );\n    const encrypted = combined.slice(saltLength + ivLength + tagLength);\n\n    const derivedKey = deriveKey(key, salt);\n\n    const decipher = crypto.createDecipheriv(algorithm, derivedKey, iv);\n    decipher.setAuthTag(tag);\n\n    const decrypted = Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final(),\n    ]);\n\n    return decrypted.toString(\"utf8\");\n  }\n\n  static encryptObject(obj: any, key: string): string {\n    return this.encrypt(JSON.stringify(obj), key);\n  }\n\n  static decryptObject(encryptedText: string, key: string): any {\n    return JSON.parse(this.decrypt(encryptedText, key));\n  }\n}\n", "import { getSyncQueue } from \"../../queues\";\nimport { issueCache } from \"../cache/IssueCache\";\nimport { integrationManager } from \"../IntegrationManager\";\nimport type { IssueData } from \"../adapters/IssueAdapter\";\nimport type { IssueAdapter } from \"../adapters/IssueAdapter\";\nimport { JobsOptions, Job } from \"bullmq\";\nimport { prisma as defaultPrisma } from \"@/lib/prismaBase\";\nimport { syncIssueToElasticsearch } from \"~/services/issueSearch\";\nimport type { PrismaClient } from \"@prisma/client\";\nimport { getCurrentTenantId } from \"../../multiTenantPrisma\";\n\n// Lazy-load zenstack enhance to reduce worker memory at startup\nlet _enhance: typeof import(\"@zenstackhq/runtime\").enhance | null = null;\nasync function getEnhance() {\n  if (!_enhance) {\n    const { enhance } = await import(\"@zenstackhq/runtime\");\n    _enhance = enhance;\n  }\n  return _enhance;\n}\n\nexport interface SyncJobData {\n  userId: string;\n  integrationId: number;\n  projectId?: string;\n  issueId?: string;\n  action: \"sync\" | \"create\" | \"update\" | \"refresh\";\n  data?: any;\n  tenantId?: string; // For multi-tenant support\n}\n\nexport interface SyncServiceOptions {\n  prismaClient?: PrismaClient; // Optional: use provided client for multi-tenant support\n}\n\nexport interface SyncOptions {\n  forceRefresh?: boolean;\n  includeMetadata?: boolean;\n  limit?: number;\n}\n\nexport class SyncService {\n  /**\n   * Queue a sync job for an integration\n   */\n  async queueSync(\n    userId: string,\n    integrationId: number,\n    options: SyncOptions = {}\n  ): Promise<string | null> {\n    const syncQueue = getSyncQueue();\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      action: \"sync\",\n      data: options,\n      tenantId: getCurrentTenantId(),\n    };\n\n    const jobOptions: JobsOptions = {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 2000,\n      },\n      removeOnComplete: true,\n      removeOnFail: false,\n    };\n\n    const job = await syncQueue.add(\"sync-issues\", jobData, jobOptions);\n    return job.id || null;\n  }\n\n  /**\n   * Queue a project-specific sync\n   */\n  async queueProjectSync(\n    userId: string,\n    integrationId: number,\n    projectId: string,\n    options: SyncOptions = {}\n  ): Promise<string | null> {\n    const syncQueue = getSyncQueue();\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      projectId,\n      action: \"sync\",\n      data: options,\n      tenantId: getCurrentTenantId(),\n    };\n\n    const job = await syncQueue.add(\"sync-project-issues\", jobData);\n    return job.id || null;\n  }\n\n  /**\n   * Queue issue creation\n   */\n  async queueIssueCreate(\n    userId: string,\n    integrationId: number,\n    issueData: any\n  ): Promise<string | null> {\n    const syncQueue = getSyncQueue();\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      action: \"create\",\n      data: issueData,\n      tenantId: getCurrentTenantId(),\n    };\n\n    const job = await syncQueue.add(\"create-issue\", jobData, {\n      attempts: 2,\n      backoff: {\n        type: \"fixed\",\n        delay: 1000,\n      },\n    });\n    return job.id || null;\n  }\n\n  /**\n   * Queue issue update\n   */\n  async queueIssueUpdate(\n    userId: string,\n    integrationId: number,\n    issueId: string,\n    updateData: any\n  ): Promise<string | null> {\n    const syncQueue = getSyncQueue();\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      issueId,\n      action: \"update\",\n      data: updateData,\n      tenantId: getCurrentTenantId(),\n    };\n\n    const job = await syncQueue.add(\"update-issue\", jobData);\n    return job.id || null;\n  }\n\n  /**\n   * Queue issue refresh (sync single issue from external system)\n   */\n  async queueIssueRefresh(\n    userId: string,\n    integrationId: number,\n    issueId: string\n  ): Promise<string | null> {\n    const syncQueue = getSyncQueue();\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      issueId,\n      action: \"refresh\",\n      tenantId: getCurrentTenantId(),\n    };\n\n    const job = await syncQueue.add(\"refresh-issue\", jobData, {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 1000,\n      },\n      removeOnComplete: true,\n      removeOnFail: false,\n    });\n    return job.id || null;\n  }\n\n  /**\n   * Perform immediate sync (used by worker)\n   */\n  async performSync(\n    userId: string,\n    integrationId: number,\n    projectId?: string,\n    options: SyncOptions = {},\n    job?: Job, // BullMQ Job for progress reporting\n    serviceOptions: SyncServiceOptions = {}\n  ): Promise<{ synced: number; errors: string[] }> {\n    const prisma = serviceOptions.prismaClient || defaultPrisma;\n    const errors: string[] = [];\n    let syncedCount = 0;\n\n    try {\n      // Get full user object for enhance\n      const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          role: {\n            include: {\n              rolePermissions: true,\n            },\n          },\n        },\n      });\n\n      if (!user) {\n        throw new Error(\"User not found\");\n      }\n\n      // Get user context for database operations (lazy-load enhance to reduce memory)\n      const enhance = await getEnhance();\n      const userDb = enhance(prisma, { user }, { kinds: [\"delegate\"] });\n\n      // Get the integration\n      const integration = await userDb.integration.findUnique({\n        where: { id: integrationId },\n        include: {\n          userIntegrationAuths: {\n            where: { userId: userId, isActive: true },\n          },\n        },\n      });\n\n      if (!integration) {\n        throw new Error(\"Integration not found\");\n      }\n\n      // Check authentication based on auth type\n      if (integration.authType === \"OAUTH2\") {\n        // For OAuth, check if user has valid authentication\n        const userAuth = integration.userIntegrationAuths[0];\n        if (!userAuth) {\n          throw new Error(\"User not authenticated for this integration\");\n        }\n\n        // Check if token is expired\n        if (userAuth.tokenExpiresAt && userAuth.tokenExpiresAt < new Date()) {\n          throw new Error(\"Authentication token has expired\");\n        }\n      } else if (\n        integration.authType === \"API_KEY\" ||\n        integration.authType === \"PERSONAL_ACCESS_TOKEN\"\n      ) {\n        // For API key or PAT, check if integration has credentials\n        if (!integration.credentials) {\n          throw new Error(\"Integration is missing credentials\");\n        }\n      } else if (integration.authType !== \"NONE\") {\n        // For other auth types, ensure there's some form of authentication\n        const userAuth = integration.userIntegrationAuths[0];\n        if (!userAuth && !integration.credentials) {\n          throw new Error(\n            \"No authentication credentials found for this integration\"\n          );\n        }\n      }\n\n      // Get the adapter\n      const adapter = await integrationManager.getAdapter(\n        String(integrationId)\n      );\n\n      if (!adapter) {\n        throw new Error(\"Invalid adapter for issue synchronization\");\n      }\n\n      // Get total count of issues to sync\n      const totalIssues = await userDb.issue.count({\n        where: {\n          integrationId,\n          ...(projectId && { projectId: parseInt(projectId) }),\n        },\n      });\n\n      // Process issues in batches to manage memory usage\n      const BATCH_SIZE = 50;\n      let processedCount = 0;\n\n      while (processedCount < totalIssues) {\n        // Fetch a batch of issues\n        const localIssues = await userDb.issue.findMany({\n          where: {\n            integrationId,\n            ...(projectId && { projectId: parseInt(projectId) }),\n          },\n          select: {\n            id: true,\n            externalId: true,\n            externalKey: true,\n            name: true,\n          },\n          skip: processedCount,\n          take: BATCH_SIZE,\n        });\n\n        // Sync each issue in the current batch\n        for (let i = 0; i < localIssues.length; i++) {\n          const localIssue = localIssues[i];\n          const globalIndex = processedCount + i;\n\n          try {\n            // Update progress to keep job alive and inform UI\n            if (job) {\n              const progress = Math.round(((globalIndex + 1) / totalIssues) * 100);\n              await job.updateProgress({\n                current: globalIndex + 1,\n                total: totalIssues,\n                percentage: progress,\n                message: `Syncing issue ${globalIndex + 1} of ${totalIssues}`,\n              });\n            }\n\n            // Use externalId to fetch the latest data, fallback to externalKey or name\n            const issueIdentifier =\n              localIssue.externalId || localIssue.externalKey || localIssue.name;\n\n            if (!issueIdentifier) {\n              errors.push(`Issue ${localIssue.id} has no external identifier`);\n              continue;\n            }\n\n            // Fetch fresh issue data from external system\n            const issueData = await adapter.syncIssue(issueIdentifier);\n\n            // Update cache\n            await issueCache.set(integrationId, issueData.id, issueData);\n\n            // Update local database\n            await this.updateExistingIssue(userDb, integrationId, issueData);\n            syncedCount++;\n\n          } catch (error: any) {\n            errors.push(\n              `Failed to sync issue ${localIssue.externalKey || localIssue.externalId || localIssue.id}: ${error.message}`\n            );\n          }\n        }\n\n        processedCount += localIssues.length;\n\n        // Allow garbage collection between batches\n        if (processedCount < totalIssues) {\n          await new Promise(resolve => setTimeout(resolve, 10));\n        }\n      }\n\n      // Fetch metadata if requested\n      if (options.includeMetadata) {\n        try {\n          // Get metadata based on adapter capabilities\n          const metadata: any = {};\n\n          // Cast to IssueAdapter to access optional methods\n          const issueAdapter = adapter as IssueAdapter;\n\n          if (issueAdapter.getProjects) {\n            metadata.projects = await issueAdapter.getProjects();\n          }\n          if (issueAdapter.getStatuses) {\n            metadata.statuses = await issueAdapter.getStatuses();\n          }\n          if (issueAdapter.getPriorities) {\n            metadata.priorities = await issueAdapter.getPriorities();\n          }\n\n          await issueCache.setMetadata(integrationId, metadata);\n        } catch (error: any) {\n          errors.push(`Failed to fetch metadata: ${error.message}`);\n        }\n      }\n\n      return { synced: syncedCount, errors };\n    } catch (error: any) {\n      errors.push(`Sync failed: ${error.message}`);\n      return { synced: syncedCount, errors };\n    }\n  }\n\n  /**\n   * Refresh a single issue from the external system\n   */\n  async performIssueRefresh(\n    userId: string,\n    integrationId: number,\n    externalIssueId: string,\n    serviceOptions: SyncServiceOptions = {}\n  ): Promise<{ success: boolean; error?: string }> {\n    const prisma = serviceOptions.prismaClient || defaultPrisma;\n    try {\n      // Get full user object for enhance\n      const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          role: {\n            include: {\n              rolePermissions: true,\n            },\n          },\n        },\n      });\n\n      if (!user) {\n        throw new Error(\"User not found\");\n      }\n\n      // Get user context for database operations (lazy-load enhance to reduce memory)\n      const enhance = await getEnhance();\n      const userDb = enhance(prisma, { user }, { kinds: [\"delegate\"] });\n\n      // Get the integration\n      const integration = await userDb.integration.findUnique({\n        where: { id: integrationId },\n        include: {\n          userIntegrationAuths: {\n            where: { userId: userId, isActive: true },\n          },\n        },\n      });\n\n      if (!integration) {\n        throw new Error(\"Integration not found\");\n      }\n\n      // Check authentication based on auth type\n      if (integration.authType === \"OAUTH2\") {\n        // For OAuth, check if user has valid authentication\n        const userAuth = integration.userIntegrationAuths[0];\n        if (!userAuth) {\n          throw new Error(\"User not authenticated for this integration\");\n        }\n\n        // Check if token is expired\n        if (userAuth.tokenExpiresAt && userAuth.tokenExpiresAt < new Date()) {\n          throw new Error(\"Authentication token has expired\");\n        }\n      } else if (\n        integration.authType === \"API_KEY\" ||\n        integration.authType === \"PERSONAL_ACCESS_TOKEN\"\n      ) {\n        // For API key or PAT, check if integration has credentials\n        if (!integration.credentials) {\n          throw new Error(\"Integration is missing credentials\");\n        }\n      } else if (integration.authType !== \"NONE\") {\n        // For other auth types, ensure there's some form of authentication\n        const userAuth = integration.userIntegrationAuths[0];\n        if (!userAuth && !integration.credentials) {\n          throw new Error(\n            \"No authentication credentials found for this integration\"\n          );\n        }\n      }\n\n      // Get the adapter\n      const adapter = await integrationManager.getAdapter(\n        String(integrationId)\n      );\n\n      if (!adapter) {\n        throw new Error(\"Invalid adapter for issue synchronization\");\n      }\n\n      // Check if adapter supports sync\n      const capabilities = adapter.getCapabilities();\n      if (!capabilities.syncIssue) {\n        throw new Error(\n          \"This integration does not support syncing individual issues\"\n        );\n      }\n\n      // For GitHub issues, we need to get the repo context from the stored issue data\n      let issueIdForSync = externalIssueId;\n      if (integration.provider === \"GITHUB\") {\n        // Fetch the stored issue to get the repo context\n        const storedIssue = await userDb.issue.findFirst({\n          where: {\n            integrationId,\n            OR: [\n              { externalId: externalIssueId },\n              { externalKey: externalIssueId },\n            ],\n          },\n        });\n\n        if (storedIssue?.data) {\n          const data = storedIssue.data as Record<string, any>;\n          const customFields = data.customFields as Record<string, any> | undefined;\n          if (customFields?._github_owner && customFields?._github_repo) {\n            // Construct compound ID for GitHub: owner/repo#number\n            const issueNumber = externalIssueId.replace(/^#/, \"\");\n            issueIdForSync = `${customFields._github_owner}/${customFields._github_repo}#${issueNumber}`;\n          }\n        }\n      }\n\n      // Fetch fresh issue data from external system\n      const issueData = await adapter.syncIssue(issueIdForSync);\n\n      // Update cache\n      await issueCache.set(integrationId, issueData.id, issueData);\n\n      // Update local database\n      await this.updateExistingIssue(userDb, integrationId, issueData);\n\n      return { success: true };\n    } catch (error: any) {\n      console.error(`Failed to refresh issue ${externalIssueId}:`, error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Update an existing issue in the local database with fresh data from external system\n   */\n  private async updateExistingIssue(\n    db: any,\n    integrationId: number,\n    issueData: IssueData\n  ): Promise<void> {\n    // Try to find the issue by externalId or externalKey\n    // This handles cases where the database might store either the ID or key\n    const existingIssue = await db.issue.findFirst({\n      where: {\n        integrationId,\n        OR: [\n          { externalId: issueData.id },\n          { externalId: issueData.key },\n          { externalKey: issueData.key },\n          { externalKey: issueData.id },\n        ],\n      },\n    });\n\n    if (!existingIssue) {\n      // Debug: Let's see if there are any issues with this key at all\n      const anyIssueWithKey = await db.issue.findFirst({\n        where: {\n          OR: [\n            { externalId: issueData.id },\n            { externalId: issueData.key },\n            { externalKey: issueData.key },\n            { externalKey: issueData.id },\n            { name: issueData.key },\n          ],\n        },\n        select: {\n          id: true,\n          integrationId: true,\n          externalId: true,\n          externalKey: true,\n          name: true,\n        },\n      });\n\n      throw new Error(\n        `Issue ${issueData.key || issueData.id} not found in local database. Issues must be created through the UI before they can be synced.`\n      );\n    }\n\n    const issuePayload = {\n      name: issueData.key || issueData.id, // Use key if available, otherwise use id\n      title: issueData.title,\n      description: issueData.description || \"\",\n      status: issueData.status,\n      priority: issueData.priority || \"medium\",\n      externalId: issueData.id,\n      externalKey: issueData.key,\n      externalUrl: issueData.url,\n      externalStatus: issueData.status,\n      externalData: issueData.customFields || {},\n      issueTypeId: issueData.issueType?.id,\n      issueTypeName: issueData.issueType?.name,\n      issueTypeIconUrl: issueData.issueType?.iconUrl,\n      lastSyncedAt: new Date(),\n    };\n\n    await db.issue.update({\n      where: { id: existingIssue.id },\n      data: issuePayload,\n    });\n\n    // Manually sync to Elasticsearch since enhanced Prisma client bypasses extensions\n    await syncIssueToElasticsearch(existingIssue.id).catch((error: any) => {\n      console.error(\n        `Failed to sync issue ${existingIssue.id} to Elasticsearch:`,\n        error\n      );\n    });\n  }\n}\n\nexport const syncService = new SyncService();\n", "import { Client } from \"@elastic/elasticsearch\";\nimport { env } from \"../env.js\";\nimport { prisma as defaultPrisma } from \"../lib/prismaBase\";\n\ntype PrismaClientType = typeof defaultPrisma;\n\n// Create singleton instance\nlet esClient: Client | null = null;\n\n/**\n * Get or create Elasticsearch client instance\n */\nexport function getElasticsearchClient(): Client | null {\n  if (!env.ELASTICSEARCH_NODE) {\n    console.warn(\n      \"ELASTICSEARCH_NODE environment variable not set. Elasticsearch integration disabled.\"\n    );\n    return null;\n  }\n\n  if (!esClient) {\n    try {\n      esClient = new Client({\n        node: env.ELASTICSEARCH_NODE,\n        // Add additional configuration as needed\n        maxRetries: 3,\n        requestTimeout: 30000,\n        sniffOnStart: false, // Disable sniffing for custom ports\n      });\n\n    } catch (error) {\n      console.error(\"Failed to initialize Elasticsearch client:\", error);\n      return null;\n    }\n  }\n\n  return esClient;\n}\n\n/**\n * Test Elasticsearch connection\n */\nexport async function testElasticsearchConnection(): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  try {\n    const response = await client.ping();\n    return true;\n  } catch (error) {\n    console.error(\"Elasticsearch connection failed:\", error);\n    return false;\n  }\n}\n\n/**\n * Repository Case index configuration\n */\nexport const REPOSITORY_CASE_INDEX = \"testplanit-repository-cases\";\n\n/**\n * Get the repository case index name, optionally prefixed with tenant ID\n * In multi-tenant mode: testplanit-{tenantId}-repository-cases\n * In single-tenant mode: testplanit-repository-cases\n */\nexport function getRepositoryCaseIndexName(tenantId?: string): string {\n  if (tenantId) {\n    return `testplanit-${tenantId}-repository-cases`;\n  }\n  return REPOSITORY_CASE_INDEX;\n}\n\n/**\n * Repository Case mapping for Elasticsearch\n */\nexport const repositoryCaseMapping = {\n  properties: {\n    id: { type: \"integer\" as const },\n    projectId: { type: \"integer\" as const },\n    projectName: { type: \"keyword\" as const },\n    projectIconUrl: { type: \"keyword\" as const },\n    repositoryId: { type: \"integer\" as const },\n    folderId: { type: \"integer\" as const },\n    folderPath: { type: \"keyword\" as const },\n    templateId: { type: \"integer\" as const },\n    templateName: { type: \"keyword\" as const },\n    name: {\n      type: \"text\" as const,\n      analyzer: \"standard\",\n      fields: {\n        keyword: { type: \"keyword\" as const },\n        suggest: { type: \"completion\" as const },\n      },\n    },\n    className: { type: \"keyword\" as const },\n    source: { type: \"keyword\" as const },\n    stateId: { type: \"integer\" as const },\n    stateName: { type: \"keyword\" as const },\n    stateIcon: { type: \"keyword\" as const },\n    stateColor: { type: \"keyword\" as const },\n    estimate: { type: \"integer\" as const },\n    forecastManual: { type: \"integer\" as const },\n    forecastAutomated: { type: \"float\" as const },\n    automated: { type: \"boolean\" as const },\n    isArchived: { type: \"boolean\" as const },\n    isDeleted: { type: \"boolean\" as const },\n    createdAt: { type: \"date\" as const },\n    creatorId: { type: \"keyword\" as const },\n    creatorName: { type: \"text\" as const },\n    tags: {\n      type: \"nested\" as const,\n      properties: {\n        id: { type: \"integer\" as const },\n        name: { type: \"keyword\" as const },\n      },\n    },\n    customFields: {\n      type: \"nested\" as const,\n      properties: {\n        fieldId: { type: \"integer\" as const },\n        fieldName: { type: \"keyword\" as const },\n        fieldType: { type: \"keyword\" as const },\n        value: { type: \"text\" as const },\n      },\n    },\n    steps: {\n      type: \"nested\" as const,\n      properties: {\n        id: { type: \"integer\" as const },\n        order: { type: \"integer\" as const },\n        step: { type: \"text\" as const },\n        expectedResult: { type: \"text\" as const },\n        isSharedStep: { type: \"boolean\" as const },\n        sharedStepGroupId: { type: \"integer\" as const },\n        sharedStepGroupName: { type: \"text\" as const },\n      },\n    },\n    // Full-text search field combining multiple fields\n    searchableContent: { type: \"text\" as const },\n  },\n};\n\n/**\n * Get Elasticsearch replica settings from database\n */\nasync function getElasticsearchSettings(prismaClient?: PrismaClientType) {\n  const prisma = prismaClient || defaultPrisma;\n  try {\n    const config = await prisma.appConfig.findUnique({\n      where: { key: \"elasticsearch_replicas\" }\n    });\n\n    // Default to 0 for single-node clusters\n    return {\n      numberOfReplicas: config?.value ? (config.value as number) : 0\n    };\n  } catch (error) {\n    console.warn(\"Failed to get Elasticsearch settings from database, using defaults:\", error);\n    return { numberOfReplicas: 0 };\n  }\n}\n\n/**\n * Create or update the repository cases index\n * @param prismaClient - Optional Prisma client for getting settings\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function createRepositoryCaseIndex(\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = getRepositoryCaseIndexName(tenantId);\n\n  try {\n    // Get settings from database\n    const settings = await getElasticsearchSettings(prismaClient);\n\n    // Check if index exists\n    const exists = await client.indices.exists({\n      index: indexName,\n    });\n\n    if (!exists) {\n      // Create index with mapping\n      await client.indices.create({\n        index: indexName,\n        settings: {\n          number_of_shards: 1,\n          number_of_replicas: settings.numberOfReplicas,\n          analysis: {\n            analyzer: {\n              standard: {\n                type: \"standard\",\n                stopwords: \"_english_\",\n              },\n            },\n          },\n        },\n        mappings: repositoryCaseMapping,\n      });\n      console.log(`Created Elasticsearch index: ${indexName}`);\n    } else {\n      // Index already exists, skip update to avoid field type conflicts\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Failed to create/update Elasticsearch index ${indexName}:`, error);\n    return false;\n  }\n}\n\n/**\n * Interface for indexing repository case data\n */\nexport interface RepositoryCaseDocument {\n  id: number;\n  projectId: number;\n  projectName: string;\n  projectIconUrl?: string | null;\n  repositoryId: number;\n  folderId: number;\n  folderPath: string;\n  templateId: number;\n  templateName: string;\n  name: string;\n  className?: string | null;\n  source: string;\n  stateId: number;\n  stateName: string;\n  stateIcon?: string;\n  stateColor?: string;\n  estimate?: number | null;\n  forecastManual?: number | null;\n  forecastAutomated?: number | null;\n  automated: boolean;\n  isArchived: boolean;\n  isDeleted: boolean;\n  createdAt: Date;\n  creatorId: string;\n  creatorName: string;\n  creatorImage?: string | null;\n  tags?: Array<{ id: number; name: string }>;\n  customFields?: Array<{\n    fieldId: number;\n    fieldName: string;\n    fieldType: string;\n    value: any;\n  }>;\n  steps?: Array<{\n    id: number;\n    order: number;\n    step: string;\n    expectedResult: string;\n    isSharedStep?: boolean;\n    sharedStepGroupId?: number;\n    sharedStepGroupName?: string;\n  }>;\n  searchableContent?: string;\n}\n", "import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod/v4\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z\n      .string()\n      .refine(\n        (str) => !str.includes(\"YOUR_MYSQL_URL_HERE\"),\n        \"You forgot to change the default URL\",\n      ),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .prefault(\"development\"),\n    NEXTAUTH_SECRET:\n      process.env.NODE_ENV === \"production\"\n        ? z.string()\n        : z.string().optional(),\n    NEXTAUTH_URL: z.preprocess(\n      // This makes Vercel deployments not fail if you don't set NEXTAUTH_URL\n      // Since NextAuth.js automatically uses the VERCEL_URL if present.\n      (str) => process.env.VERCEL_URL ?? str,\n      // VERCEL_URL doesn't include `https` so it cant be validated as a URL\n      process.env.VERCEL ? z.string() : z.url(),\n    ),\n    ELASTICSEARCH_NODE: z.url().optional(),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,\n    NEXTAUTH_URL: process.env.NEXTAUTH_URL,\n    ELASTICSEARCH_NODE: process.env.ELASTICSEARCH_NODE,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n", "import { Client } from \"@elastic/elasticsearch\";\nimport { SearchableEntityType, CustomFieldDocument } from \"~/types/search\";\nimport { getElasticsearchClient } from \"./elasticsearchService\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\n\ntype PrismaClientType = typeof defaultPrisma;\n\n// Re-export for convenience\nexport { getElasticsearchClient };\n\n// Base index names for each entity type (without tenant prefix)\nconst BASE_INDEX_NAMES = {\n  [SearchableEntityType.REPOSITORY_CASE]: \"repository-cases\",\n  [SearchableEntityType.SHARED_STEP]: \"shared-steps\",\n  [SearchableEntityType.TEST_RUN]: \"test-runs\",\n  [SearchableEntityType.SESSION]: \"sessions\",\n  [SearchableEntityType.PROJECT]: \"projects\",\n  [SearchableEntityType.ISSUE]: \"issues\",\n  [SearchableEntityType.MILESTONE]: \"milestones\",\n} as const;\n\n/**\n * Get the index name for an entity type, optionally prefixed with tenant ID\n * In multi-tenant mode: testplanit-{tenantId}-{entityType}\n * In single-tenant mode: testplanit-{entityType}\n */\nexport function getEntityIndexName(\n  entityType: SearchableEntityType,\n  tenantId?: string\n): string {\n  const baseName = BASE_INDEX_NAMES[entityType];\n  if (tenantId) {\n    return `testplanit-${tenantId}-${baseName}`;\n  }\n  return `testplanit-${baseName}`;\n}\n\n// Legacy constant for backward compatibility (single-tenant mode)\n// @deprecated Use getEntityIndexName() instead for multi-tenant support\nexport const ENTITY_INDICES = {\n  [SearchableEntityType.REPOSITORY_CASE]: \"testplanit-repository-cases\",\n  [SearchableEntityType.SHARED_STEP]: \"testplanit-shared-steps\",\n  [SearchableEntityType.TEST_RUN]: \"testplanit-test-runs\",\n  [SearchableEntityType.SESSION]: \"testplanit-sessions\",\n  [SearchableEntityType.PROJECT]: \"testplanit-projects\",\n  [SearchableEntityType.ISSUE]: \"testplanit-issues\",\n  [SearchableEntityType.MILESTONE]: \"testplanit-milestones\",\n} as const;\n\n// Base mapping for all entities\nconst baseMapping = {\n  properties: {\n    id: { type: \"integer\" as const },\n    projectId: { type: \"integer\" as const },\n    projectName: { type: \"keyword\" as const },\n    projectIconUrl: { type: \"keyword\" as const },\n    createdAt: { type: \"date\" as const },\n    updatedAt: { type: \"date\" as const },\n    createdById: { type: \"keyword\" as const },\n    createdByName: { type: \"keyword\" as const },\n    createdByImage: { type: \"keyword\" as const },\n    searchableContent: {\n      type: \"text\" as const,\n      analyzer: \"standard\",\n      fields: {\n        keyword: {\n          type: \"keyword\" as const,\n          ignore_above: 256,\n        },\n      },\n    },\n    customFields: {\n      type: \"nested\" as const,\n      properties: {\n        fieldId: { type: \"integer\" as const },\n        fieldName: { type: \"keyword\" as const },\n        fieldType: { type: \"keyword\" as const },\n        value: { type: \"text\" as const },\n        valueKeyword: { type: \"keyword\" as const },\n        valueNumeric: { type: \"double\" as const },\n        valueBoolean: { type: \"boolean\" as const },\n        valueDate: { type: \"date\" as const },\n        valueArray: { type: \"keyword\" as const },\n        fieldOption: {\n          type: \"object\" as const,\n          properties: {\n            id: { type: \"integer\" as const },\n            name: { type: \"keyword\" as const },\n            icon: {\n              type: \"object\" as const,\n              properties: {\n                name: { type: \"keyword\" as const },\n              },\n            },\n            iconColor: {\n              type: \"object\" as const,\n              properties: {\n                value: { type: \"keyword\" as const },\n              },\n            },\n          },\n        },\n        fieldOptions: {\n          type: \"nested\" as const,\n          properties: {\n            id: { type: \"integer\" as const },\n            name: { type: \"keyword\" as const },\n            icon: {\n              type: \"object\" as const,\n              properties: {\n                name: { type: \"keyword\" as const },\n              },\n            },\n            iconColor: {\n              type: \"object\" as const,\n              properties: {\n                value: { type: \"keyword\" as const },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n};\n\n// Entity-specific mappings\nexport const ENTITY_MAPPINGS = {\n  [SearchableEntityType.REPOSITORY_CASE]: {\n    properties: {\n      ...baseMapping.properties,\n      repositoryId: { type: \"integer\" as const },\n      folderId: { type: \"integer\" as const },\n      folderPath: { type: \"keyword\" as const },\n      templateId: { type: \"integer\" as const },\n      templateName: { type: \"keyword\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      className: { type: \"keyword\" as const },\n      source: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      estimate: { type: \"integer\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      automated: { type: \"boolean\" as const },\n      isArchived: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n      steps: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          order: { type: \"integer\" as const },\n          step: { type: \"text\" as const },\n          expectedResult: { type: \"text\" as const },\n          isSharedStep: { type: \"boolean\" as const },\n          sharedStepGroupId: { type: \"integer\" as const },\n          sharedStepGroupName: { type: \"text\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.SHARED_STEP]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      isDeleted: { type: \"boolean\" as const },\n      items: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          order: { type: \"integer\" as const },\n          step: { type: \"text\" as const },\n          expectedResult: { type: \"text\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.TEST_RUN]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      configId: { type: \"integer\" as const },\n      configurationName: { type: \"keyword\" as const },\n      milestoneId: { type: \"integer\" as const },\n      milestoneName: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      elapsed: { type: \"integer\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      testRunType: { type: \"keyword\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.SESSION]: {\n    properties: {\n      ...baseMapping.properties,\n      templateId: { type: \"integer\" as const },\n      templateName: { type: \"keyword\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      mission: { type: \"text\" as const },\n      configId: { type: \"integer\" as const },\n      configurationName: { type: \"keyword\" as const },\n      milestoneId: { type: \"integer\" as const },\n      milestoneName: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      assignedToId: { type: \"keyword\" as const },\n      assignedToName: { type: \"keyword\" as const },\n      assignedToImage: { type: \"keyword\" as const },\n      estimate: { type: \"integer\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      elapsed: { type: \"integer\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.PROJECT]: {\n    properties: {\n      id: { type: \"integer\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      iconUrl: { type: \"keyword\" as const },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      createdAt: { type: \"date\" as const },\n      createdById: { type: \"keyword\" as const },\n      createdByName: { type: \"keyword\" as const },\n      createdByImage: { type: \"keyword\" as const },\n      searchableContent: { type: \"text\" as const },\n    },\n  },\n  [SearchableEntityType.ISSUE]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      title: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      description: { type: \"text\" as const },\n      externalId: { type: \"keyword\" as const },\n      note: { type: \"text\" as const },\n      url: { type: \"keyword\" as const },\n      issueSystem: { type: \"text\" as const },\n      isDeleted: { type: \"boolean\" as const },\n    },\n  },\n  [SearchableEntityType.MILESTONE]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      milestoneTypeId: { type: \"integer\" as const },\n      milestoneTypeName: { type: \"keyword\" as const },\n      milestoneTypeIcon: { type: \"keyword\" as const },\n      parentId: { type: \"integer\" as const },\n      parentName: { type: \"keyword\" as const },\n      dueDate: { type: \"date\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      isDeleted: { type: \"boolean\" as const },\n    },\n  },\n};\n\n/**\n * Get Elasticsearch replica settings from database\n */\nasync function getElasticsearchSettings(prismaClient?: PrismaClientType) {\n  const prisma = prismaClient || defaultPrisma;\n  try {\n    const config = await prisma.appConfig.findUnique({\n      where: { key: \"elasticsearch_replicas\" }\n    });\n\n    // Default to 0 for single-node clusters\n    return {\n      numberOfReplicas: config?.value ? (config.value as number) : 0\n    };\n  } catch (error) {\n    console.warn(\"Failed to get Elasticsearch settings from database, using defaults:\", error);\n    return { numberOfReplicas: 0 };\n  }\n}\n\n/**\n * Create index for a specific entity type\n * @param entityType - The type of entity to create an index for\n * @param prismaClient - Optional Prisma client for getting settings\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function createEntityIndex(\n  entityType: SearchableEntityType,\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = getEntityIndexName(entityType, tenantId);\n  const mapping = ENTITY_MAPPINGS[entityType];\n\n  try {\n    // Get settings from database\n    const settings = await getElasticsearchSettings(prismaClient);\n\n    const indexExists = await client.indices.exists({ index: indexName });\n\n    if (!indexExists) {\n      await client.indices.create({\n        index: indexName,\n        mappings: mapping,\n        settings: {\n          number_of_shards: 1,\n          number_of_replicas: settings.numberOfReplicas,\n          analysis: {\n            analyzer: {\n              standard: {\n                type: \"standard\",\n                stopwords: \"_english_\",\n              },\n            },\n          },\n        },\n      });\n\n      console.log(`Created Elasticsearch index: ${indexName}`);\n      return true;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Failed to create index ${indexName} for ${entityType}:`, error);\n    return false;\n  }\n}\n\n/**\n * Create all entity indices\n * @param prismaClient - Optional Prisma client for getting settings\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function createAllEntityIndices(\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<void> {\n  const entityTypes = Object.values(SearchableEntityType);\n\n  for (const entityType of entityTypes) {\n    await createEntityIndex(entityType, prismaClient, tenantId);\n  }\n}\n\n/**\n * Transform custom field values based on field type\n */\nexport function transformCustomFieldValue(\n  fieldType: string,\n  value: any\n): Partial<CustomFieldDocument> {\n  const base: Partial<CustomFieldDocument> = {};\n\n  switch (fieldType) {\n    case \"Checkbox\":\n      base.valueBoolean = Boolean(value);\n      base.value = String(value);\n      break;\n\n    case \"Date\":\n      if (value) {\n        const date = new Date(value);\n        if (!isNaN(date.getTime())) {\n          base.valueDate = date.toISOString();\n          base.value = date.toISOString();\n        }\n      }\n      break;\n\n    case \"Number\":\n      base.valueNumeric = Number(value);\n      base.value = String(value);\n      break;\n\n    case \"Multi-Select\":\n      if (Array.isArray(value)) {\n        base.valueArray = value.map((v) => String(v));\n        base.value = value.join(\" \");\n      } else if (value) {\n        // Handle case where value might be a JSON string\n        try {\n          const parsed = JSON.parse(value);\n          if (Array.isArray(parsed)) {\n            base.valueArray = parsed.map((v) => String(v));\n            base.value = parsed.join(\" \");\n          }\n        } catch {\n          base.value = String(value);\n        }\n      }\n      break;\n\n    case \"Select\":\n      base.valueKeyword = String(value);\n      base.value = String(value);\n      break;\n\n    case \"Text String\":\n    case \"Link\":\n      base.valueKeyword = String(value);\n      base.value = String(value);\n      break;\n\n    case \"Text Long\":\n      // Extract text from TipTap JSON\n      if (value) {\n        try {\n          const content = typeof value === \"string\" ? JSON.parse(value) : value;\n          const textContent = extractTextFromTipTap(content);\n          base.value = textContent;\n        } catch {\n          base.value = String(value);\n        }\n      }\n      break;\n\n    case \"Steps\":\n      // Steps are handled separately in the steps array\n      if (value) {\n        base.value = String(value);\n      }\n      break;\n\n    default:\n      base.value = String(value);\n  }\n\n  return base;\n}\n\n/**\n * Extract plain text from TipTap JSON content\n */\nfunction extractTextFromTipTap(content: any): string {\n  if (!content || !content.content) return \"\";\n\n  let text = \"\";\n\n  function extractFromNode(node: any) {\n    if (node.text) {\n      text += node.text + \" \";\n    }\n    if (node.content) {\n      node.content.forEach(extractFromNode);\n    }\n  }\n\n  content.content.forEach(extractFromNode);\n  return text.trim();\n}\n\n/**\n * Build custom field documents for indexing\n */\nexport function buildCustomFieldDocuments(\n  fieldValues: Array<{\n    fieldId: number;\n    field: {\n      displayName: string;\n      systemName: string;\n      type?: { type: string };\n      fieldOptions?: Array<{\n        fieldOption: {\n          id: number;\n          name: string;\n          icon?: { name: string };\n          iconColor?: { value: string };\n        };\n      }>;\n    };\n    value: any;\n  }>\n): CustomFieldDocument[] {\n  return fieldValues.map((cfv) => {\n    const fieldType = cfv.field.type?.type || cfv.field.systemName;\n    const transformed = transformCustomFieldValue(fieldType, cfv.value);\n\n    const doc: CustomFieldDocument = {\n      fieldId: cfv.fieldId,\n      fieldName: cfv.field.displayName,\n      fieldType: fieldType,\n      ...transformed,\n    };\n\n    // For single select/dropdown fields, find the selected option\n    if (\n      cfv.value &&\n      cfv.field.fieldOptions &&\n      (fieldType === \"Select\" || fieldType === \"Dropdown\")\n    ) {\n      const selectedOption = cfv.field.fieldOptions.find(\n        (fo) => fo.fieldOption.id === cfv.value\n      );\n      if (selectedOption) {\n        doc.fieldOption = {\n          id: selectedOption.fieldOption.id,\n          name: selectedOption.fieldOption.name,\n          icon: selectedOption.fieldOption.icon,\n          iconColor: selectedOption.fieldOption.iconColor,\n        };\n      }\n    }\n\n    // Add all field options for multi-select fields\n    if (cfv.field.fieldOptions && fieldType === \"Multi-Select\") {\n      doc.fieldOptions = cfv.field.fieldOptions.map((fo) => ({\n        id: fo.fieldOption.id,\n        name: fo.fieldOption.name,\n        icon: fo.fieldOption.icon,\n        iconColor: fo.fieldOption.iconColor,\n      }));\n    }\n\n    return doc;\n  });\n}\n\n/**\n * Get all indices for a list of entity types\n * @param entityTypes - Optional list of entity types to get indices for\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport function getIndicesForEntityTypes(\n  entityTypes?: SearchableEntityType[],\n  tenantId?: string\n): string[] {\n  const types = entityTypes && entityTypes.length > 0\n    ? entityTypes\n    : Object.values(SearchableEntityType);\n\n  return types.map((type) => getEntityIndexName(type, tenantId));\n}\n\n/**\n * Build aggregations for faceted search\n */\nexport function buildAggregations(\n  facets: string[],\n  entityTypes?: SearchableEntityType[]\n): Record<string, any> {\n  const aggs: Record<string, any> = {};\n\n  // Common facets\n  if (facets.includes(\"projects\") || facets.includes(\"projectId\")) {\n    aggs.projects = {\n      terms: {\n        field: \"projectId\",\n        size: 100,\n      },\n    };\n  }\n\n  if (facets.includes(\"states\") || facets.includes(\"stateId\")) {\n    aggs.states = {\n      terms: {\n        field: \"stateId\",\n        size: 50,\n      },\n    };\n  }\n\n  if (facets.includes(\"tags\") || facets.includes(\"tagIds\")) {\n    aggs.tags = {\n      terms: {\n        field: \"tagIds\",\n        size: 100,\n      },\n    };\n  }\n\n  if (facets.includes(\"creators\") || facets.includes(\"creatorId\")) {\n    aggs.creators = {\n      terms: {\n        field: \"createdById.keyword\",\n        size: 100,\n      },\n    };\n  }\n\n  // Entity-specific aggregations\n  if (\n    !entityTypes ||\n    entityTypes.includes(SearchableEntityType.REPOSITORY_CASE)\n  ) {\n    if (facets.includes(\"folders\") || facets.includes(\"folderId\")) {\n      aggs.folders = {\n        terms: {\n          field: \"folderId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"templates\") || facets.includes(\"templateId\")) {\n      aggs.templates = {\n        terms: {\n          field: \"templateId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"automated\")) {\n      aggs.automated = {\n        terms: {\n          field: \"automated\",\n        },\n      };\n    }\n  }\n\n  if (!entityTypes || entityTypes.includes(SearchableEntityType.TEST_RUN)) {\n    if (\n      facets.includes(\"configurations\") ||\n      facets.includes(\"configurationId\")\n    ) {\n      aggs.configurations = {\n        terms: {\n          field: \"configurationId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"milestones\") || facets.includes(\"milestoneId\")) {\n      aggs.milestones = {\n        terms: {\n          field: \"milestoneId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"testRunType\")) {\n      aggs.testRunType = {\n        terms: {\n          field: \"testRunType\",\n        },\n      };\n    }\n  }\n\n  if (!entityTypes || entityTypes.includes(SearchableEntityType.SESSION)) {\n    if (facets.includes(\"assignedTo\") || facets.includes(\"assignedToId\")) {\n      aggs.assignedTo = {\n        terms: {\n          field: \"assignedToId.keyword\",\n          size: 100,\n        },\n      };\n    }\n  }\n\n  // Entity type counts\n  aggs.entityTypes = {\n    terms: {\n      field: \"_index\",\n      size: 10,\n    },\n  };\n\n  return aggs;\n}\n", "import {\n  getElasticsearchClient,\n  getEntityIndexName,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Issue, PrismaClient } from \"@prisma/client\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\n/**\n * Type for issue with all required relations for indexing\n */\ntype IssueForIndexing = Issue & {\n  createdBy: { name: string; image?: string | null };\n  integration?: { name: string } | null;\n  // Direct project relationship (preferred)\n  project?: { id: number; name: string; iconUrl?: string | null } | null;\n  // Fallback: Try to get project from any relationship\n  repositoryCases?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  sessions?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  testRuns?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  sessionResults?: Array<{\n    session: {\n      project: { id: number; name: string; iconUrl?: string | null };\n    };\n  }>;\n  testRunResults?: Array<{\n    testRun: {\n      project: { id: number; name: string; iconUrl?: string | null };\n    };\n  }>;\n  testRunStepResults?: Array<{\n    testRunResult: {\n      testRun: {\n        project: { id: number; name: string; iconUrl?: string | null };\n      };\n    };\n  }>;\n};\n\n/**\n * Helper function to find project info from any issue relationship\n * Checks direct project relationship first, then falls back to relationship tables\n */\nfunction getProjectFromIssue(issue: IssueForIndexing): {\n  id: number;\n  name: string;\n  iconUrl?: string | null;\n} | null {\n  // Check direct project relationship first (most common and efficient)\n  if (issue.project) {\n    return issue.project;\n  }\n\n  // Fallback: Try repository cases\n  if (issue.repositoryCases?.[0]?.project) {\n    return issue.repositoryCases[0].project;\n  }\n\n  // Try sessions\n  if (issue.sessions?.[0]?.project) {\n    return issue.sessions[0].project;\n  }\n\n  // Try test runs\n  if (issue.testRuns?.[0]?.project) {\n    return issue.testRuns[0].project;\n  }\n\n  // Try session results\n  if (issue.sessionResults?.[0]?.session?.project) {\n    return issue.sessionResults[0].session.project;\n  }\n\n  // Try test run results\n  if (issue.testRunResults?.[0]?.testRun?.project) {\n    return issue.testRunResults[0].testRun.project;\n  }\n\n  // Try test run step results\n  if (issue.testRunStepResults?.[0]?.testRunResult?.testRun?.project) {\n    return issue.testRunStepResults[0].testRunResult.testRun.project;\n  }\n\n  return null;\n}\n\n/**\n * Index a single issue to Elasticsearch\n * @param issue - The issue to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function indexIssue(\n  issue: IssueForIndexing,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.ISSUE, tenantId);\n\n  // Try to get project info from any linked relationship\n  const projectInfo = getProjectFromIssue(issue);\n\n  // Skip indexing if no project is found (orphaned issue)\n  if (!projectInfo) {\n    console.warn(`Issue ${issue.id} (${issue.name}) has no linked project, skipping indexing`);\n    return;\n  }\n\n  // Extract text from TipTap JSON for note field\n  const noteText = issue.note ? extractTextFromNode(issue.note) : \"\";\n\n  const searchableContent = [\n    issue.name,\n    issue.title,\n    issue.description || \"\",\n    issue.externalId || \"\",\n    noteText,\n    issue.integration?.name || \"\",\n  ].join(\" \");\n\n  const document = {\n    id: issue.id,\n    projectId: projectInfo.id,\n    projectName: projectInfo.name,\n    projectIconUrl: projectInfo.iconUrl,\n    name: issue.name,\n    title: issue.title,\n    description: issue.description,\n    externalId: issue.externalId,\n    note: noteText,\n    url: (issue.data as any)?.url,\n    issueSystem: issue.integration?.name || \"Unknown\",\n    isDeleted: issue.isDeleted,\n    createdAt: issue.createdAt,\n    createdById: issue.createdById,\n    createdByName: issue.createdBy.name,\n    createdByImage: issue.createdBy.image,\n    searchableContent,\n  };\n\n  await client.index({\n    index: indexName,\n    id: issue.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete an issue from Elasticsearch\n * @param issueId - The ID of the issue to delete\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function deleteIssueFromIndex(\n  issueId: number,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.ISSUE, tenantId);\n\n  try {\n    await client.delete({\n      index: indexName,\n      id: issueId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete issue from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single issue to Elasticsearch\n * @param issueId - The ID of the issue to sync\n * @param prismaClient - Optional Prisma client for tenant-specific queries\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncIssueToElasticsearch(\n  issueId: number,\n  prismaClient?: PrismaClient,\n  tenantId?: string\n): Promise<boolean> {\n  const prisma = prismaClient || defaultPrisma;\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const issue = await prisma.issue.findUnique({\n      where: { id: issueId },\n      include: {\n        createdBy: true,\n        integration: true,\n        // Include direct project relationship (preferred)\n        project: true,\n        // Fallback: Check all possible relationships to find project\n        repositoryCases: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        sessions: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        testRuns: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        sessionResults: {\n          take: 1,\n          include: {\n            session: {\n              include: {\n                project: true,\n              },\n            },\n          },\n        },\n        testRunResults: {\n          take: 1,\n          include: {\n            testRun: {\n              include: {\n                project: true,\n              },\n            },\n          },\n        },\n        testRunStepResults: {\n          take: 1,\n          include: {\n            testRunResult: {\n              include: {\n                testRun: {\n                  include: {\n                    project: true,\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (!issue) {\n      console.warn(`Issue ${issueId} not found`);\n      return false;\n    }\n\n    // Index issue including deleted ones (filtering happens at search time based on admin permissions)\n    // Note: indexIssue will skip issues without a valid project link\n    await indexIssue(issue as IssueForIndexing, tenantId);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync issue ${issueId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index issues for a project\n * @param projectId - The project ID to sync issues for\n * @param db - Prisma client instance\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncProjectIssuesToElasticsearch(\n  projectId: number,\n  db: any,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.ISSUE, tenantId);\n\n  console.log(`Starting issue sync for project ${projectId}${tenantId ? ` (tenant: ${tenantId})` : \"\"}`);\n\n  // Find issues either by direct projectId or through any relationship\n  const issues = await db.issue.findMany({\n    where: {\n      // Include deleted items (filtering happens at search time based on admin permissions)\n      OR: [\n        // Direct project relationship (preferred)\n        { projectId, project: { isDeleted: false } },\n        // Fallback: Find through relationships\n        { repositoryCases: { some: { projectId, project: { isDeleted: false } } } },\n        { sessions: { some: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        { testRuns: { some: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        { sessionResults: { some: { session: { projectId, isDeleted: false, project: { isDeleted: false } } } } },\n        { testRunResults: { some: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } } },\n        {\n          testRunStepResults: {\n            some: { testRunResult: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n          },\n        },\n      ],\n    },\n    include: {\n      createdBy: true,\n      integration: true,\n      // Include direct project relationship (preferred)\n      project: true,\n      // Fallback relationships\n      repositoryCases: {\n        where: { projectId, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      sessions: {\n        where: { projectId, isDeleted: false, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      testRuns: {\n        where: { projectId, isDeleted: false, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      sessionResults: {\n        where: { session: { projectId, isDeleted: false, project: { isDeleted: false } } },\n        take: 1,\n        include: {\n          session: {\n            include: { project: true },\n          },\n        },\n      },\n      testRunResults: {\n        where: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } },\n        take: 1,\n        include: {\n          testRun: {\n            include: { project: true },\n          },\n        },\n      },\n      testRunStepResults: {\n        where: { testRunResult: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        take: 1,\n        include: {\n          testRunResult: {\n            include: {\n              testRun: {\n                include: { project: true },\n              },\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (issues.length === 0) {\n    console.log(\"No issues to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  let skippedCount = 0;\n\n  for (const issue of issues) {\n    // Try to get project info from any linked relationship\n    const projectInfo = getProjectFromIssue(issue as IssueForIndexing);\n\n    // Skip issues without a valid project link\n    if (!projectInfo) {\n      console.warn(`Issue ${issue.id} has no linked project, skipping`);\n      skippedCount++;\n      continue;\n    }\n\n    // Extract text from TipTap JSON for note field\n    const noteText = issue.note ? extractTextFromNode(issue.note) : \"\";\n\n    const searchableContent = [\n      issue.name,\n      issue.title,\n      issue.description || \"\",\n      issue.externalId || \"\",\n      noteText,\n      issue.integration?.name || \"\",\n    ].join(\" \");\n\n    bulkBody.push({\n      index: {\n        _index: indexName,\n        _id: issue.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: issue.id,\n      projectId: projectInfo.id,\n      projectName: projectInfo.name,\n      projectIconUrl: projectInfo.iconUrl,\n      name: issue.name,\n      title: issue.title,\n      description: issue.description,\n      externalId: issue.externalId,\n      note: noteText,\n      url: (issue.data as any)?.url,\n      issueSystem: issue.integration?.name || \"Unknown\",\n      isDeleted: issue.isDeleted,\n      createdAt: issue.createdAt,\n      createdById: issue.createdById,\n      createdByName: issue.createdBy.name,\n      createdByImage: issue.createdBy.image,\n      searchableContent,\n    });\n  }\n\n  if (bulkBody.length === 0) {\n    console.log(\n      `No valid issues to index (${skippedCount} orphaned issues skipped)`\n    );\n    return;\n  }\n\n  try {\n    const bulkResponse = await client.bulk({ body: bulkBody, refresh: true });\n    if (bulkResponse.errors) {\n      const errorItems = bulkResponse.items.filter(\n        (item: any) => item.index?.error\n      );\n      console.error(`Bulk indexing errors: ${errorItems.length} failed documents`);\n      // Log detailed error information\n      errorItems.slice(0, 10).forEach((item: any) => {\n        if (item.index?.error) {\n          console.error(`  Failed to index document ${item.index._id}:`);\n          console.error(`    Error type: ${item.index.error.type}`);\n          console.error(`    Error reason: ${item.index.error.reason}`);\n          if (item.index.error.caused_by) {\n            console.error(`    Caused by: ${JSON.stringify(item.index.error.caused_by)}`);\n          }\n        }\n      });\n      if (errorItems.length > 10) {\n        console.error(`  ... and ${errorItems.length - 10} more errors`);\n      }\n    } else {\n      console.log(\n        `Successfully indexed ${bulkBody.length / 2} issues (${skippedCount} orphaned issues skipped)`\n      );\n    }\n  } catch (error) {\n    console.error(\"Failed to index issues:\", error);\n  }\n}\n", "/**\n * Recursively extracts text content from a JSON node structure\n * (commonly used in Tiptap/ProseMirror).\n */\nexport const extractTextFromNode = (node: any): string => {\n  if (!node) return \"\";\n\n  // If the node itself is just a string, return it\n  if (typeof node === \"string\") return node;\n\n  // If the node has a direct text property, return it\n  if (node.text && typeof node.text === \"string\") return node.text;\n\n  // If the node has a content array, recursively process each item\n  if (node.content && Array.isArray(node.content)) {\n    return node.content.map(extractTextFromNode).join(\"\"); // Join without spaces for raw text\n  }\n\n  // Return empty string if no text found or structure is unexpected\n  return \"\";\n};\n", "// lib/multiTenantPrisma.ts\n// Multi-tenant Prisma client factory for shared worker containers\n\nimport { PrismaClient } from \"@prisma/client\";\nimport * as fs from \"fs\";\n\n/**\n * Tenant configuration interface\n */\nexport interface TenantConfig {\n  tenantId: string;\n  databaseUrl: string;\n  elasticsearchNode?: string;\n  elasticsearchIndex?: string;\n}\n\n/**\n * Check if multi-tenant mode is enabled\n */\nexport function isMultiTenantMode(): boolean {\n  return process.env.MULTI_TENANT_MODE === \"true\";\n}\n\n/**\n * Get the current instance's tenant ID\n * In multi-tenant mode, each web app instance belongs to a single tenant\n * Set via INSTANCE_TENANT_ID environment variable\n * Returns undefined in single-tenant mode or if not configured\n */\nexport function getCurrentTenantId(): string | undefined {\n  if (!isMultiTenantMode()) {\n    return undefined;\n  }\n  return process.env.INSTANCE_TENANT_ID;\n}\n\n/**\n * Cache of Prisma clients per tenant to avoid creating new connections for each job\n */\nconst tenantClients: Map<string, PrismaClient> = new Map();\n\n/**\n * Tenant configurations loaded from environment or config file\n */\nlet tenantConfigs: Map<string, TenantConfig> | null = null;\n\n/**\n * Path to the tenant config file (can be set via TENANT_CONFIG_FILE env var)\n */\nconst TENANT_CONFIG_FILE = process.env.TENANT_CONFIG_FILE || \"/config/tenants.json\";\n\n/**\n * Load tenant configurations from file\n */\nfunction loadTenantsFromFile(filePath: string): Map<string, TenantConfig> {\n  const configs = new Map<string, TenantConfig>();\n\n  try {\n    if (fs.existsSync(filePath)) {\n      const fileContent = fs.readFileSync(filePath, \"utf-8\");\n      const parsed = JSON.parse(fileContent) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(parsed)) {\n        configs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n        });\n      }\n      console.log(`Loaded ${configs.size} tenant configurations from ${filePath}`);\n    }\n  } catch (error) {\n    console.error(`Failed to load tenant configs from ${filePath}:`, error);\n  }\n\n  return configs;\n}\n\n/**\n * Reload tenant configurations from file (for dynamic updates)\n * This allows adding new tenants without restarting workers\n */\nexport function reloadTenantConfigs(): Map<string, TenantConfig> {\n  // Clear cached configs\n  tenantConfigs = null;\n  // Reload\n  return loadTenantConfigs();\n}\n\n/**\n * Load tenant configurations from:\n * 1. Config file (TENANT_CONFIG_FILE env var or /config/tenants.json)\n * 2. TENANT_CONFIGS environment variable (JSON string)\n * 3. Individual environment variables: TENANT_<ID>_DATABASE_URL, etc.\n */\nexport function loadTenantConfigs(): Map<string, TenantConfig> {\n  if (tenantConfigs) {\n    return tenantConfigs;\n  }\n\n  tenantConfigs = new Map();\n\n  // Priority 1: Load from config file\n  const fileConfigs = loadTenantsFromFile(TENANT_CONFIG_FILE);\n  for (const [tenantId, config] of fileConfigs) {\n    tenantConfigs.set(tenantId, config);\n  }\n\n  // Priority 2: Load from TENANT_CONFIGS env var (can override file configs)\n  const configJson = process.env.TENANT_CONFIGS;\n  if (configJson) {\n    try {\n      const configs = JSON.parse(configJson) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(configs)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n        });\n      }\n      console.log(`Loaded ${Object.keys(configs).length} tenant configurations from TENANT_CONFIGS env var`);\n    } catch (error) {\n      console.error(\"Failed to parse TENANT_CONFIGS:\", error);\n    }\n  }\n\n  // Priority 3: Individual tenant environment variables\n  // Format: TENANT_<TENANT_ID>_DATABASE_URL, TENANT_<TENANT_ID>_ELASTICSEARCH_NODE\n  for (const [key, value] of Object.entries(process.env)) {\n    const match = key.match(/^TENANT_([A-Z0-9_]+)_DATABASE_URL$/);\n    if (match && value) {\n      const tenantId = match[1].toLowerCase();\n      if (!tenantConfigs.has(tenantId)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: value,\n          elasticsearchNode: process.env[`TENANT_${match[1]}_ELASTICSEARCH_NODE`],\n          elasticsearchIndex: process.env[`TENANT_${match[1]}_ELASTICSEARCH_INDEX`],\n        });\n      }\n    }\n  }\n\n  if (tenantConfigs.size === 0) {\n    console.warn(\"No tenant configurations found. Multi-tenant mode will not work without configurations.\");\n  }\n\n  return tenantConfigs;\n}\n\n/**\n * Get tenant configuration by ID\n */\nexport function getTenantConfig(tenantId: string): TenantConfig | undefined {\n  const configs = loadTenantConfigs();\n  return configs.get(tenantId);\n}\n\n/**\n * Get all tenant IDs\n */\nexport function getAllTenantIds(): string[] {\n  const configs = loadTenantConfigs();\n  return Array.from(configs.keys());\n}\n\n/**\n * Create a Prisma client for a specific tenant\n */\nfunction createTenantPrismaClient(config: TenantConfig): PrismaClient {\n  const client = new PrismaClient({\n    datasources: {\n      db: {\n        url: config.databaseUrl,\n      },\n    },\n    errorFormat: \"pretty\",\n  });\n\n  return client;\n}\n\n/**\n * Get or create a Prisma client for a specific tenant\n * Caches clients to reuse connections\n * Supports dynamic tenant addition by reloading configs if tenant not found\n */\nexport function getTenantPrismaClient(tenantId: string): PrismaClient {\n  // Check cache first\n  let client = tenantClients.get(tenantId);\n  if (client) {\n    return client;\n  }\n\n  // Get tenant config\n  let config = getTenantConfig(tenantId);\n\n  // If not found, try reloading configs (tenant may have been added dynamically)\n  if (!config) {\n    console.log(`Tenant ${tenantId} not found in cache, reloading configurations...`);\n    reloadTenantConfigs();\n    config = getTenantConfig(tenantId);\n  }\n\n  if (!config) {\n    throw new Error(`No configuration found for tenant: ${tenantId}`);\n  }\n\n  // Create and cache new client\n  client = createTenantPrismaClient(config);\n  tenantClients.set(tenantId, client);\n  console.log(`Created Prisma client for tenant: ${tenantId}`);\n\n  return client;\n}\n\n/**\n * Get a Prisma client based on job data\n * In single-tenant mode, returns the default client\n * In multi-tenant mode, returns tenant-specific client\n */\nexport function getPrismaClientForJob(jobData: { tenantId?: string }): PrismaClient {\n  if (!isMultiTenantMode()) {\n    // Single-tenant mode: use lightweight Prisma client (no ES sync extensions)\n    // Import lazily to avoid circular dependencies\n    const { prisma } = require(\"./prismaBase\");\n    return prisma;\n  }\n\n  // Multi-tenant mode: require tenantId\n  if (!jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n\n  return getTenantPrismaClient(jobData.tenantId);\n}\n\n/**\n * Disconnect all tenant clients (for graceful shutdown)\n */\nexport async function disconnectAllTenantClients(): Promise<void> {\n  const disconnectPromises: Promise<void>[] = [];\n\n  for (const [tenantId, client] of tenantClients) {\n    console.log(`Disconnecting Prisma client for tenant: ${tenantId}`);\n    disconnectPromises.push(client.$disconnect());\n  }\n\n  await Promise.all(disconnectPromises);\n  tenantClients.clear();\n  console.log(\"All tenant Prisma clients disconnected\");\n}\n\n/**\n * Base interface for job data that supports multi-tenancy\n */\nexport interface MultiTenantJobData {\n  tenantId?: string; // Optional in single-tenant mode, required in multi-tenant mode\n}\n\n/**\n * Validate job data for multi-tenant mode\n */\nexport function validateMultiTenantJobData(jobData: MultiTenantJobData): void {\n  if (isMultiTenantMode() && !jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_bullmq", "IORedis", "credentials", "crypto", "crypto", "prismaClient", "prisma", "import_client", "prisma", "prisma", "prisma"]
}
