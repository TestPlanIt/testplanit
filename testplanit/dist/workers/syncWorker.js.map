{
  "version": 3,
  "sources": ["../../workers/syncWorker.ts", "../../lib/valkey.ts", "../../lib/queueNames.ts", "../../lib/queues.ts", "../../lib/integrations/cache/IssueCache.ts", "../../lib/prisma.ts", "../../services/repositoryCaseSync.ts", "../../services/elasticsearchService.ts", "../../env.js", "../../services/elasticsearchIndexing.ts", "../../utils/extractTextFromJson.ts", "../../services/unifiedElasticsearchService.ts", "../../services/testRunSearch.ts", "../../services/sessionSearch.ts", "../../services/sharedStepSearch.ts", "../../services/issueSearch.ts", "../../services/milestoneSearch.ts", "../../services/projectSearch.ts", "../../lib/integrations/adapters/BaseAdapter.ts", "../../lib/integrations/adapters/JiraAdapter.ts", "../../lib/integrations/adapters/GitHubAdapter.ts", "../../lib/integrations/adapters/AzureDevOpsAdapter.ts", "../../lib/integrations/adapters/SimpleUrlAdapter.ts", "../../utils/encryption.ts", "../../lib/integrations/IntegrationManager.ts", "../../lib/integrations/services/SyncService.ts"],
  "sourcesContent": ["import { Worker, Job } from \"bullmq\";\nimport valkeyConnection from \"../lib/valkey\";\nimport { SYNC_QUEUE_NAME } from \"../lib/queueNames\";\nimport { syncService, SyncJobData } from \"../lib/integrations/services/SyncService\";\nimport { pathToFileURL } from \"node:url\";\n\nconst processor = async (job: Job) => {\n  console.log(`Processing sync job ${job.id} of type ${job.name}`);\n\n  const jobData = job.data as SyncJobData;\n\n  switch (job.name) {\n    case \"sync-issues\":\n      try {\n        const result = await syncService.performSync(\n          jobData.userId,\n          jobData.integrationId,\n          jobData.projectId,\n          jobData.data,\n          job // Pass job for progress reporting\n        );\n\n        if (result.errors.length > 0) {\n          console.warn(\n            `Sync completed with ${result.errors.length} errors:`,\n            result.errors\n          );\n        }\n\n        console.log(`Synced ${result.synced} issues successfully`);\n        return result;\n      } catch (error) {\n        console.error(\"Failed to sync issues:\", error);\n        throw error;\n      }\n\n    case \"sync-project-issues\":\n      try {\n        if (!jobData.projectId) {\n          throw new Error(\"Project ID is required for project sync\");\n        }\n\n        const result = await syncService.performSync(\n          jobData.userId,\n          jobData.integrationId,\n          jobData.projectId,\n          jobData.data,\n          job // Pass job for progress reporting\n        );\n\n        if (result.errors.length > 0) {\n          console.warn(\n            `Project sync completed with ${result.errors.length} errors:`,\n            result.errors\n          );\n        }\n\n        console.log(`Synced ${result.synced} issues from project successfully`);\n        return result;\n      } catch (error) {\n        console.error(\"Failed to sync project issues:\", error);\n        throw error;\n      }\n\n    case \"refresh-issue\":\n      try {\n        if (!jobData.issueId) {\n          throw new Error(\"Issue ID is required for issue refresh\");\n        }\n\n        const result = await syncService.performIssueRefresh(\n          jobData.userId,\n          jobData.integrationId,\n          jobData.issueId\n        );\n\n        if (!result.success) {\n          throw new Error(result.error || \"Failed to refresh issue\");\n        }\n\n        console.log(`Refreshed issue ${jobData.issueId} successfully`);\n        return result;\n      } catch (error) {\n        console.error(`Failed to refresh issue ${jobData.issueId}:`, error);\n        throw error;\n      }\n\n    case \"create-issue\":\n      try {\n        if (!jobData.data) {\n          throw new Error(\"Issue data is required for issue creation\");\n        }\n\n        // TODO: Implement issue creation via adapter\n        console.log(\"Issue creation not yet implemented in worker\");\n        return { success: false, error: \"Not implemented\" };\n      } catch (error) {\n        console.error(\"Failed to create issue:\", error);\n        throw error;\n      }\n\n    case \"update-issue\":\n      try {\n        if (!jobData.issueId || !jobData.data) {\n          throw new Error(\"Issue ID and data are required for issue update\");\n        }\n\n        // TODO: Implement issue update via adapter\n        console.log(\"Issue update not yet implemented in worker\");\n        return { success: false, error: \"Not implemented\" };\n      } catch (error) {\n        console.error(\"Failed to update issue:\", error);\n        throw error;\n      }\n\n    default:\n      throw new Error(`Unknown job type: ${job.name}`);\n  }\n};\n\nlet worker: Worker | null = null;\n\n// Function to start the worker\nconst startWorker = async () => {\n  if (valkeyConnection) {\n    worker = new Worker(SYNC_QUEUE_NAME, processor, {\n      connection: valkeyConnection,\n      concurrency: 1, // Process 1 sync job at a time to manage memory usage\n      lockDuration: 21600000, // 6 hours - allows for very large issue syncs\n      maxStalledCount: 1, // Reduce automatic stalled job retries\n      stalledInterval: 300000, // Check for stalled jobs every 5 minutes\n    });\n\n    worker.on(\"completed\", (job) => {\n      console.log(`Sync job ${job.id} completed successfully.`);\n    });\n\n    worker.on(\"failed\", (job, err) => {\n      console.error(`Sync job ${job?.id} failed:`, err);\n    });\n\n    worker.on(\"error\", (err) => {\n      console.error(\"Sync worker error:\", err);\n    });\n\n    console.log(`Sync worker started for queue \"${SYNC_QUEUE_NAME}\".`);\n  } else {\n    console.warn(\"Valkey connection not available. Sync worker not started.\");\n  }\n\n  // Allow graceful shutdown\n  process.on(\"SIGINT\", async () => {\n    console.log(\"Shutting down sync worker...\");\n    if (worker) {\n      await worker.close();\n    }\n    process.exit(0);\n  });\n};\n\n// Run the worker if this file is executed directly (works with both ESM and CommonJS)\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  (typeof import.meta === \"undefined\" ||\n    (import.meta as any).url === undefined)\n) {\n  console.log(\"Sync worker running...\");\n  startWorker().catch((err) => {\n    console.error(\"Failed to start sync worker:\", err);\n    process.exit(1);\n  });\n}\n\nexport default worker;\n", "import IORedis from \"ioredis\";\n\n// Check if we should skip Valkey connection (useful during build)\nconst skipConnection = process.env.SKIP_VALKEY_CONNECTION === \"true\";\n\n// Get Valkey URL from environment\nconst valkeyUrl = process.env.VALKEY_URL;\n\nif (!valkeyUrl && !skipConnection) {\n  // Log an error, but maybe don't throw immediately\n  // depending on whether Valkey is strictly required at startup\n  console.error(\n    \"VALKEY_URL environment variable is not set. Background jobs may fail.\"\n  );\n  // Optional: throw new Error('VALKEY_URL environment variable is not set.');\n}\n\n// Configure the connection options\nconst connectionOptions = {\n  maxRetriesPerRequest: null, // Required by BullMQ\n  enableReadyCheck: false, // Optional: Sometimes helps with startup race conditions\n};\n\nlet valkeyConnection: IORedis | null = null;\n\nif (valkeyUrl && !skipConnection) {\n  // Convert valkey:// to redis:// for ioredis compatibility\n  // ioredis expects redis:// protocol but we're connecting to Valkey\n  const connectionUrl = valkeyUrl.replace(/^valkey:\\/\\//, 'redis://');\n  \n  // Create and export the connection instance only if URL is provided\n  valkeyConnection = new IORedis(connectionUrl, connectionOptions);\n\n  valkeyConnection.on(\"connect\", () => {\n    console.log(\"Successfully connected to Valkey.\");\n  });\n\n  valkeyConnection.on(\"error\", (err) => {\n    console.error(\"Valkey connection error:\", err);\n  });\n} else {\n  console.warn(\"Valkey URL not provided. Valkey connection not established.\");\n}\n\nexport default valkeyConnection;", "// Queue name constants - no initialization, just names\nexport const FORECAST_QUEUE_NAME = \"forecast-updates\";\nexport const NOTIFICATION_QUEUE_NAME = \"notifications\";\nexport const EMAIL_QUEUE_NAME = \"emails\";\nexport const SYNC_QUEUE_NAME = \"issue-sync\";\nexport const TESTMO_IMPORT_QUEUE_NAME = \"testmo-imports\";\nexport const ELASTICSEARCH_REINDEX_QUEUE_NAME = \"elasticsearch-reindex\";\n", "import { Queue } from \"bullmq\";\nimport valkeyConnection from \"./valkey\";\nimport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n} from \"./queueNames\";\n\n// Re-export queue names for backward compatibility\nexport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n};\n\nlet forecastQueue: Queue | null = null;\nlet notificationQueue: Queue | null = null;\nlet emailQueue: Queue | null = null;\nlet syncQueue: Queue | null = null;\nlet testmoImportQueue: Queue | null = null;\nlet elasticsearchReindexQueue: Queue | null = null;\n\n// Initialize queue only if Valkey connection exists\nif (valkeyConnection) {\n  // Create and export the forecast queue instance\n  forecastQueue = new Queue(FORECAST_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      // Configuration for jobs in this queue (optional)\n      attempts: 3, // Number of times to retry a failed job\n      backoff: {\n        type: \"exponential\", // Exponential backoff strategy\n        delay: 5000, // Initial delay 5s\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7, // keep up to 7 days\n        count: 1000, // keep up to 1000 jobs\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14, // keep up to 14 days\n      },\n    },\n  });\n\n  console.log(`Queue \"${FORECAST_QUEUE_NAME}\" initialized.`);\n\n  // Optional: Add basic event listeners for logging/monitoring\n  forecastQueue.on(\"error\", (error) => {\n    console.error(`Queue ${FORECAST_QUEUE_NAME} error:`, error);\n  });\n} else {\n  console.warn(\n    `Valkey connection not available, Queue \"${FORECAST_QUEUE_NAME}\" not initialized.`\n  );\n}\n\n// Initialize notification queue\nif (valkeyConnection) {\n  notificationQueue = new Queue(NOTIFICATION_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7, // keep up to 7 days\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14, // keep up to 14 days\n      },\n    },\n  });\n\n  console.log(`Queue \"${NOTIFICATION_QUEUE_NAME}\" initialized.`);\n\n  notificationQueue.on(\"error\", (error) => {\n    console.error(`Queue ${NOTIFICATION_QUEUE_NAME} error:`, error);\n  });\n} else {\n  console.warn(\n    `Valkey connection not available, Queue \"${NOTIFICATION_QUEUE_NAME}\" not initialized.`\n  );\n}\n\n// Initialize email queue\nif (valkeyConnection) {\n  emailQueue = new Queue(EMAIL_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 5,\n      backoff: {\n        type: \"exponential\",\n        delay: 10000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 30, // keep up to 30 days\n        count: 5000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30, // keep up to 30 days\n      },\n    },\n  });\n\n  console.log(`Queue \"${EMAIL_QUEUE_NAME}\" initialized.`);\n\n  emailQueue.on(\"error\", (error) => {\n    console.error(`Queue ${EMAIL_QUEUE_NAME} error:`, error);\n  });\n} else {\n  console.warn(\n    `Valkey connection not available, Queue \"${EMAIL_QUEUE_NAME}\" not initialized.`\n  );\n}\n\n// Initialize sync queue\nif (valkeyConnection) {\n  syncQueue = new Queue(SYNC_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 3, // keep up to 3 days\n        count: 500,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 7, // keep up to 7 days\n      },\n    },\n  });\n\n  console.log(`Queue \"${SYNC_QUEUE_NAME}\" initialized.`);\n\n  syncQueue.on(\"error\", (error) => {\n    console.error(`Queue ${SYNC_QUEUE_NAME} error:`, error);\n  });\n} else {\n  console.warn(\n    `Valkey connection not available, Queue \"${SYNC_QUEUE_NAME}\" not initialized.`\n  );\n}\n\n// Initialize Testmo import queue\nif (valkeyConnection) {\n  testmoImportQueue = new Queue(TESTMO_IMPORT_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 100,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" initialized.`);\n\n  testmoImportQueue.on(\"error\", (error) => {\n    console.error(`Queue ${TESTMO_IMPORT_QUEUE_NAME} error:`, error);\n  });\n} else {\n  console.warn(\n    `Valkey connection not available, Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" not initialized.`\n  );\n}\n\n// Initialize Elasticsearch reindex queue\nif (valkeyConnection) {\n  elasticsearchReindexQueue = new Queue(ELASTICSEARCH_REINDEX_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1, // Don't retry reindex jobs automatically\n      removeOnComplete: {\n        age: 3600 * 24 * 7, // keep up to 7 days\n        count: 50,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14, // keep up to 14 days\n      },\n    },\n  });\n\n  console.log(`Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" initialized.`);\n\n  elasticsearchReindexQueue.on(\"error\", (error) => {\n    console.error(`Queue ${ELASTICSEARCH_REINDEX_QUEUE_NAME} error:`, error);\n  });\n} else {\n  console.warn(\n    `Valkey connection not available, Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" not initialized.`\n  );\n}\n\n// Export the potentially null queues\nexport { forecastQueue, notificationQueue, emailQueue, syncQueue, testmoImportQueue, elasticsearchReindexQueue };\n", "import { Redis } from \"ioredis\"; // ioredis client type (compatible with Valkey)\nimport valkeyConnection from \"../../valkey\"; // Valkey connection\nimport { IssueData } from \"../adapters/IssueAdapter\";\n\nexport interface CachedIssue extends IssueData {\n  cachedAt: Date;\n  integrationId: number;\n}\n\nexport class IssueCache {\n  private valkey: Redis | null; // Valkey connection instance\n  private defaultTTL: number = 3600; // 1 hour default TTL\n\n  constructor() {\n    // Use a duplicate connection to avoid conflicts with BullMQ\n    this.valkey = valkeyConnection ? valkeyConnection.duplicate() : null;\n  }\n\n  private getCacheKey(integrationId: number, externalId: string): string {\n    return `issue:${integrationId}:${externalId}`;\n  }\n\n  private getBulkCacheKey(integrationId: number, projectId?: string): string {\n    return projectId\n      ? `issues:${integrationId}:project:${projectId}`\n      : `issues:${integrationId}:all`;\n  }\n\n  private getMetadataCacheKey(integrationId: number): string {\n    return `issue-metadata:${integrationId}`;\n  }\n\n  private getProjectCacheKey(integrationId: number): string {\n    return `projects:${integrationId}`;\n  }\n\n  async get(\n    integrationId: number,\n    externalId: string\n  ): Promise<CachedIssue | null> {\n    if (!this.valkey) return null;\n\n    const key = this.getCacheKey(integrationId, externalId);\n    const cached = await this.valkey.get(key);\n\n    if (!cached) {\n      return null;\n    }\n\n    try {\n      const data = JSON.parse(cached);\n      return {\n        ...data,\n        createdAt: new Date(data.createdAt),\n        updatedAt: new Date(data.updatedAt),\n        cachedAt: new Date(data.cachedAt),\n      } as CachedIssue;\n    } catch (error) {\n      console.error(\"Failed to parse cached issue:\", error);\n      await this.valkey.del(key); // Remove corrupted cache\n      return null;\n    }\n  }\n\n  async set(\n    integrationId: number,\n    externalId: string,\n    issue: IssueData,\n    ttl?: number\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getCacheKey(integrationId, externalId);\n    const cachedIssue: CachedIssue = {\n      ...issue,\n      integrationId,\n      cachedAt: new Date(),\n    };\n    const value = JSON.stringify(cachedIssue);\n    const cacheTTL = ttl ?? this.defaultTTL;\n\n    await this.valkey.setex(key, cacheTTL, value);\n  }\n\n  async getBulk(\n    integrationId: number,\n    projectId?: string\n  ): Promise<CachedIssue[]> {\n    if (!this.valkey) return [];\n\n    const key = this.getBulkCacheKey(integrationId, projectId);\n    const cached = await this.valkey.get(key);\n\n    if (!cached) {\n      return [];\n    }\n\n    try {\n      const data = JSON.parse(cached);\n      return data.map((item: any) => ({\n        ...item,\n        createdAt: new Date(item.createdAt),\n        updatedAt: new Date(item.updatedAt),\n        cachedAt: new Date(item.cachedAt),\n      })) as CachedIssue[];\n    } catch (error) {\n      console.error(\"Failed to parse cached issues:\", error);\n      await this.valkey.del(key);\n      return [];\n    }\n  }\n\n  async setBulk(\n    integrationId: number,\n    issues: IssueData[],\n    projectId?: string,\n    ttl?: number\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getBulkCacheKey(integrationId, projectId);\n    const cachedIssues = issues.map((issue) => ({\n      ...issue,\n      integrationId,\n      cachedAt: new Date(),\n    }));\n    const value = JSON.stringify(cachedIssues);\n    const cacheTTL = ttl ?? this.defaultTTL;\n\n    await this.valkey.setex(key, cacheTTL, value);\n\n    // Also cache individual issues\n    const pipeline = this.valkey.pipeline();\n    for (const issue of issues) {\n      const issueKey = this.getCacheKey(integrationId, issue.id);\n      const cachedIssue: CachedIssue = {\n        ...issue,\n        integrationId,\n        cachedAt: new Date(),\n      };\n      pipeline.setex(issueKey, cacheTTL, JSON.stringify(cachedIssue));\n    }\n    await pipeline.exec();\n  }\n\n  async invalidate(integrationId: number, externalId?: string): Promise<void> {\n    if (!this.valkey) return;\n\n    if (externalId) {\n      // Invalidate specific issue\n      const key = this.getCacheKey(integrationId, externalId);\n      await this.valkey.del(key);\n    } else {\n      // Invalidate all issues for integration using scan for better performance\n      const stream = this.valkey.scanStream({\n        match: `issue:${integrationId}:*`,\n        count: 100,\n      });\n\n      const pipeline = this.valkey.pipeline();\n      stream.on(\"data\", (keys: string[]) => {\n        if (keys.length) {\n          keys.forEach((key) => pipeline.del(key));\n        }\n      });\n\n      stream.on(\"end\", async () => {\n        await pipeline.exec();\n      });\n\n      // Also invalidate bulk caches\n      const bulkStream = this.valkey.scanStream({\n        match: `issues:${integrationId}:*`,\n        count: 100,\n      });\n\n      const bulkPipeline = this.valkey.pipeline();\n      bulkStream.on(\"data\", (keys: string[]) => {\n        if (keys.length) {\n          keys.forEach((key) => bulkPipeline.del(key));\n        }\n      });\n\n      bulkStream.on(\"end\", async () => {\n        await bulkPipeline.exec();\n      });\n    }\n  }\n\n  async invalidateProject(\n    integrationId: number,\n    projectId: string\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getBulkCacheKey(integrationId, projectId);\n    await this.valkey.del(key);\n  }\n\n  async getMetadata(\n    integrationId: number\n  ): Promise<Record<string, any> | null> {\n    if (!this.valkey) return null;\n\n    const key = this.getMetadataCacheKey(integrationId);\n    const cached = await this.valkey.get(key);\n\n    if (!cached) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(cached);\n    } catch (error) {\n      console.error(\"Failed to parse cached metadata:\", error);\n      await this.valkey.del(key);\n      return null;\n    }\n  }\n\n  async setMetadata(\n    integrationId: number,\n    metadata: Record<string, any>,\n    ttl: number = 7200 // 2 hours for metadata\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getMetadataCacheKey(integrationId);\n    const value = JSON.stringify(metadata);\n    await this.valkey.setex(key, ttl, value);\n  }\n\n  async getProjects(\n    integrationId: number\n  ): Promise<Array<{ id: string; key: string; name: string }> | null> {\n    if (!this.valkey) return null;\n\n    const key = this.getProjectCacheKey(integrationId);\n    const cached = await this.valkey.get(key);\n\n    if (!cached) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(cached);\n    } catch (error) {\n      console.error(\"Failed to parse cached projects:\", error);\n      await this.valkey.del(key);\n      return null;\n    }\n  }\n\n  async setProjects(\n    integrationId: number,\n    projects: Array<{ id: string; key: string; name: string }>,\n    ttl: number = 86400 // 24 hours for project list\n  ): Promise<void> {\n    if (!this.valkey) return;\n\n    const key = this.getProjectCacheKey(integrationId);\n    const value = JSON.stringify(projects);\n    await this.valkey.setex(key, ttl, value);\n  }\n\n  async getCacheTTL(\n    integrationId: number,\n    externalId: string\n  ): Promise<number> {\n    if (!this.valkey) return -1;\n\n    const key = this.getCacheKey(integrationId, externalId);\n    return await this.valkey.ttl(key);\n  }\n\n  async warmCache(\n    integrationId: number,\n    fetchFn: () => Promise<IssueData[]>,\n    projectId?: string\n  ): Promise<void> {\n    try {\n      const issues = await fetchFn();\n      await this.setBulk(integrationId, issues, projectId);\n    } catch (error) {\n      console.error(\"Failed to warm cache:\", error);\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.valkey) {\n      this.valkey.disconnect();\n    }\n  }\n}\n\nexport const issueCache = new IssueCache();\n", "// app/lib/prisma.ts\nimport { PrismaClient } from \"@prisma/client\";\nimport { enhance } from \"@zenstackhq/runtime\";\nimport { syncRepositoryCaseToElasticsearch } from \"../services/repositoryCaseSync\";\nimport { syncTestRunToElasticsearch } from \"../services/testRunSearch\";\nimport { syncSessionToElasticsearch } from \"../services/sessionSearch\";\nimport { syncSharedStepToElasticsearch } from \"../services/sharedStepSearch\";\nimport { syncIssueToElasticsearch } from \"../services/issueSearch\";\nimport { syncMilestoneToElasticsearch } from \"../services/milestoneSearch\";\nimport { syncProjectToElasticsearch } from \"../services/projectSearch\";\n\n// Declare global types\ndeclare global {\n  var prisma: PrismaClient | undefined;\n  var db: any;\n}\n\n// Use different variable names to avoid redeclaration\nlet prismaClient: PrismaClient;\nlet dbClient: any;\n\n// Helper function to create and configure PrismaClient with Elasticsearch sync\nfunction createPrismaClient(errorFormat: \"pretty\" | \"colorless\") {\n  const baseClient = new PrismaClient({ errorFormat });\n  \n  // Add Elasticsearch sync using client extensions\n  const client = baseClient.$extends({\n    query: {\n      repositoryCases: {\n        async create({ args, query }: any) {\n          const result = await query(args);\n          // Sync to Elasticsearch asynchronously\n          if (result?.id) {\n            syncRepositoryCaseToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync repository case ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async update({ args, query }: any) {\n          const result = await query(args);\n          // Sync to Elasticsearch asynchronously\n          if (result?.id) {\n            syncRepositoryCaseToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync repository case ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async upsert({ args, query }: any) {\n          const result = await query(args);\n          // Sync to Elasticsearch asynchronously\n          if (result?.id) {\n            syncRepositoryCaseToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync repository case ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async delete({ args, query }: any) {\n          const result = await query(args);\n          // Sync to Elasticsearch asynchronously (will handle removal if needed)\n          if (result?.id) {\n            syncRepositoryCaseToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync repository case ${result.id} to Elasticsearch after delete:`, error);\n            });\n          }\n          return result;\n        },\n      },\n      testRuns: {\n        async create({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncTestRunToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync test run ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async update({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncTestRunToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync test run ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n      },\n      sessions: {\n        async create({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncSessionToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync session ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async update({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncSessionToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync session ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async upsert({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncSessionToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync session ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async delete({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncSessionToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync session ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n      },\n      sharedStepGroups: {\n        async create({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncSharedStepToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync shared step ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async update({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncSharedStepToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync shared step ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n      },\n      issues: {\n        async create({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncIssueToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync issue ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async update({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncIssueToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync issue ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n      },\n      milestones: {\n        async create({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncMilestoneToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync milestone ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async update({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncMilestoneToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync milestone ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n      },\n      projects: {\n        async create({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncProjectToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync project ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n        async update({ args, query }: any) {\n          const result = await query(args);\n          if (result?.id) {\n            syncProjectToElasticsearch(result.id).catch((error: any) => {\n              console.error(`Failed to sync project ${result.id} to Elasticsearch:`, error);\n            });\n          }\n          return result;\n        },\n      },\n    } as any,\n  });\n  \n  return client as unknown as PrismaClient;\n}\n\n// Check if we're in a production environment or not.\n// In development, Next.js might hot-reload and create new instances, so we prevent that.\nif (process.env.NODE_ENV === \"production\") {\n  prismaClient = createPrismaClient(\"pretty\");\n  dbClient = enhance(prismaClient);\n} else {\n  // Check if there's already a global instance of PrismaClient\n  if (!global.prisma) {\n    global.prisma = createPrismaClient(\"colorless\");\n    global.db = enhance(global.prisma);\n  }\n  prismaClient = global.prisma;\n  dbClient = global.db;\n}\n\nexport const prisma = prismaClient;\nexport const db = dbClient;\n", "import { PrismaClient } from \"@prisma/client\";\nimport {\n  createRepositoryCaseIndex,\n  RepositoryCaseDocument,\n} from \"./elasticsearchService\";\nimport {\n  indexRepositoryCase,\n  deleteRepositoryCase,\n  bulkIndexRepositoryCases,\n} from \"./elasticsearchIndexing\";\nimport { extractTextFromNode } from \"../utils/extractTextFromJson\";\nimport { buildCustomFieldDocuments } from \"./unifiedElasticsearchService\";\n\nconst prisma = new PrismaClient();\n\n/**\n * Safely extract text from a step field that might be JSON string or object\n */\nfunction extractStepText(stepData: any): string {\n  if (!stepData) return \"\";\n\n  try {\n    // If it's a string, try to parse it as JSON\n    if (typeof stepData === \"string\") {\n      const parsed = JSON.parse(stepData);\n      return extractTextFromNode(parsed);\n    }\n    // Otherwise, assume it's already an object\n    return extractTextFromNode(stepData);\n  } catch (error) {\n    // If parsing fails, return the original string\n    return typeof stepData === \"string\" ? stepData : \"\";\n  }\n}\n\n/**\n * Build a repository case document for Elasticsearch from Prisma data\n */\nexport async function buildRepositoryCaseDocument(\n  caseId: number\n): Promise<RepositoryCaseDocument | null> {\n  const repoCase = await prisma.repositoryCases.findUnique({\n    where: { id: caseId },\n    include: {\n      project: true,\n      folder: true,\n      template: true,\n      state: {\n        include: {\n          icon: true,\n          color: true,\n        },\n      },\n      creator: true,\n      tags: true,\n      steps: {\n        orderBy: { order: \"asc\" },\n        include: {\n          sharedStepGroup: {\n            include: {\n              items: {\n                orderBy: { order: \"asc\" },\n              },\n            },\n          },\n        },\n      },\n      caseFieldValues: {\n        include: {\n          field: {\n            include: {\n              type: true,\n              fieldOptions: {\n                include: {\n                  fieldOption: {\n                    include: {\n                      icon: true,\n                      iconColor: true,\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (!repoCase) return null;\n\n  // Build folder path\n  const folderPath = await buildFolderPath(repoCase.folderId);\n\n  return {\n    id: repoCase.id,\n    projectId: repoCase.projectId,\n    projectName: repoCase.project.name,\n    projectIconUrl: repoCase.project.iconUrl,\n    repositoryId: repoCase.repositoryId,\n    folderId: repoCase.folderId,\n    folderPath,\n    templateId: repoCase.templateId,\n    templateName: repoCase.template.templateName,\n    name: repoCase.name,\n    className: repoCase.className,\n    source: repoCase.source,\n    stateId: repoCase.stateId,\n    stateName: repoCase.state.name,\n    stateIcon: repoCase.state.icon.name,\n    stateColor: repoCase.state.color.value,\n    estimate: repoCase.estimate,\n    forecastManual: repoCase.forecastManual,\n    forecastAutomated: repoCase.forecastAutomated,\n    automated: repoCase.automated,\n    isArchived: repoCase.isArchived,\n    isDeleted: repoCase.isDeleted,\n    createdAt: repoCase.createdAt,\n    creatorId: repoCase.creatorId,\n    creatorName: repoCase.creator.name,\n    creatorImage: repoCase.creator.image,\n    tags: repoCase.tags.map((tag) => ({\n      id: tag.id,\n      name: tag.name,\n    })),\n    customFields: buildCustomFieldDocuments(\n      repoCase.caseFieldValues.map((cfv) => ({\n        fieldId: cfv.fieldId,\n        field: {\n          displayName: cfv.field.displayName,\n          systemName: cfv.field.systemName,\n          type: cfv.field.type ? { type: cfv.field.type.type } : undefined,\n          fieldOptions: cfv.field.fieldOptions?.map((fo) => ({\n            fieldOption: {\n              id: fo.fieldOption.id,\n              name: fo.fieldOption.name,\n              icon: fo.fieldOption.icon\n                ? { name: fo.fieldOption.icon.name }\n                : undefined,\n              iconColor: fo.fieldOption.iconColor\n                ? { value: fo.fieldOption.iconColor.value }\n                : undefined,\n            },\n          })),\n        },\n        value: cfv.value,\n      }))\n    )\n      .filter(\n        (cf) => cf.value !== null && cf.value !== undefined && cf.value !== \"\"\n      )\n      .map((cf) => ({\n        fieldId: cf.fieldId,\n        fieldName: cf.fieldName,\n        fieldType: cf.fieldType,\n        value: cf.value || \"\", // Ensure value is always present\n      })),\n    steps: repoCase.steps.flatMap((step): any[] => {\n      // If this is a shared step, expand all items from the group\n      if (step.sharedStepGroupId && step.sharedStepGroup) {\n        return step.sharedStepGroup.items.map((item, index) => ({\n          id: step.id * 1000 + index, // Generate unique ID for each shared step item\n          order: step.order,\n          step: extractStepText(item.step),\n          expectedResult: extractStepText(item.expectedResult),\n          isSharedStep: true,\n          sharedStepGroupId: step.sharedStepGroupId,\n          sharedStepGroupName: step.sharedStepGroup?.name,\n        }));\n      }\n      // Regular step\n      return [\n        {\n          id: step.id,\n          order: step.order,\n          step: extractStepText(step.step),\n          expectedResult: extractStepText(step.expectedResult),\n          isSharedStep: false,\n          sharedStepGroupId: undefined,\n          sharedStepGroupName: undefined,\n        },\n      ];\n    }),\n  };\n}\n\n/**\n * Build the full folder path for a folder\n */\nasync function buildFolderPath(folderId: number): Promise<string> {\n  const folder = await prisma.repositoryFolders.findUnique({\n    where: { id: folderId },\n    include: { parent: true },\n  });\n\n  if (!folder) return \"/\";\n\n  const path = [folder.name];\n  let current: any = folder;\n\n  while (current.parent) {\n    path.unshift(current.parent.name);\n    const nextParent = await prisma.repositoryFolders.findUnique({\n      where: { id: current.parent.id },\n      include: { parent: true },\n    });\n    if (!nextParent) break;\n    current = nextParent;\n  }\n\n  return \"/\" + path.join(\"/\");\n}\n\n/**\n * Sync a repository case to Elasticsearch after create/update\n */\nexport async function syncRepositoryCaseToElasticsearch(\n  caseId: number\n): Promise<boolean> {\n  const doc = await buildRepositoryCaseDocument(caseId);\n  if (!doc) {\n    // Case no longer exists (hard deleted) - remove from Elasticsearch\n    await deleteRepositoryCase(caseId);\n    return true;\n  }\n\n  // Index all cases including deleted ones (they'll be filtered in search based on admin permissions)\n  // Only exclude archived cases as they're typically not meant to be searchable\n  if (doc.isArchived) {\n    await deleteRepositoryCase(caseId);\n    return true;\n  }\n\n  return await indexRepositoryCase(doc);\n}\n\n/**\n * Sync all repository cases for a project to Elasticsearch\n */\nexport async function syncProjectCasesToElasticsearch(\n  projectId: number,\n  batchSize: number = 100,\n  progressCallback?: (processed: number, total: number, message: string) => void | Promise<void>\n): Promise<boolean> {\n  try {\n    // Ensure index exists\n    await createRepositoryCaseIndex();\n\n    const totalCases = await prisma.repositoryCases.count({\n      where: {\n        projectId,\n        isArchived: false, // Only exclude archived, include deleted items\n      },\n    });\n\n    const message = `Syncing ${totalCases} cases for project ${projectId}...`;\n    console.log(message);\n    if (progressCallback) {\n      await progressCallback(0, totalCases, message);\n    }\n\n    let processed = 0;\n    let hasMore = true;\n\n    while (hasMore) {\n      const cases = await prisma.repositoryCases.findMany({\n        where: {\n          projectId,\n          isArchived: false, // Only exclude archived, include deleted items\n        },\n        skip: processed,\n        take: batchSize,\n        orderBy: { id: \"asc\" },\n      });\n\n      if (cases.length === 0) {\n        hasMore = false;\n        break;\n      }\n\n      // Build documents for this batch\n      const documents: RepositoryCaseDocument[] = [];\n\n      for (const caseItem of cases) {\n        const doc = await buildRepositoryCaseDocument(caseItem.id);\n        if (doc) {\n          documents.push(doc);\n        }\n      }\n\n      // Bulk index this batch\n      if (documents.length > 0) {\n        const success = await bulkIndexRepositoryCases(documents);\n        if (!success) {\n          console.error(`Failed to index batch starting at ${processed}`);\n          return false;\n        }\n      }\n\n      processed += cases.length;\n      const progressMessage = `Indexed ${processed}/${totalCases} cases...`;\n      console.log(progressMessage);\n      if (progressCallback) {\n        await progressCallback(processed, totalCases, progressMessage);\n      }\n    }\n\n    const finalMessage = `Successfully synced ${processed} cases to Elasticsearch`;\n    console.log(finalMessage);\n    if (progressCallback) {\n      await progressCallback(processed, totalCases, finalMessage);\n    }\n    return true;\n  } catch (error) {\n    console.error(\"Error syncing project cases to Elasticsearch:\", error);\n    return false;\n  }\n}\n\n/**\n * Initialize Elasticsearch indexes on application startup\n */\nexport async function initializeElasticsearchIndexes(): Promise<void> {\n  try {\n    const created = await createRepositoryCaseIndex();\n    if (created) {\n      console.log(\"Elasticsearch indexes initialized successfully\");\n    }\n  } catch (error) {\n    console.error(\"Failed to initialize Elasticsearch indexes:\", error);\n  }\n}\n", "import { Client } from \"@elastic/elasticsearch\";\nimport { env } from \"../env.js\";\n\n// Create singleton instance\nlet esClient: Client | null = null;\n\n/**\n * Get or create Elasticsearch client instance\n */\nexport function getElasticsearchClient(): Client | null {\n  if (!env.ELASTICSEARCH_NODE) {\n    console.warn(\n      \"ELASTICSEARCH_NODE environment variable not set. Elasticsearch integration disabled.\"\n    );\n    return null;\n  }\n\n  if (!esClient) {\n    try {\n      esClient = new Client({\n        node: env.ELASTICSEARCH_NODE,\n        // Add additional configuration as needed\n        maxRetries: 3,\n        requestTimeout: 30000,\n        sniffOnStart: false, // Disable sniffing for custom ports\n      });\n\n    } catch (error) {\n      console.error(\"Failed to initialize Elasticsearch client:\", error);\n      return null;\n    }\n  }\n\n  return esClient;\n}\n\n/**\n * Test Elasticsearch connection\n */\nexport async function testElasticsearchConnection(): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  try {\n    const response = await client.ping();\n    return true;\n  } catch (error) {\n    console.error(\"Elasticsearch connection failed:\", error);\n    return false;\n  }\n}\n\n/**\n * Repository Case index configuration\n */\nexport const REPOSITORY_CASE_INDEX = \"testplanit-repository-cases\";\n\n/**\n * Repository Case mapping for Elasticsearch\n */\nexport const repositoryCaseMapping = {\n  properties: {\n    id: { type: \"integer\" as const },\n    projectId: { type: \"integer\" as const },\n    projectName: { type: \"keyword\" as const },\n    projectIconUrl: { type: \"keyword\" as const },\n    repositoryId: { type: \"integer\" as const },\n    folderId: { type: \"integer\" as const },\n    folderPath: { type: \"keyword\" as const },\n    templateId: { type: \"integer\" as const },\n    templateName: { type: \"keyword\" as const },\n    name: {\n      type: \"text\" as const,\n      analyzer: \"standard\",\n      fields: {\n        keyword: { type: \"keyword\" as const },\n        suggest: { type: \"completion\" as const },\n      },\n    },\n    className: { type: \"keyword\" as const },\n    source: { type: \"keyword\" as const },\n    stateId: { type: \"integer\" as const },\n    stateName: { type: \"keyword\" as const },\n    stateIcon: { type: \"keyword\" as const },\n    stateColor: { type: \"keyword\" as const },\n    estimate: { type: \"integer\" as const },\n    forecastManual: { type: \"integer\" as const },\n    forecastAutomated: { type: \"float\" as const },\n    automated: { type: \"boolean\" as const },\n    isArchived: { type: \"boolean\" as const },\n    isDeleted: { type: \"boolean\" as const },\n    createdAt: { type: \"date\" as const },\n    creatorId: { type: \"keyword\" as const },\n    creatorName: { type: \"text\" as const },\n    tags: {\n      type: \"nested\" as const,\n      properties: {\n        id: { type: \"integer\" as const },\n        name: { type: \"keyword\" as const },\n      },\n    },\n    customFields: {\n      type: \"nested\" as const,\n      properties: {\n        fieldId: { type: \"integer\" as const },\n        fieldName: { type: \"keyword\" as const },\n        fieldType: { type: \"keyword\" as const },\n        value: { type: \"text\" as const },\n      },\n    },\n    steps: {\n      type: \"nested\" as const,\n      properties: {\n        id: { type: \"integer\" as const },\n        order: { type: \"integer\" as const },\n        step: { type: \"text\" as const },\n        expectedResult: { type: \"text\" as const },\n        isSharedStep: { type: \"boolean\" as const },\n        sharedStepGroupId: { type: \"integer\" as const },\n        sharedStepGroupName: { type: \"text\" as const },\n      },\n    },\n    // Full-text search field combining multiple fields\n    searchableContent: { type: \"text\" as const },\n  },\n};\n\n/**\n * Get Elasticsearch replica settings from database\n */\nasync function getElasticsearchSettings() {\n  try {\n    const { PrismaClient } = await import(\"@prisma/client\");\n    const prisma = new PrismaClient();\n    \n    const config = await prisma.appConfig.findUnique({\n      where: { key: \"elasticsearch_replicas\" }\n    });\n    \n    await prisma.$disconnect();\n    \n    // Default to 0 for single-node clusters\n    return {\n      numberOfReplicas: config?.value ? (config.value as number) : 0\n    };\n  } catch (error) {\n    console.warn(\"Failed to get Elasticsearch settings from database, using defaults:\", error);\n    return { numberOfReplicas: 0 };\n  }\n}\n\n/**\n * Create or update the repository cases index\n */\nexport async function createRepositoryCaseIndex(): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  try {\n    // Get settings from database\n    const settings = await getElasticsearchSettings();\n    \n    // Check if index exists\n    const exists = await client.indices.exists({\n      index: REPOSITORY_CASE_INDEX,\n    });\n\n    if (!exists) {\n      // Create index with mapping\n      await client.indices.create({\n        index: REPOSITORY_CASE_INDEX,\n        settings: {\n          number_of_shards: 1,\n          number_of_replicas: settings.numberOfReplicas,\n          analysis: {\n            analyzer: {\n              standard: {\n                type: \"standard\",\n                stopwords: \"_english_\",\n              },\n            },\n          },\n        },\n        mappings: repositoryCaseMapping,\n      });\n    } else {\n      // Index already exists, skip update to avoid field type conflicts\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Failed to create/update Elasticsearch index:\", error);\n    return false;\n  }\n}\n\n/**\n * Interface for indexing repository case data\n */\nexport interface RepositoryCaseDocument {\n  id: number;\n  projectId: number;\n  projectName: string;\n  projectIconUrl?: string | null;\n  repositoryId: number;\n  folderId: number;\n  folderPath: string;\n  templateId: number;\n  templateName: string;\n  name: string;\n  className?: string | null;\n  source: string;\n  stateId: number;\n  stateName: string;\n  stateIcon?: string;\n  stateColor?: string;\n  estimate?: number | null;\n  forecastManual?: number | null;\n  forecastAutomated?: number | null;\n  automated: boolean;\n  isArchived: boolean;\n  isDeleted: boolean;\n  createdAt: Date;\n  creatorId: string;\n  creatorName: string;\n  creatorImage?: string | null;\n  tags?: Array<{ id: number; name: string }>;\n  customFields?: Array<{\n    fieldId: number;\n    fieldName: string;\n    fieldType: string;\n    value: any;\n  }>;\n  steps?: Array<{\n    id: number;\n    order: number;\n    step: string;\n    expectedResult: string;\n    isSharedStep?: boolean;\n    sharedStepGroupId?: number;\n    sharedStepGroupName?: string;\n  }>;\n  searchableContent?: string;\n}\n", "import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod/v4\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z\n      .string()\n      .refine(\n        (str) => !str.includes(\"YOUR_MYSQL_URL_HERE\"),\n        \"You forgot to change the default URL\",\n      ),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .prefault(\"development\"),\n    NEXTAUTH_SECRET:\n      process.env.NODE_ENV === \"production\"\n        ? z.string()\n        : z.string().optional(),\n    NEXTAUTH_URL: z.preprocess(\n      // This makes Vercel deployments not fail if you don't set NEXTAUTH_URL\n      // Since NextAuth.js automatically uses the VERCEL_URL if present.\n      (str) => process.env.VERCEL_URL ?? str,\n      // VERCEL_URL doesn't include `https` so it cant be validated as a URL\n      process.env.VERCEL ? z.string() : z.url(),\n    ),\n    ELASTICSEARCH_NODE: z.url().optional(),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,\n    NEXTAUTH_URL: process.env.NEXTAUTH_URL,\n    ELASTICSEARCH_NODE: process.env.ELASTICSEARCH_NODE,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n", "import {\n  getElasticsearchClient,\n  REPOSITORY_CASE_INDEX,\n  RepositoryCaseDocument,\n} from \"./elasticsearchService\";\n\n/**\n * Index a repository case in Elasticsearch\n */\nexport async function indexRepositoryCase(\n  caseData: RepositoryCaseDocument\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  try {\n    // Build searchable content from various fields\n    const searchableContent = [\n      caseData.name,\n      caseData.className,\n      caseData.tags?.map((t) => t.name).join(\" \"),\n      caseData.steps?.map((s) => {\n        const stepContent = `${s.step} ${s.expectedResult}`;\n        // Include shared step group name if it's a shared step\n        return s.isSharedStep && s.sharedStepGroupName \n          ? `${stepContent} ${s.sharedStepGroupName}`\n          : stepContent;\n      }).join(\" \"),\n      caseData.customFields?.map((cf) => cf.value).join(\" \"),\n    ]\n      .filter(Boolean)\n      .join(\" \");\n\n    await client.index({\n      index: REPOSITORY_CASE_INDEX,\n      id: caseData.id.toString(),\n      document: {\n        ...caseData,\n        searchableContent,\n      },\n    });\n\n    console.log(`Indexed repository case ${caseData.id} in Elasticsearch`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to index repository case ${caseData.id}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index repository cases\n */\nexport async function bulkIndexRepositoryCases(\n  cases: RepositoryCaseDocument[]\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client || cases.length === 0) return false;\n\n  try {\n    const operations = cases.flatMap((caseData) => {\n      // Build searchable content\n      const searchableContent = [\n        caseData.name,\n        caseData.className,\n        caseData.tags?.map((t) => t.name).join(\" \"),\n        caseData.steps?.map((s) => {\n          const stepContent = `${s.step} ${s.expectedResult}`;\n          // Include shared step group name if it's a shared step\n          return s.isSharedStep && s.sharedStepGroupName \n            ? `${stepContent} ${s.sharedStepGroupName}`\n            : stepContent;\n        }).join(\" \"),\n        caseData.customFields?.map((cf) => cf.value).join(\" \"),\n      ]\n        .filter(Boolean)\n        .join(\" \");\n\n      return [\n        {\n          index: { _index: REPOSITORY_CASE_INDEX, _id: caseData.id.toString() },\n        },\n        { ...caseData, searchableContent },\n      ];\n    });\n\n    const bulkResponse = await client.bulk({\n      operations,\n      refresh: true,\n    });\n\n    if (bulkResponse.errors) {\n      const errorItems = bulkResponse.items.filter((item) => item.index?.error);\n      console.error(\"Bulk indexing errors:\", errorItems);\n      // Log detailed error information\n      errorItems.forEach((item) => {\n        if (item.index?.error) {\n          console.error(`Failed to index document ${item.index._id}:`);\n          console.error(`  Error type: ${item.index.error.type}`);\n          console.error(`  Error reason: ${item.index.error.reason}`);\n        }\n      });\n      return false;\n    }\n\n    console.log(\n      `Bulk indexed ${cases.length} repository cases in Elasticsearch`\n    );\n    return true;\n  } catch (error) {\n    console.error(\"Failed to bulk index repository cases:\", error);\n    return false;\n  }\n}\n\n/**\n * Delete a repository case from Elasticsearch\n */\nexport async function deleteRepositoryCase(caseId: number): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  try {\n    await client.delete({\n      index: REPOSITORY_CASE_INDEX,\n      id: caseId.toString(),\n    });\n\n    console.log(`Deleted repository case ${caseId} from Elasticsearch`);\n    return true;\n  } catch (error) {\n    // 404 is expected if document doesn't exist\n    if ((error as any).statusCode === 404) {\n      console.log(\n        `Repository case ${caseId} not found in Elasticsearch (already deleted)`\n      );\n      return true;\n    }\n    console.error(`Failed to delete repository case ${caseId}:`, error);\n    return false;\n  }\n}\n", "/**\n * Recursively extracts text content from a JSON node structure\n * (commonly used in Tiptap/ProseMirror).\n */\nexport const extractTextFromNode = (node: any): string => {\n  if (!node) return \"\";\n\n  // If the node itself is just a string, return it\n  if (typeof node === \"string\") return node;\n\n  // If the node has a direct text property, return it\n  if (node.text && typeof node.text === \"string\") return node.text;\n\n  // If the node has a content array, recursively process each item\n  if (node.content && Array.isArray(node.content)) {\n    return node.content.map(extractTextFromNode).join(\"\"); // Join without spaces for raw text\n  }\n\n  // Return empty string if no text found or structure is unexpected\n  return \"\";\n};\n", "import { Client } from \"@elastic/elasticsearch\";\nimport { SearchableEntityType, CustomFieldDocument } from \"~/types/search\";\nimport { getElasticsearchClient } from \"./elasticsearchService\";\n\n// Re-export for convenience\nexport { getElasticsearchClient };\n\n// Index names for each entity type\nexport const ENTITY_INDICES = {\n  [SearchableEntityType.REPOSITORY_CASE]: \"testplanit-repository-cases\",\n  [SearchableEntityType.SHARED_STEP]: \"testplanit-shared-steps\",\n  [SearchableEntityType.TEST_RUN]: \"testplanit-test-runs\",\n  [SearchableEntityType.SESSION]: \"testplanit-sessions\",\n  [SearchableEntityType.PROJECT]: \"testplanit-projects\",\n  [SearchableEntityType.ISSUE]: \"testplanit-issues\",\n  [SearchableEntityType.MILESTONE]: \"testplanit-milestones\",\n} as const;\n\n// Base mapping for all entities\nconst baseMapping = {\n  properties: {\n    id: { type: \"integer\" as const },\n    projectId: { type: \"integer\" as const },\n    projectName: { type: \"keyword\" as const },\n    projectIconUrl: { type: \"keyword\" as const },\n    createdAt: { type: \"date\" as const },\n    updatedAt: { type: \"date\" as const },\n    createdById: { type: \"keyword\" as const },\n    createdByName: { type: \"keyword\" as const },\n    createdByImage: { type: \"keyword\" as const },\n    searchableContent: {\n      type: \"text\" as const,\n      analyzer: \"standard\",\n      fields: {\n        keyword: {\n          type: \"keyword\" as const,\n          ignore_above: 256,\n        },\n      },\n    },\n    customFields: {\n      type: \"nested\" as const,\n      properties: {\n        fieldId: { type: \"integer\" as const },\n        fieldName: { type: \"keyword\" as const },\n        fieldType: { type: \"keyword\" as const },\n        value: { type: \"text\" as const },\n        valueKeyword: { type: \"keyword\" as const },\n        valueNumeric: { type: \"double\" as const },\n        valueBoolean: { type: \"boolean\" as const },\n        valueDate: { type: \"date\" as const },\n        valueArray: { type: \"keyword\" as const },\n        fieldOption: {\n          type: \"object\" as const,\n          properties: {\n            id: { type: \"integer\" as const },\n            name: { type: \"keyword\" as const },\n            icon: {\n              type: \"object\" as const,\n              properties: {\n                name: { type: \"keyword\" as const },\n              },\n            },\n            iconColor: {\n              type: \"object\" as const,\n              properties: {\n                value: { type: \"keyword\" as const },\n              },\n            },\n          },\n        },\n        fieldOptions: {\n          type: \"nested\" as const,\n          properties: {\n            id: { type: \"integer\" as const },\n            name: { type: \"keyword\" as const },\n            icon: {\n              type: \"object\" as const,\n              properties: {\n                name: { type: \"keyword\" as const },\n              },\n            },\n            iconColor: {\n              type: \"object\" as const,\n              properties: {\n                value: { type: \"keyword\" as const },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n};\n\n// Entity-specific mappings\nexport const ENTITY_MAPPINGS = {\n  [SearchableEntityType.REPOSITORY_CASE]: {\n    properties: {\n      ...baseMapping.properties,\n      repositoryId: { type: \"integer\" as const },\n      folderId: { type: \"integer\" as const },\n      folderPath: { type: \"keyword\" as const },\n      templateId: { type: \"integer\" as const },\n      templateName: { type: \"keyword\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      className: { type: \"keyword\" as const },\n      source: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      estimate: { type: \"integer\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      automated: { type: \"boolean\" as const },\n      isArchived: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n      steps: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          order: { type: \"integer\" as const },\n          step: { type: \"text\" as const },\n          expectedResult: { type: \"text\" as const },\n          isSharedStep: { type: \"boolean\" as const },\n          sharedStepGroupId: { type: \"integer\" as const },\n          sharedStepGroupName: { type: \"text\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.SHARED_STEP]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      isDeleted: { type: \"boolean\" as const },\n      items: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          order: { type: \"integer\" as const },\n          step: { type: \"text\" as const },\n          expectedResult: { type: \"text\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.TEST_RUN]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      configId: { type: \"integer\" as const },\n      configurationName: { type: \"keyword\" as const },\n      milestoneId: { type: \"integer\" as const },\n      milestoneName: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      elapsed: { type: \"integer\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      testRunType: { type: \"keyword\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.SESSION]: {\n    properties: {\n      ...baseMapping.properties,\n      templateId: { type: \"integer\" as const },\n      templateName: { type: \"keyword\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      mission: { type: \"text\" as const },\n      configId: { type: \"integer\" as const },\n      configurationName: { type: \"keyword\" as const },\n      milestoneId: { type: \"integer\" as const },\n      milestoneName: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      assignedToId: { type: \"keyword\" as const },\n      assignedToName: { type: \"keyword\" as const },\n      assignedToImage: { type: \"keyword\" as const },\n      estimate: { type: \"integer\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      elapsed: { type: \"integer\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.PROJECT]: {\n    properties: {\n      id: { type: \"integer\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      iconUrl: { type: \"keyword\" as const },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      createdAt: { type: \"date\" as const },\n      createdById: { type: \"keyword\" as const },\n      createdByName: { type: \"keyword\" as const },\n      createdByImage: { type: \"keyword\" as const },\n      searchableContent: { type: \"text\" as const },\n    },\n  },\n  [SearchableEntityType.ISSUE]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      title: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      description: { type: \"text\" as const },\n      externalId: { type: \"keyword\" as const },\n      note: { type: \"text\" as const },\n      url: { type: \"keyword\" as const },\n      issueSystem: { type: \"text\" as const },\n      isDeleted: { type: \"boolean\" as const },\n    },\n  },\n  [SearchableEntityType.MILESTONE]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      milestoneTypeId: { type: \"integer\" as const },\n      milestoneTypeName: { type: \"keyword\" as const },\n      milestoneTypeIcon: { type: \"keyword\" as const },\n      parentId: { type: \"integer\" as const },\n      parentName: { type: \"keyword\" as const },\n      dueDate: { type: \"date\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      isDeleted: { type: \"boolean\" as const },\n    },\n  },\n};\n\n/**\n * Get Elasticsearch replica settings from database\n */\nasync function getElasticsearchSettings() {\n  try {\n    const { PrismaClient } = await import(\"@prisma/client\");\n    const prisma = new PrismaClient();\n    \n    const config = await prisma.appConfig.findUnique({\n      where: { key: \"elasticsearch_replicas\" }\n    });\n    \n    await prisma.$disconnect();\n    \n    // Default to 0 for single-node clusters\n    return {\n      numberOfReplicas: config?.value ? (config.value as number) : 0\n    };\n  } catch (error) {\n    console.warn(\"Failed to get Elasticsearch settings from database, using defaults:\", error);\n    return { numberOfReplicas: 0 };\n  }\n}\n\n/**\n * Create index for a specific entity type\n */\nexport async function createEntityIndex(\n  entityType: SearchableEntityType\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = ENTITY_INDICES[entityType];\n  const mapping = ENTITY_MAPPINGS[entityType];\n\n  try {\n    // Get settings from database\n    const settings = await getElasticsearchSettings();\n    \n    const indexExists = await client.indices.exists({ index: indexName });\n\n    if (!indexExists) {\n      await client.indices.create({\n        index: indexName,\n        mappings: mapping,\n        settings: {\n          number_of_shards: 1,\n          number_of_replicas: settings.numberOfReplicas,\n          analysis: {\n            analyzer: {\n              standard: {\n                type: \"standard\",\n                stopwords: \"_english_\",\n              },\n            },\n          },\n        },\n      });\n\n      return true;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Failed to create index for ${entityType}:`, error);\n    return false;\n  }\n}\n\n/**\n * Create all entity indices\n */\nexport async function createAllEntityIndices(): Promise<void> {\n  const entityTypes = Object.values(SearchableEntityType);\n\n  for (const entityType of entityTypes) {\n    await createEntityIndex(entityType);\n  }\n}\n\n/**\n * Transform custom field values based on field type\n */\nexport function transformCustomFieldValue(\n  fieldType: string,\n  value: any\n): Partial<CustomFieldDocument> {\n  const base: Partial<CustomFieldDocument> = {};\n\n  switch (fieldType) {\n    case \"Checkbox\":\n      base.valueBoolean = Boolean(value);\n      base.value = String(value);\n      break;\n\n    case \"Date\":\n      if (value) {\n        const date = new Date(value);\n        if (!isNaN(date.getTime())) {\n          base.valueDate = date.toISOString();\n          base.value = date.toISOString();\n        }\n      }\n      break;\n\n    case \"Number\":\n      base.valueNumeric = Number(value);\n      base.value = String(value);\n      break;\n\n    case \"Multi-Select\":\n      if (Array.isArray(value)) {\n        base.valueArray = value.map((v) => String(v));\n        base.value = value.join(\" \");\n      } else if (value) {\n        // Handle case where value might be a JSON string\n        try {\n          const parsed = JSON.parse(value);\n          if (Array.isArray(parsed)) {\n            base.valueArray = parsed.map((v) => String(v));\n            base.value = parsed.join(\" \");\n          }\n        } catch {\n          base.value = String(value);\n        }\n      }\n      break;\n\n    case \"Select\":\n      base.valueKeyword = String(value);\n      base.value = String(value);\n      break;\n\n    case \"Text String\":\n    case \"Link\":\n      base.valueKeyword = String(value);\n      base.value = String(value);\n      break;\n\n    case \"Text Long\":\n      // Extract text from TipTap JSON\n      if (value) {\n        try {\n          const content = typeof value === \"string\" ? JSON.parse(value) : value;\n          const textContent = extractTextFromTipTap(content);\n          base.value = textContent;\n        } catch {\n          base.value = String(value);\n        }\n      }\n      break;\n\n    case \"Steps\":\n      // Steps are handled separately in the steps array\n      if (value) {\n        base.value = String(value);\n      }\n      break;\n\n    default:\n      base.value = String(value);\n  }\n\n  return base;\n}\n\n/**\n * Extract plain text from TipTap JSON content\n */\nfunction extractTextFromTipTap(content: any): string {\n  if (!content || !content.content) return \"\";\n\n  let text = \"\";\n\n  function extractFromNode(node: any) {\n    if (node.text) {\n      text += node.text + \" \";\n    }\n    if (node.content) {\n      node.content.forEach(extractFromNode);\n    }\n  }\n\n  content.content.forEach(extractFromNode);\n  return text.trim();\n}\n\n/**\n * Build custom field documents for indexing\n */\nexport function buildCustomFieldDocuments(\n  fieldValues: Array<{\n    fieldId: number;\n    field: {\n      displayName: string;\n      systemName: string;\n      type?: { type: string };\n      fieldOptions?: Array<{\n        fieldOption: {\n          id: number;\n          name: string;\n          icon?: { name: string };\n          iconColor?: { value: string };\n        };\n      }>;\n    };\n    value: any;\n  }>\n): CustomFieldDocument[] {\n  return fieldValues.map((cfv) => {\n    const fieldType = cfv.field.type?.type || cfv.field.systemName;\n    const transformed = transformCustomFieldValue(fieldType, cfv.value);\n\n    const doc: CustomFieldDocument = {\n      fieldId: cfv.fieldId,\n      fieldName: cfv.field.displayName,\n      fieldType: fieldType,\n      ...transformed,\n    };\n\n    // For single select/dropdown fields, find the selected option\n    if (\n      cfv.value &&\n      cfv.field.fieldOptions &&\n      (fieldType === \"Select\" || fieldType === \"Dropdown\")\n    ) {\n      const selectedOption = cfv.field.fieldOptions.find(\n        (fo) => fo.fieldOption.id === cfv.value\n      );\n      if (selectedOption) {\n        doc.fieldOption = {\n          id: selectedOption.fieldOption.id,\n          name: selectedOption.fieldOption.name,\n          icon: selectedOption.fieldOption.icon,\n          iconColor: selectedOption.fieldOption.iconColor,\n        };\n      }\n    }\n\n    // Add all field options for multi-select fields\n    if (cfv.field.fieldOptions && fieldType === \"Multi-Select\") {\n      doc.fieldOptions = cfv.field.fieldOptions.map((fo) => ({\n        id: fo.fieldOption.id,\n        name: fo.fieldOption.name,\n        icon: fo.fieldOption.icon,\n        iconColor: fo.fieldOption.iconColor,\n      }));\n    }\n\n    return doc;\n  });\n}\n\n/**\n * Get all indices for a list of entity types\n */\nexport function getIndicesForEntityTypes(\n  entityTypes?: SearchableEntityType[]\n): string[] {\n  if (!entityTypes || entityTypes.length === 0) {\n    return Object.values(ENTITY_INDICES);\n  }\n\n  return entityTypes.map((type) => ENTITY_INDICES[type]);\n}\n\n/**\n * Build aggregations for faceted search\n */\nexport function buildAggregations(\n  facets: string[],\n  entityTypes?: SearchableEntityType[]\n): Record<string, any> {\n  const aggs: Record<string, any> = {};\n\n  // Common facets\n  if (facets.includes(\"projects\") || facets.includes(\"projectId\")) {\n    aggs.projects = {\n      terms: {\n        field: \"projectId\",\n        size: 100,\n      },\n    };\n  }\n\n  if (facets.includes(\"states\") || facets.includes(\"stateId\")) {\n    aggs.states = {\n      terms: {\n        field: \"stateId\",\n        size: 50,\n      },\n    };\n  }\n\n  if (facets.includes(\"tags\") || facets.includes(\"tagIds\")) {\n    aggs.tags = {\n      terms: {\n        field: \"tagIds\",\n        size: 100,\n      },\n    };\n  }\n\n  if (facets.includes(\"creators\") || facets.includes(\"creatorId\")) {\n    aggs.creators = {\n      terms: {\n        field: \"createdById.keyword\",\n        size: 100,\n      },\n    };\n  }\n\n  // Entity-specific aggregations\n  if (\n    !entityTypes ||\n    entityTypes.includes(SearchableEntityType.REPOSITORY_CASE)\n  ) {\n    if (facets.includes(\"folders\") || facets.includes(\"folderId\")) {\n      aggs.folders = {\n        terms: {\n          field: \"folderId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"templates\") || facets.includes(\"templateId\")) {\n      aggs.templates = {\n        terms: {\n          field: \"templateId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"automated\")) {\n      aggs.automated = {\n        terms: {\n          field: \"automated\",\n        },\n      };\n    }\n  }\n\n  if (!entityTypes || entityTypes.includes(SearchableEntityType.TEST_RUN)) {\n    if (\n      facets.includes(\"configurations\") ||\n      facets.includes(\"configurationId\")\n    ) {\n      aggs.configurations = {\n        terms: {\n          field: \"configurationId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"milestones\") || facets.includes(\"milestoneId\")) {\n      aggs.milestones = {\n        terms: {\n          field: \"milestoneId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"testRunType\")) {\n      aggs.testRunType = {\n        terms: {\n          field: \"testRunType\",\n        },\n      };\n    }\n  }\n\n  if (!entityTypes || entityTypes.includes(SearchableEntityType.SESSION)) {\n    if (facets.includes(\"assignedTo\") || facets.includes(\"assignedToId\")) {\n      aggs.assignedTo = {\n        terms: {\n          field: \"assignedToId.keyword\",\n          size: 100,\n        },\n      };\n    }\n  }\n\n  // Entity type counts\n  aggs.entityTypes = {\n    terms: {\n      field: \"_index\",\n      size: 10,\n    },\n  };\n\n  return aggs;\n}\n", "import {\n  getElasticsearchClient,\n  ENTITY_INDICES,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { TestRuns, Prisma } from \"@prisma/client\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\nconst prisma = new PrismaClient();\n\n/**\n * Type for test run with all required relations for indexing\n */\ntype TestRunForIndexing = TestRuns & {\n  project: { name: string };\n  createdBy: { name: string };\n  state: { name: string };\n  configuration?: { name: string } | null;\n  milestone?: { name: string } | null;\n  tags: Array<{ id: number; name: string }>;\n};\n\n/**\n * Index a single test run to Elasticsearch\n */\nexport async function indexTestRun(testRun: TestRunForIndexing): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const searchableContent = [\n    testRun.name,\n    testRun.note ? extractTextFromNode(testRun.note) : \"\",\n    testRun.docs ? extractTextFromNode(testRun.docs) : \"\",\n    testRun.tags.map((t) => t.name).join(\" \"),\n  ].join(\" \");\n\n  const document = {\n    id: testRun.id,\n    projectId: testRun.projectId,\n    projectName: testRun.project.name,\n    name: testRun.name,\n    note: testRun.note,\n    docs: testRun.docs,\n    configId: testRun.configId,\n    configurationName: testRun.configuration?.name,\n    milestoneId: testRun.milestoneId,\n    milestoneName: testRun.milestone?.name,\n    stateId: testRun.stateId,\n    stateName: testRun.state.name,\n    forecastManual: testRun.forecastManual,\n    forecastAutomated: testRun.forecastAutomated,\n    elapsed: testRun.elapsed,\n    isCompleted: testRun.isCompleted,\n    isDeleted: testRun.isDeleted,\n    completedAt: testRun.completedAt,\n    testRunType: testRun.testRunType,\n    createdAt: testRun.createdAt,\n    createdById: testRun.createdById,\n    createdByName: testRun.createdBy.name,\n    tags: testRun.tags.map((tag) => ({ id: tag.id, name: tag.name })),\n    searchableContent,\n  };\n\n  await client.index({\n    index: ENTITY_INDICES[SearchableEntityType.TEST_RUN],\n    id: testRun.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete a test run from Elasticsearch\n */\nexport async function deleteTestRunFromIndex(testRunId: number): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  try {\n    await client.delete({\n      index: ENTITY_INDICES[SearchableEntityType.TEST_RUN],\n      id: testRunId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete test run from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single test run to Elasticsearch\n */\nexport async function syncTestRunToElasticsearch(testRunId: number): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const testRun = await prisma.testRuns.findUnique({\n      where: { id: testRunId },\n      include: {\n        project: true,\n        createdBy: true,\n        state: true,\n        configuration: true,\n        milestone: true,\n        tags: true,\n      },\n    });\n\n    if (!testRun) {\n      console.warn(`Test run ${testRunId} not found`);\n      return false;\n    }\n\n    // Index test run including deleted ones (filtering happens at search time based on admin permissions)\n\n    // Index the test run\n    await indexTestRun(testRun as TestRunForIndexing);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync test run ${testRunId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index test runs for a project\n */\nexport async function syncProjectTestRunsToElasticsearch(\n  projectId: number,\n  db: any\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  console.log(`Starting test run sync for project ${projectId}`);\n\n  const testRuns = await db.testRuns.findMany({\n    where: {\n      projectId: projectId,\n      // Include deleted items (filtering happens at search time based on admin permissions)\n    },\n    include: {\n      project: true,\n      createdBy: true,\n      state: true,\n      configuration: true,\n      milestone: true,\n      tags: true,\n    },\n  });\n\n  if (testRuns.length === 0) {\n    console.log(\"No test runs to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  for (const testRun of testRuns) {\n    const searchableContent = [\n      testRun.name,\n      testRun.note ? extractTextFromNode(testRun.note) : \"\",\n      testRun.docs ? extractTextFromNode(testRun.docs) : \"\",\n      testRun.tags.map((t: any) => t.name).join(\" \"),\n    ].join(\" \");\n\n    bulkBody.push({\n      index: {\n        _index: ENTITY_INDICES[SearchableEntityType.TEST_RUN],\n        _id: testRun.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: testRun.id,\n      projectId: testRun.projectId,\n      projectName: testRun.project.name,\n      name: testRun.name,\n      note: testRun.note,\n      docs: testRun.docs,\n      configId: testRun.configId,\n      configurationName: testRun.configuration?.name,\n      milestoneId: testRun.milestoneId,\n      milestoneName: testRun.milestone?.name,\n      stateId: testRun.stateId,\n      stateName: testRun.state.name,\n      forecastManual: testRun.forecastManual,\n      forecastAutomated: testRun.forecastAutomated,\n      elapsed: testRun.elapsed,\n      isCompleted: testRun.isCompleted,\n      isDeleted: testRun.isDeleted,\n      completedAt: testRun.completedAt,\n      testRunType: testRun.testRunType,\n      createdAt: testRun.createdAt,\n      createdById: testRun.createdById,\n      createdByName: testRun.createdBy.name,\n      tags: testRun.tags.map((tag: any) => ({ id: tag.id, name: tag.name })),\n      searchableContent,\n    });\n  }\n\n  try {\n    const bulkResponse = await client.bulk({ body: bulkBody, refresh: true });\n\n    if (bulkResponse.errors) {\n      const errors = bulkResponse.items.filter(\n        (item: any) => item.index?.error\n      );\n      console.error(\"Bulk indexing errors:\", errors);\n    } else {\n      console.log(`Successfully indexed ${testRuns.length} test runs`);\n    }\n  } catch (error) {\n    console.error(\"Failed to bulk index test runs:\", error);\n    throw error;\n  }\n}\n\n/**\n * Search for test runs\n */\nexport async function searchTestRuns(params: {\n  query?: string;\n  projectIds?: number[];\n  stateIds?: number[];\n  configurationIds?: number[];\n  milestoneIds?: number[];\n  isCompleted?: boolean;\n  testRunType?: string;\n  customFields?: Array<{\n    fieldId: number;\n    fieldType: string;\n    operator: string;\n    value: any;\n    value2?: any;\n  }>;\n  from?: number;\n  size?: number;\n  sort?: Array<{ field: string; order: \"asc\" | \"desc\" }>;\n}): Promise<{\n  hits: any[];\n  total: number;\n  took: number;\n}> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    return { hits: [], total: 0, took: 0 };\n  }\n\n  const must: any[] = [];\n  const filter: any[] = [];\n\n  // Add query\n  if (params.query) {\n    must.push({\n      multi_match: {\n        query: params.query,\n        fields: [\n          \"name^3\",\n          \"searchableContent\",\n          \"note\",\n          \"docs\",\n          \"customFields.value\",\n        ],\n        type: \"best_fields\",\n        operator: \"or\",\n        fuzziness: \"AUTO\",\n      },\n    });\n  }\n\n  // Add filters\n  if (params.projectIds && params.projectIds.length > 0) {\n    filter.push({ terms: { projectId: params.projectIds } });\n  }\n  if (params.stateIds && params.stateIds.length > 0) {\n    filter.push({ terms: { stateId: params.stateIds } });\n  }\n  if (params.configurationIds && params.configurationIds.length > 0) {\n    filter.push({ terms: { configId: params.configurationIds } });\n  }\n  if (params.milestoneIds && params.milestoneIds.length > 0) {\n    filter.push({ terms: { milestoneId: params.milestoneIds } });\n  }\n  if (typeof params.isCompleted === \"boolean\") {\n    filter.push({ term: { isCompleted: params.isCompleted } });\n  }\n  if (params.testRunType) {\n    filter.push({ term: { testRunType: params.testRunType } });\n  }\n\n  // Add custom field filters\n  if (params.customFields) {\n    // Implementation would be similar to repository case custom field filters\n  }\n\n  const searchBody: any = {\n    index: ENTITY_INDICES[SearchableEntityType.TEST_RUN],\n    from: params.from || 0,\n    size: params.size || 20,\n    query: {\n      bool: {\n        must,\n        filter,\n      },\n    },\n    highlight: {\n      fields: {\n        name: { number_of_fragments: 1 },\n        searchableContent: { number_of_fragments: 3 },\n        note: { number_of_fragments: 2 },\n        docs: { number_of_fragments: 2 },\n      },\n      pre_tags: ['<mark class=\"search-highlight\">'],\n      post_tags: [\"</mark>\"],\n    },\n  };\n\n  // Add sorting\n  if (params.sort && params.sort.length > 0) {\n    searchBody.sort = params.sort.map((s) => ({\n      [s.field]: { order: s.order },\n    }));\n  }\n\n  try {\n    const response = await client.search(searchBody);\n    return {\n      hits: response.hits.hits,\n      total:\n        typeof response.hits.total === \"object\"\n          ? response.hits.total.value\n          : response.hits.total || 0,\n      took: response.took,\n    };\n  } catch (error) {\n    console.error(\"Test run search error:\", error);\n    return { hits: [], total: 0, took: 0 };\n  }\n}\n", "import {\n  getElasticsearchClient,\n  ENTITY_INDICES,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Sessions, Prisma } from \"@prisma/client\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\nconst prisma = new PrismaClient();\n\n/**\n * Type for session with all required relations for indexing\n */\ntype SessionForIndexing = Sessions & {\n  project: { name: string };\n  createdBy: { name: string };\n  assignedTo?: { name: string } | null;\n  state: { name: string };\n  template: { templateName: string };\n  configuration?: { name: string } | null;\n  milestone?: { name: string } | null;\n  tags: Array<{ id: number; name: string }>;\n  sessionFields?: Array<{\n    fieldId: number;\n    field: {\n      displayName: string;\n      systemName: string;\n      type?: { type: string };\n    };\n    value: any;\n  }>;\n};\n\n/**\n * Index a single session to Elasticsearch\n */\nexport async function indexSession(session: SessionForIndexing): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const searchableContent = [\n    session.name,\n    session.note ? extractTextFromNode(session.note) : \"\",\n    session.mission ? extractTextFromNode(session.mission) : \"\",\n    session.tags.map((t) => t.name).join(\" \"),\n  ].join(\" \");\n\n\n  const document = {\n    id: session.id,\n    projectId: session.projectId,\n    projectName: session.project.name,\n    templateId: session.templateId,\n    templateName: session.template.templateName,\n    name: session.name,\n    note: session.note,\n    mission: session.mission,\n    configId: session.configId,\n    configurationName: session.configuration?.name,\n    milestoneId: session.milestoneId,\n    milestoneName: session.milestone?.name,\n    stateId: session.stateId,\n    stateName: session.state.name,\n    assignedToId: session.assignedToId,\n    assignedToName: session.assignedTo?.name,\n    estimate: session.estimate,\n    forecastManual: session.forecastManual,\n    forecastAutomated: session.forecastAutomated,\n    elapsed: session.elapsed,\n    isCompleted: session.isCompleted,\n    isDeleted: session.isDeleted,\n    completedAt: session.completedAt,\n    createdAt: session.createdAt,\n    createdById: session.createdById,\n    createdByName: session.createdBy.name,\n    tags: session.tags.map((tag) => ({ id: tag.id, name: tag.name })),\n    searchableContent,\n  };\n\n  await client.index({\n    index: ENTITY_INDICES[SearchableEntityType.SESSION],\n    id: session.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete a session from Elasticsearch\n */\nexport async function deleteSessionFromIndex(sessionId: number): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  try {\n    await client.delete({\n      index: ENTITY_INDICES[SearchableEntityType.SESSION],\n      id: sessionId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete session from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single session to Elasticsearch\n */\nexport async function syncSessionToElasticsearch(sessionId: number): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const session = await prisma.sessions.findUnique({\n      where: { id: sessionId },\n      include: {\n        project: true,\n        createdBy: true,\n        assignedTo: true,\n        state: true,\n        template: true,\n        configuration: true,\n        milestone: true,\n        tags: true,\n      },\n    });\n\n    if (!session) {\n      console.warn(`Session ${sessionId} not found`);\n      return false;\n    }\n\n    // Index session including deleted ones (filtering happens at search time based on admin permissions)\n\n    // Index the session\n    await indexSession(session as SessionForIndexing);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync session ${sessionId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index sessions for a project\n */\nexport async function syncProjectSessionsToElasticsearch(\n  projectId: number,\n  db: any\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n\n  const sessions = await db.sessions.findMany({\n    where: {\n      projectId: projectId,\n      // Include deleted items (filtering happens at search time based on admin permissions)\n    },\n    include: {\n      project: true,\n      createdBy: true,\n      assignedTo: true,\n      state: true,\n      template: true,\n      configuration: true,\n      milestone: true,\n      tags: true,\n    },\n  });\n\n  if (sessions.length === 0) {\n    return;\n  }\n\n  const bulkBody = [];\n  for (const session of sessions) {\n    const searchableContent = [\n      session.name,\n      session.note ? extractTextFromNode(session.note) : \"\",\n      session.mission ? extractTextFromNode(session.mission) : \"\",\n      session.tags.map((t: any) => t.name).join(\" \"),\n    ].join(\" \");\n\n\n    bulkBody.push({\n      index: {\n        _index: ENTITY_INDICES[SearchableEntityType.SESSION],\n        _id: session.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: session.id,\n      projectId: session.projectId,\n      projectName: session.project.name,\n      templateId: session.templateId,\n      templateName: session.template.templateName,\n      name: session.name,\n      note: session.note,\n      mission: session.mission,\n      configId: session.configId,\n      configurationName: session.configuration?.name,\n      milestoneId: session.milestoneId,\n      milestoneName: session.milestone?.name,\n      stateId: session.stateId,\n      stateName: session.state.name,\n      assignedToId: session.assignedToId,\n      assignedToName: session.assignedTo?.name,\n      estimate: session.estimate,\n      forecastManual: session.forecastManual,\n      forecastAutomated: session.forecastAutomated,\n      elapsed: session.elapsed,\n      isCompleted: session.isCompleted,\n      isDeleted: session.isDeleted,\n      completedAt: session.completedAt,\n      createdAt: session.createdAt,\n      createdById: session.createdById,\n      createdByName: session.createdBy.name,\n      tags: session.tags.map((tag: any) => ({ id: tag.id, name: tag.name })),\n      searchableContent,\n    });\n  }\n\n  try {\n    const bulkResponse = await client.bulk({ body: bulkBody, refresh: true });\n\n    if (bulkResponse.errors) {\n      const errors = bulkResponse.items.filter(\n        (item: any) => item.index?.error\n      );\n      console.error(\"Bulk indexing errors:\", errors);\n    } else {\n    }\n  } catch (error) {\n    console.error(\"Failed to bulk index sessions:\", error);\n    throw error;\n  }\n}\n\n/**\n * Search for sessions\n */\nexport async function searchSessions(params: {\n  query?: string;\n  projectIds?: number[];\n  templateIds?: number[];\n  stateIds?: number[];\n  assignedToIds?: string[];\n  configurationIds?: number[];\n  milestoneIds?: number[];\n  isCompleted?: boolean;\n  customFields?: Array<{\n    fieldId: number;\n    fieldType: string;\n    operator: string;\n    value: any;\n    value2?: any;\n  }>;\n  from?: number;\n  size?: number;\n  sort?: Array<{ field: string; order: \"asc\" | \"desc\" }>;\n}): Promise<{\n  hits: any[];\n  total: number;\n  took: number;\n}> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    return { hits: [], total: 0, took: 0 };\n  }\n\n  const must: any[] = [];\n  const filter: any[] = [];\n\n  // Add query\n  if (params.query) {\n    must.push({\n      multi_match: {\n        query: params.query,\n        fields: [\n          \"name^3\",\n          \"searchableContent\",\n          \"note\",\n          \"mission\",\n          \"customFields.value\",\n        ],\n        type: \"best_fields\",\n        operator: \"or\",\n        fuzziness: \"AUTO\",\n      },\n    });\n  }\n\n  // Add filters\n  if (params.projectIds && params.projectIds.length > 0) {\n    filter.push({ terms: { projectId: params.projectIds } });\n  }\n  if (params.templateIds && params.templateIds.length > 0) {\n    filter.push({ terms: { templateId: params.templateIds } });\n  }\n  if (params.stateIds && params.stateIds.length > 0) {\n    filter.push({ terms: { stateId: params.stateIds } });\n  }\n  if (params.assignedToIds && params.assignedToIds.length > 0) {\n    filter.push({ terms: { assignedToId: params.assignedToIds } });\n  }\n  if (params.configurationIds && params.configurationIds.length > 0) {\n    filter.push({ terms: { configId: params.configurationIds } });\n  }\n  if (params.milestoneIds && params.milestoneIds.length > 0) {\n    filter.push({ terms: { milestoneId: params.milestoneIds } });\n  }\n  if (typeof params.isCompleted === \"boolean\") {\n    filter.push({ term: { isCompleted: params.isCompleted } });\n  }\n\n  // Add custom field filters\n  if (params.customFields) {\n    // Implementation would be similar to repository case custom field filters\n  }\n\n  const searchBody: any = {\n    index: ENTITY_INDICES[SearchableEntityType.SESSION],\n    from: params.from || 0,\n    size: params.size || 20,\n    query: {\n      bool: {\n        must,\n        filter,\n      },\n    },\n    highlight: {\n      fields: {\n        name: { number_of_fragments: 1 },\n        searchableContent: { number_of_fragments: 3 },\n        note: { number_of_fragments: 2 },\n        mission: { number_of_fragments: 2 },\n      },\n      pre_tags: ['<mark class=\"search-highlight\">'],\n      post_tags: [\"</mark>\"],\n    },\n  };\n\n  // Add sorting\n  if (params.sort && params.sort.length > 0) {\n    searchBody.sort = params.sort.map((s) => ({\n      [s.field]: { order: s.order },\n    }));\n  }\n\n  try {\n    const response = await client.search(searchBody);\n    return {\n      hits: response.hits.hits,\n      total:\n        typeof response.hits.total === \"object\"\n          ? response.hits.total.value\n          : response.hits.total || 0,\n      took: response.took,\n    };\n  } catch (error) {\n    console.error(\"Session search error:\", error);\n    return { hits: [], total: 0, took: 0 };\n  }\n}\n", "import { PrismaClient } from \"@prisma/client\";\nimport {\n  getElasticsearchClient,\n  ENTITY_INDICES,\n  createEntityIndex,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\nconst prisma = new PrismaClient();\n\n/**\n * Document structure for shared steps in Elasticsearch\n */\nexport interface SharedStepDocument {\n  id: number;\n  name: string;\n  projectId: number;\n  projectName: string;\n  projectIconUrl?: string | null;\n  createdAt: Date;\n  createdById: string;\n  createdByName: string;\n  createdByImage?: string | null;\n  isDeleted: boolean;\n  items: Array<{\n    id: number;\n    order: number;\n    step: string;\n    expectedResult: string;\n  }>;\n  searchableContent: string;\n}\n\n/**\n * Build a shared step document for Elasticsearch from Prisma data\n */\nexport async function buildSharedStepDocument(\n  stepGroupId: number\n): Promise<SharedStepDocument | null> {\n  const stepGroup = await prisma.sharedStepGroup.findUnique({\n    where: { id: stepGroupId },\n    include: {\n      project: true,\n      createdBy: true,\n      items: {\n        orderBy: { order: \"asc\" },\n      },\n    },\n  });\n\n  if (!stepGroup) return null;\n\n  // Build searchable content from name and step items\n  const searchableContent = [\n    stepGroup.name,\n    ...stepGroup.items.map((item) => {\n      let stepText = \"\";\n      let expectedResultText = \"\";\n\n      // Handle step field\n      if (typeof item.step === \"string\") {\n        try {\n          const parsed = JSON.parse(item.step);\n          stepText = extractTextFromNode(parsed);\n        } catch {\n          stepText = item.step;\n        }\n      } else if (item.step) {\n        stepText = extractTextFromNode(item.step);\n      }\n\n      // Handle expectedResult field\n      if (typeof item.expectedResult === \"string\") {\n        try {\n          const parsed = JSON.parse(item.expectedResult);\n          expectedResultText = extractTextFromNode(parsed);\n        } catch {\n          expectedResultText = item.expectedResult;\n        }\n      } else if (item.expectedResult) {\n        expectedResultText = extractTextFromNode(item.expectedResult);\n      }\n\n      return `${stepText} ${expectedResultText}`;\n    }),\n  ].join(\" \");\n\n  return {\n    id: stepGroup.id,\n    name: stepGroup.name,\n    projectId: stepGroup.projectId,\n    projectName: stepGroup.project.name,\n    projectIconUrl: stepGroup.project.iconUrl,\n    createdAt: stepGroup.createdAt,\n    createdById: stepGroup.createdById,\n    createdByName: stepGroup.createdBy.name,\n    createdByImage: stepGroup.createdBy.image,\n    isDeleted: stepGroup.isDeleted,\n    items: stepGroup.items.map((item) => ({\n      id: item.id,\n      order: item.order,\n      step:\n        typeof item.step === \"object\"\n          ? JSON.stringify(item.step)\n          : String(item.step),\n      expectedResult:\n        typeof item.expectedResult === \"object\"\n          ? JSON.stringify(item.expectedResult)\n          : String(item.expectedResult),\n    })),\n    searchableContent,\n  };\n}\n\n/**\n * Index a shared step group in Elasticsearch\n */\nexport async function indexSharedStep(\n  stepData: SharedStepDocument\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  try {\n    await client.index({\n      index: ENTITY_INDICES[SearchableEntityType.SHARED_STEP],\n      id: stepData.id.toString(),\n      document: stepData,\n    });\n\n    console.log(`Indexed shared step ${stepData.id} in Elasticsearch`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to index shared step ${stepData.id}:`, error);\n    return false;\n  }\n}\n\n/**\n * Delete a shared step from Elasticsearch\n */\nexport async function deleteSharedStep(stepId: number): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  try {\n    await client.delete({\n      index: ENTITY_INDICES[SearchableEntityType.SHARED_STEP],\n      id: stepId.toString(),\n    });\n\n    console.log(`Deleted shared step ${stepId} from Elasticsearch`);\n    return true;\n  } catch (error) {\n    // 404 is expected if document doesn't exist\n    if ((error as any).statusCode === 404) {\n      console.log(\n        `Shared step ${stepId} not found in Elasticsearch (already deleted)`\n      );\n      return true;\n    }\n    console.error(`Failed to delete shared step ${stepId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Sync a shared step to Elasticsearch after create/update\n */\nexport async function syncSharedStepToElasticsearch(\n  stepId: number\n): Promise<boolean> {\n  const doc = await buildSharedStepDocument(stepId);\n  if (!doc) return false;\n\n  // Index shared step including deleted ones (filtering happens at search time based on admin permissions)\n  return await indexSharedStep(doc);\n}\n\n/**\n * Sync all shared steps for a project to Elasticsearch\n */\nexport async function syncProjectSharedStepsToElasticsearch(\n  projectId: number,\n  batchSize: number = 100\n): Promise<boolean> {\n  try {\n    // Ensure index exists\n    await createEntityIndex(SearchableEntityType.SHARED_STEP);\n\n    const totalSteps = await prisma.sharedStepGroup.count({\n      where: {\n        projectId,\n        // Include deleted items (filtering happens at search time based on admin permissions)\n      },\n    });\n\n    console.log(\n      `Syncing ${totalSteps} shared steps for project ${projectId}...`\n    );\n\n    let processed = 0;\n    let hasMore = true;\n\n    while (hasMore) {\n      const steps = await prisma.sharedStepGroup.findMany({\n        where: {\n          projectId,\n          // Include deleted items (filtering happens at search time based on admin permissions)\n        },\n        skip: processed,\n        take: batchSize,\n        orderBy: { id: \"asc\" },\n      });\n\n      if (steps.length === 0) {\n        hasMore = false;\n        break;\n      }\n\n      // Build and index documents for this batch\n      for (const step of steps) {\n        const doc = await buildSharedStepDocument(step.id);\n        if (doc) {\n          await indexSharedStep(doc);\n        }\n      }\n\n      processed += steps.length;\n      console.log(`Indexed ${processed}/${totalSteps} shared steps...`);\n    }\n\n    console.log(\n      `Successfully synced ${processed} shared steps to Elasticsearch`\n    );\n    return true;\n  } catch (error) {\n    console.error(\n      \"Error syncing project shared steps to Elasticsearch:\",\n      error\n    );\n    return false;\n  }\n}\n", "import {\n  getElasticsearchClient,\n  ENTITY_INDICES,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Issue } from \"@prisma/client\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\nconst prisma = new PrismaClient();\n\n/**\n * Type for issue with all required relations for indexing\n */\ntype IssueForIndexing = Issue & {\n  createdBy: { name: string; image?: string | null };\n  integration?: { name: string } | null;\n  // Direct project relationship (preferred)\n  project?: { id: number; name: string; iconUrl?: string | null } | null;\n  // Fallback: Try to get project from any relationship\n  repositoryCases?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  sessions?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  testRuns?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  sessionResults?: Array<{\n    session: {\n      project: { id: number; name: string; iconUrl?: string | null };\n    };\n  }>;\n  testRunResults?: Array<{\n    testRun: {\n      project: { id: number; name: string; iconUrl?: string | null };\n    };\n  }>;\n  testRunStepResults?: Array<{\n    testRunResult: {\n      testRun: {\n        project: { id: number; name: string; iconUrl?: string | null };\n      };\n    };\n  }>;\n};\n\n/**\n * Helper function to find project info from any issue relationship\n * Checks direct project relationship first, then falls back to relationship tables\n */\nfunction getProjectFromIssue(issue: IssueForIndexing): {\n  id: number;\n  name: string;\n  iconUrl?: string | null;\n} | null {\n  // Check direct project relationship first (most common and efficient)\n  if (issue.project) {\n    return issue.project;\n  }\n\n  // Fallback: Try repository cases\n  if (issue.repositoryCases?.[0]?.project) {\n    return issue.repositoryCases[0].project;\n  }\n\n  // Try sessions\n  if (issue.sessions?.[0]?.project) {\n    return issue.sessions[0].project;\n  }\n\n  // Try test runs\n  if (issue.testRuns?.[0]?.project) {\n    return issue.testRuns[0].project;\n  }\n\n  // Try session results\n  if (issue.sessionResults?.[0]?.session?.project) {\n    return issue.sessionResults[0].session.project;\n  }\n\n  // Try test run results\n  if (issue.testRunResults?.[0]?.testRun?.project) {\n    return issue.testRunResults[0].testRun.project;\n  }\n\n  // Try test run step results\n  if (issue.testRunStepResults?.[0]?.testRunResult?.testRun?.project) {\n    return issue.testRunStepResults[0].testRunResult.testRun.project;\n  }\n\n  return null;\n}\n\n/**\n * Index a single issue to Elasticsearch\n */\nexport async function indexIssue(issue: IssueForIndexing): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  // Try to get project info from any linked relationship\n  const projectInfo = getProjectFromIssue(issue);\n\n  // Skip indexing if no project is found (orphaned issue)\n  if (!projectInfo) {\n    console.warn(`Issue ${issue.id} (${issue.name}) has no linked project, skipping indexing`);\n    return;\n  }\n\n  const searchableContent = [\n    issue.name,\n    issue.title,\n    issue.description || \"\",\n    issue.externalId || \"\",\n    issue.note ? extractTextFromNode(issue.note) : \"\",\n    issue.integration?.name || \"\",\n  ].join(\" \");\n\n  const document = {\n    id: issue.id,\n    projectId: projectInfo.id,\n    projectName: projectInfo.name,\n    projectIconUrl: projectInfo.iconUrl,\n    name: issue.name,\n    title: issue.title,\n    description: issue.description,\n    externalId: issue.externalId,\n    note: issue.note,\n    url: (issue.data as any)?.url,\n    issueSystem: issue.integration?.name || \"Unknown\",\n    isDeleted: issue.isDeleted,\n    createdAt: issue.createdAt,\n    createdById: issue.createdById,\n    createdByName: issue.createdBy.name,\n    createdByImage: issue.createdBy.image,\n    searchableContent,\n  };\n\n  await client.index({\n    index: ENTITY_INDICES[SearchableEntityType.ISSUE],\n    id: issue.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete an issue from Elasticsearch\n */\nexport async function deleteIssueFromIndex(issueId: number): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  try {\n    await client.delete({\n      index: ENTITY_INDICES[SearchableEntityType.ISSUE],\n      id: issueId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete issue from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single issue to Elasticsearch\n */\nexport async function syncIssueToElasticsearch(\n  issueId: number\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const issue = await prisma.issue.findUnique({\n      where: { id: issueId },\n      include: {\n        createdBy: true,\n        integration: true,\n        // Include direct project relationship (preferred)\n        project: true,\n        // Fallback: Check all possible relationships to find project\n        repositoryCases: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        sessions: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        testRuns: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        sessionResults: {\n          take: 1,\n          include: {\n            session: {\n              include: {\n                project: true,\n              },\n            },\n          },\n        },\n        testRunResults: {\n          take: 1,\n          include: {\n            testRun: {\n              include: {\n                project: true,\n              },\n            },\n          },\n        },\n        testRunStepResults: {\n          take: 1,\n          include: {\n            testRunResult: {\n              include: {\n                testRun: {\n                  include: {\n                    project: true,\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (!issue) {\n      console.warn(`Issue ${issueId} not found`);\n      return false;\n    }\n\n    // Index issue including deleted ones (filtering happens at search time based on admin permissions)\n    // Note: indexIssue will skip issues without a valid project link\n    await indexIssue(issue as IssueForIndexing);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync issue ${issueId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index issues for a project\n */\nexport async function syncProjectIssuesToElasticsearch(\n  projectId: number,\n  db: any\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  console.log(`Starting issue sync for project ${projectId}`);\n\n  // Find issues either by direct projectId or through any relationship\n  const issues = await db.issue.findMany({\n    where: {\n      // Include deleted items (filtering happens at search time based on admin permissions)\n      OR: [\n        // Direct project relationship (preferred)\n        { projectId, project: { isDeleted: false } },\n        // Fallback: Find through relationships\n        { repositoryCases: { some: { projectId, project: { isDeleted: false } } } },\n        { sessions: { some: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        { testRuns: { some: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        { sessionResults: { some: { session: { projectId, isDeleted: false, project: { isDeleted: false } } } } },\n        { testRunResults: { some: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } } },\n        {\n          testRunStepResults: {\n            some: { testRunResult: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n          },\n        },\n      ],\n    },\n    include: {\n      createdBy: true,\n      integration: true,\n      // Include direct project relationship (preferred)\n      project: true,\n      // Fallback relationships\n      repositoryCases: {\n        where: { projectId, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      sessions: {\n        where: { projectId, isDeleted: false, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      testRuns: {\n        where: { projectId, isDeleted: false, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      sessionResults: {\n        where: { session: { projectId, isDeleted: false, project: { isDeleted: false } } },\n        take: 1,\n        include: {\n          session: {\n            include: { project: true },\n          },\n        },\n      },\n      testRunResults: {\n        where: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } },\n        take: 1,\n        include: {\n          testRun: {\n            include: { project: true },\n          },\n        },\n      },\n      testRunStepResults: {\n        where: { testRunResult: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        take: 1,\n        include: {\n          testRunResult: {\n            include: {\n              testRun: {\n                include: { project: true },\n              },\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (issues.length === 0) {\n    console.log(\"No issues to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  let skippedCount = 0;\n\n  for (const issue of issues) {\n    // Try to get project info from any linked relationship\n    const projectInfo = getProjectFromIssue(issue as IssueForIndexing);\n\n    // Skip issues without a valid project link\n    if (!projectInfo) {\n      console.warn(`Issue ${issue.id} has no linked project, skipping`);\n      skippedCount++;\n      continue;\n    }\n\n    const searchableContent = [\n      issue.name,\n      issue.title,\n      issue.description || \"\",\n      issue.externalId || \"\",\n      issue.note ? extractTextFromNode(issue.note) : \"\",\n      issue.integration?.name || \"\",\n    ].join(\" \");\n\n    bulkBody.push({\n      index: {\n        _index: ENTITY_INDICES[SearchableEntityType.ISSUE],\n        _id: issue.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: issue.id,\n      projectId: projectInfo.id,\n      projectName: projectInfo.name,\n      projectIconUrl: projectInfo.iconUrl,\n      name: issue.name,\n      title: issue.title,\n      description: issue.description,\n      externalId: issue.externalId,\n      note: issue.note,\n      url: (issue.data as any)?.url,\n      issueSystem: issue.integration?.name || \"Unknown\",\n      isDeleted: issue.isDeleted,\n      createdAt: issue.createdAt,\n      createdById: issue.createdById,\n      createdByName: issue.createdBy.name,\n      createdByImage: issue.createdBy.image,\n      searchableContent,\n    });\n  }\n\n  if (bulkBody.length === 0) {\n    console.log(\n      `No valid issues to index (${skippedCount} orphaned issues skipped)`\n    );\n    return;\n  }\n\n  try {\n    const response = await client.bulk({ body: bulkBody, refresh: true });\n    if (response.errors) {\n      console.error(\"Bulk indexing errors:\", response.errors);\n    }\n    console.log(\n      `Successfully indexed ${bulkBody.length / 2} issues (${skippedCount} orphaned issues skipped)`\n    );\n  } catch (error) {\n    console.error(\"Failed to index issues:\", error);\n  }\n}\n", "import {\n  getElasticsearchClient,\n  ENTITY_INDICES,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Milestones } from \"@prisma/client\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\nconst prisma = new PrismaClient();\n\n/**\n * Type for milestone with all required relations for indexing\n */\ntype MilestoneForIndexing = Milestones & {\n  project: { name: string; iconUrl?: string | null };\n  creator: { name: string; image?: string | null };\n  milestoneType: { name: string; icon?: { name: string } | null };\n  parent?: { name: string } | null;\n};\n\n/**\n * Index a single milestone to Elasticsearch\n */\nexport async function indexMilestone(milestone: MilestoneForIndexing): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const searchableContent = [\n    milestone.name,\n    milestone.note ? extractTextFromNode(milestone.note) : \"\",\n    milestone.docs ? extractTextFromNode(milestone.docs) : \"\",\n  ].join(\" \");\n\n\n  const document = {\n    id: milestone.id,\n    projectId: milestone.projectId,\n    projectName: milestone.project.name,\n    projectIconUrl: milestone.project.iconUrl,\n    name: milestone.name,\n    note: milestone.note,\n    docs: milestone.docs,\n    milestoneTypeId: milestone.milestoneTypesId,\n    milestoneTypeName: milestone.milestoneType.name,\n    milestoneTypeIcon: milestone.milestoneType.icon?.name,\n    parentId: milestone.parentId,\n    parentName: milestone.parent?.name,\n    isCompleted: milestone.isCompleted,\n    completedAt: milestone.completedAt,\n    isDeleted: milestone.isDeleted,\n    createdAt: milestone.createdAt,\n    createdById: milestone.createdBy,\n    createdByName: milestone.creator.name,\n    createdByImage: milestone.creator.image,\n    searchableContent,\n  };\n\n  await client.index({\n    index: ENTITY_INDICES[SearchableEntityType.MILESTONE],\n    id: milestone.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete a milestone from Elasticsearch\n */\nexport async function deleteMilestoneFromIndex(milestoneId: number): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  try {\n    await client.delete({\n      index: ENTITY_INDICES[SearchableEntityType.MILESTONE],\n      id: milestoneId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete milestone from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single milestone to Elasticsearch\n */\nexport async function syncMilestoneToElasticsearch(milestoneId: number): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const milestone = await prisma.milestones.findUnique({\n      where: { id: milestoneId },\n      include: {\n        project: true,\n        creator: true,\n        milestoneType: {\n          include: {\n            icon: true,\n          },\n        },\n        parent: true,\n      },\n    });\n\n    if (!milestone) {\n      console.warn(`Milestone ${milestoneId} not found`);\n      return false;\n    }\n\n    // Index milestone including deleted ones (filtering happens at search time based on admin permissions)\n\n    // Index the milestone\n    await indexMilestone(milestone as MilestoneForIndexing);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync milestone ${milestoneId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index milestones for a project\n */\nexport async function syncProjectMilestonesToElasticsearch(\n  projectId: number,\n  db: any\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  console.log(`Starting milestone sync for project ${projectId}`);\n\n  const milestones = await db.milestones.findMany({\n    where: {\n      projectId: projectId,\n      // Include deleted items (filtering happens at search time based on admin permissions)\n    },\n    include: {\n      project: true,\n      creator: true,\n      milestoneType: {\n        include: {\n          icon: true,\n        },\n      },\n      parent: true,\n    },\n  });\n\n  if (milestones.length === 0) {\n    console.log(\"No milestones to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  for (const milestone of milestones) {\n    const searchableContent = [\n      milestone.name,\n      milestone.note ? extractTextFromNode(milestone.note) : \"\",\n      milestone.docs ? extractTextFromNode(milestone.docs) : \"\",\n    ].join(\" \");\n\n\n    bulkBody.push({\n      index: {\n        _index: ENTITY_INDICES[SearchableEntityType.MILESTONE],\n        _id: milestone.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: milestone.id,\n      projectId: milestone.projectId,\n      projectName: milestone.project.name,\n      projectIconUrl: milestone.project.iconUrl,\n      name: milestone.name,\n      note: milestone.note,\n      docs: milestone.docs,\n      milestoneTypeId: milestone.milestoneTypesId,\n      milestoneTypeName: milestone.milestoneType.name,\n      milestoneTypeIcon: milestone.milestoneType.icon?.name,\n      parentId: milestone.parentId,\n      parentName: milestone.parent?.name,\n        isCompleted: milestone.isCompleted,\n      completedAt: milestone.completedAt,\n      isDeleted: milestone.isDeleted,\n      createdAt: milestone.createdAt,\n        createdById: milestone.createdBy,\n      createdByName: milestone.createdBy.name,\n      createdByImage: milestone.createdBy.image,\n        searchableContent,\n    });\n  }\n\n  try {\n    const response = await client.bulk({ body: bulkBody, refresh: true });\n    if (response.errors) {\n      console.error(\"Bulk indexing errors:\", response.errors);\n    }\n    console.log(`Successfully indexed ${milestones.length} milestones`);\n  } catch (error) {\n    console.error(\"Failed to index milestones:\", error);\n  }\n}\n\n/**\n * Sync all milestones that have a specific parent\n */\nexport async function syncChildMilestonesToElasticsearch(parentId: number): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  try {\n    const childMilestones = await prisma.milestones.findMany({\n      where: {\n        parentId: parentId,\n        // Include deleted items (filtering happens at search time based on admin permissions)\n      },\n    });\n\n    for (const child of childMilestones) {\n      await syncMilestoneToElasticsearch(child.id);\n    }\n  } catch (error) {\n    console.error(`Failed to sync child milestones of parent ${parentId}:`, error);\n  }\n}", "import {\n  getElasticsearchClient,\n  ENTITY_INDICES,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Projects } from \"@prisma/client\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\nconst prisma = new PrismaClient();\n\n/**\n * Type for project with all required relations for indexing\n */\ntype ProjectForIndexing = Projects & {\n  creator: { name: string; image?: string | null };\n};\n\n/**\n * Index a single project to Elasticsearch\n */\nexport async function indexProject(project: ProjectForIndexing): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const searchableContent = [\n    project.name,\n    project.note ? extractTextFromNode(project.note) : \"\",\n    project.docs ? extractTextFromNode(project.docs) : \"\",\n  ].join(\" \");\n\n  const document = {\n    id: project.id,\n    name: project.name,\n    iconUrl: project.iconUrl,\n    note: project.note,\n    docs: project.docs,\n    isDeleted: project.isDeleted,\n    createdAt: project.createdAt,\n    createdById: project.createdBy,\n    createdByName: project.creator.name,\n    createdByImage: project.creator.image,\n    searchableContent,\n  };\n\n  await client.index({\n    index: ENTITY_INDICES[SearchableEntityType.PROJECT],\n    id: project.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete a project from Elasticsearch\n */\nexport async function deleteProjectFromIndex(projectId: number): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  try {\n    await client.delete({\n      index: ENTITY_INDICES[SearchableEntityType.PROJECT],\n      id: projectId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete project from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single project to Elasticsearch\n */\nexport async function syncProjectToElasticsearch(projectId: number): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const project = await prisma.projects.findUnique({\n      where: { id: projectId },\n      include: {\n        creator: true,\n      },\n    });\n\n    if (!project) {\n      console.warn(`Project ${projectId} not found`);\n      return false;\n    }\n\n    // Index project including deleted ones (filtering happens at search time based on admin permissions)\n\n    // Index the project\n    await indexProject(project);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync project ${projectId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Sync all projects to Elasticsearch\n */\nexport async function syncAllProjectsToElasticsearch(): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  console.log(\"Starting project sync\");\n\n  const projects = await prisma.projects.findMany({\n    where: {\n      // Include deleted items (filtering happens at search time based on admin permissions)\n    },\n    include: {\n      creator: true,\n    },\n  });\n\n  if (projects.length === 0) {\n    console.log(\"No projects to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  for (const project of projects) {\n    const searchableContent = [\n      project.name,\n      project.note ? extractTextFromNode(project.note) : \"\",\n      project.docs ? extractTextFromNode(project.docs) : \"\",\n    ].join(\" \");\n\n    bulkBody.push({\n      index: {\n        _index: ENTITY_INDICES[SearchableEntityType.PROJECT],\n        _id: project.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: project.id,\n      name: project.name,\n      iconUrl: project.iconUrl,\n      note: project.note,\n      docs: project.docs,\n      isDeleted: project.isDeleted,\n      createdAt: project.createdAt,\n      createdById: project.createdBy,\n      createdByName: project.creator.name,\n      createdByImage: project.creator.image,\n      searchableContent,\n    });\n  }\n\n  try {\n    const response = await client.bulk({ body: bulkBody, refresh: true });\n    if (response.errors) {\n      console.error(\"Bulk indexing errors:\", response.errors);\n    }\n    console.log(`Successfully indexed ${projects.length} projects`);\n  } catch (error) {\n    console.error(\"Failed to index projects:\", error);\n  }\n}", "import {\n  IssueAdapter,\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n  WebhookData,\n  FieldMapping,\n} from \"./IssueAdapter\";\n\n/**\n * Base abstract class implementing common functionality for all issue tracking adapters\n */\nexport abstract class BaseAdapter implements IssueAdapter {\n  protected config: any;\n  protected authData?: AuthenticationData;\n  protected authenticated: boolean = false;\n\n  // Rate limiting configuration\n  protected rateLimitDelay: number = 1000; // Default 1 second between requests\n  protected lastRequestTime: number = 0;\n\n  // Retry configuration\n  protected maxRetries: number = 3;\n  protected retryDelay: number = 1000;\n\n  constructor(config: any) {\n    this.config = config;\n  }\n\n  /**\n   * Get the capabilities of this adapter\n   */\n  abstract getCapabilities(): IssueAdapterCapabilities;\n\n  /**\n   * Authenticate with the issue tracking system\n   */\n  async authenticate(authData: AuthenticationData): Promise<void> {\n    this.authData = authData;\n    await this.performAuthentication(authData);\n    this.authenticated = true;\n  }\n\n  /**\n   * Perform adapter-specific authentication\n   */\n  protected abstract performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void>;\n\n  /**\n   * Check if the current authentication is valid\n   */\n  async isAuthenticated(): Promise<boolean> {\n    if (!this.authenticated || !this.authData) {\n      return false;\n    }\n\n    // Check if token has expired\n    if (this.authData.expiresAt && this.authData.expiresAt < new Date()) {\n      this.authenticated = false;\n      return false;\n    }\n\n    // Perform adapter-specific validation if needed\n    return this.validateAuthentication();\n  }\n\n  /**\n   * Validate authentication (can be overridden by adapters)\n   */\n  protected async validateAuthentication(): Promise<boolean> {\n    return true;\n  }\n\n  /**\n   * Create a new issue\n   */\n  abstract createIssue(data: CreateIssueData): Promise<IssueData>;\n\n  /**\n   * Update an existing issue\n   */\n  abstract updateIssue(\n    issueId: string,\n    data: UpdateIssueData\n  ): Promise<IssueData>;\n\n  /**\n   * Get a single issue by ID\n   */\n  abstract getIssue(issueId: string): Promise<IssueData>;\n\n  /**\n   * Search for issues\n   */\n  abstract searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }>;\n\n  /**\n   * Link an issue to a test case\n   */\n  async linkToTestCase(\n    issueId: string,\n    testCaseId: string,\n    metadata?: any\n  ): Promise<void> {\n    // Default implementation adds a comment to the issue\n    const comment = `Linked to test case: ${testCaseId}${metadata ? \"\\nMetadata: \" + JSON.stringify(metadata) : \"\"}`;\n    await this.addComment(issueId, comment);\n  }\n\n  /**\n   * Add a comment to an issue (should be implemented by adapters that support it)\n   */\n  protected async addComment(issueId: string, comment: string): Promise<void> {\n    throw new Error(\"Adding comments is not supported by this adapter\");\n  }\n\n  /**\n   * Sync issue data from the external system\n   */\n  async syncIssue(issueId: string): Promise<IssueData> {\n    return this.getIssue(issueId);\n  }\n\n  /**\n   * Apply rate limiting\n   */\n  protected async applyRateLimit(): Promise<void> {\n    const now = Date.now();\n    const timeSinceLastRequest = now - this.lastRequestTime;\n\n    if (timeSinceLastRequest < this.rateLimitDelay) {\n      const delay = this.rateLimitDelay - timeSinceLastRequest;\n      await this.sleep(delay);\n    }\n\n    this.lastRequestTime = Date.now();\n  }\n\n  /**\n   * Execute request with retry logic\n   */\n  protected async executeWithRetry<T>(\n    operation: () => Promise<T>,\n    retries: number = this.maxRetries\n  ): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let i = 0; i <= retries; i++) {\n      try {\n        await this.applyRateLimit();\n        return await operation();\n      } catch (error) {\n        lastError = error as Error;\n\n        if (i < retries) {\n          const delay = this.retryDelay * Math.pow(2, i); // Exponential backoff\n          console.warn(`Request failed, retrying in ${delay}ms...`, error);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    throw lastError || new Error(\"Operation failed after retries\");\n  }\n\n  /**\n   * Sleep for specified milliseconds\n   */\n  protected sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Make HTTP request with authentication headers\n   */\n  protected async makeRequest<T>(\n    url: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    if (!this.authData) {\n      throw new Error(\"Not authenticated\");\n    }\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      ...((options.headers as Record<string, string>) || {}),\n    };\n\n    // Add authentication headers based on auth type\n    switch (this.authData.type) {\n      case \"oauth\":\n        headers[\"Authorization\"] = `Bearer ${this.authData.accessToken}`;\n        break;\n      case \"api_key\":\n        // Some APIs use Authorization header with token prefix\n        if (this.authData.apiKey) {\n          if (this.config.provider === \"AZURE_DEVOPS\") {\n            // Azure DevOps uses Basic auth with PAT\n            const credentials = Buffer.from(\n              `:${this.authData.apiKey}`\n            ).toString(\"base64\");\n            headers[\"Authorization\"] = `Basic ${credentials}`;\n          } else if (this.config.provider === \"GITHUB\") {\n            // GitHub uses token prefix\n            headers[\"Authorization\"] = `token ${this.authData.apiKey}`;\n          } else {\n            // Default to X-API-Key header\n            headers[\"X-API-Key\"] = this.authData.apiKey;\n          }\n        }\n        break;\n      case \"basic\":\n        const credentials = Buffer.from(\n          `${this.authData.username}:${this.authData.password}`\n        ).toString(\"base64\");\n        headers[\"Authorization\"] = `Basic ${credentials}`;\n        break;\n    }\n\n    const response = await this.executeWithRetry(() =>\n      fetch(url, {\n        ...options,\n        headers,\n      })\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`HTTP ${response.status}: ${errorText}`);\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Build full URL from base URL and path\n   */\n  protected buildUrl(path: string): string {\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      throw new Error(\"Base URL not configured\");\n    }\n\n    // Ensure base URL doesn't end with slash and path starts with slash\n    const cleanBaseUrl = baseUrl.replace(/\\/$/, \"\");\n    const cleanPath = path.startsWith(\"/\") ? path : `/${path}`;\n\n    return `${cleanBaseUrl}${cleanPath}`;\n  }\n\n  /**\n   * Default implementation for webhook registration (not supported by default)\n   */\n  async registerWebhook?(\n    url: string,\n    events: string[],\n    secret?: string\n  ): Promise<WebhookData> {\n    throw new Error(\"Webhook registration is not supported by this adapter\");\n  }\n\n  /**\n   * Default implementation for webhook unregistration\n   */\n  async unregisterWebhook?(webhookId: string): Promise<void> {\n    throw new Error(\"Webhook unregistration is not supported by this adapter\");\n  }\n\n  /**\n   * Default implementation for webhook processing\n   */\n  async processWebhook?(payload: any, signature?: string): Promise<void> {\n    throw new Error(\"Webhook processing is not supported by this adapter\");\n  }\n\n  /**\n   * Get field mappings (can be overridden by adapters)\n   */\n  getFieldMappings?(): FieldMapping[] {\n    return [];\n  }\n\n  /**\n   * Validate configuration (can be overridden by adapters)\n   */\n  async validateConfiguration?(): Promise<{\n    valid: boolean;\n    errors?: string[];\n  }> {\n    const errors: string[] = [];\n\n    if (!this.authData) {\n      errors.push(\"No authentication data provided\");\n    }\n\n    if (!this.config.baseUrl && !this.authData?.baseUrl) {\n      errors.push(\"Base URL is required\");\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n}\n", "import { BaseAdapter } from \"./BaseAdapter\";\nimport {\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n} from \"./IssueAdapter\";\n\n/**\n * Jira integration adapter implementing OAuth authentication\n */\nexport class JiraAdapter extends BaseAdapter {\n  public supportsOAuth = true;\n\n  private clientId: string;\n  private clientSecret: string;\n  private redirectUri: string;\n  private cloudId?: string;\n  private apiEmail?: string;\n  private apiToken?: string;\n  private baseUrl?: string;\n\n  constructor(config: any) {\n    super(config);\n\n    // OAuth configuration\n    this.clientId = process.env.JIRA_CLIENT_ID || \"\";\n    this.clientSecret = process.env.JIRA_CLIENT_SECRET || \"\";\n    this.redirectUri = process.env.JIRA_REDIRECT_URI || \"\";\n\n    // Base URL from config if provided\n    if (config.baseUrl) {\n      this.baseUrl = config.baseUrl;\n    }\n  }\n\n  getCapabilities(): IssueAdapterCapabilities {\n    return {\n      createIssue: true,\n      updateIssue: true,\n      linkIssue: true,\n      syncIssue: true,\n      searchIssues: true,\n      webhooks: true,\n      customFields: true,\n      attachments: true,\n    };\n  }\n\n  protected async performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void> {\n    if (authData.type === \"api_key\") {\n      // Handle API key authentication\n      if (!authData.email || !authData.apiToken || !authData.baseUrl) {\n        throw new Error(\n          \"API key authentication requires email, apiToken, and baseUrl\"\n        );\n      }\n\n      this.apiEmail = authData.email;\n      this.apiToken = authData.apiToken;\n      this.baseUrl = authData.baseUrl;\n\n      // Test the connection\n      const response = await fetch(`${this.baseUrl}/rest/api/3/myself`, {\n        headers: {\n          Authorization: `Basic ${Buffer.from(`${this.apiEmail}:${this.apiToken}`).toString(\"base64\")}`,\n          Accept: \"application/json\",\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          `Jira API authentication failed: ${response.statusText}`\n        );\n      }\n    } else if (authData.type === \"oauth\") {\n      // OAuth authentication\n      if (!this.clientId || !this.clientSecret || !this.redirectUri) {\n        throw new Error(\n          \"Jira OAuth configuration is incomplete. Please check environment variables.\"\n        );\n      }\n\n      // Get accessible resources to determine the cloud ID\n      if (!this.cloudId) {\n        const resources = await this.getAccessibleResources(\n          authData.accessToken!\n        );\n        if (resources.length === 0) {\n          throw new Error(\"No accessible Jira resources found\");\n        }\n        this.cloudId = resources[0].id;\n      }\n    } else {\n      throw new Error(\n        \"Jira adapter only supports OAuth and API key authentication\"\n      );\n    }\n  }\n\n  /**\n   * Get available projects\n   */\n  async getProjects(): Promise<\n    Array<{ id: string; key: string; name: string }>\n  > {\n    if (this.apiEmail && this.apiToken && this.baseUrl) {\n      // API key authentication\n      const response = await fetch(\n        `${this.baseUrl}/rest/api/3/project/search`,\n        {\n          headers: {\n            Authorization: `Basic ${Buffer.from(`${this.apiEmail}:${this.apiToken}`).toString(\"base64\")}`,\n            Accept: \"application/json\",\n          },\n        }\n      );\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch projects: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return (data.values || []).map((project: any) => ({\n        id: project.id,\n        key: project.key,\n        name: project.name,\n      }));\n    } else if (this.authData?.accessToken && this.cloudId) {\n      // OAuth authentication\n      const response = await this.makeRequest<any>(\n        `https://api.atlassian.com/ex/jira/${this.cloudId}/rest/api/3/project/search`\n      );\n\n      return (response.values || []).map((project: any) => ({\n        id: project.id,\n        key: project.key,\n        name: project.name,\n      }));\n    } else {\n      throw new Error(\"Not authenticated\");\n    }\n  }\n\n  /**\n   * Get OAuth authorization URL\n   */\n  getAuthorizationUrl(state: string): string {\n    const params = new URLSearchParams({\n      audience: \"api.atlassian.com\",\n      client_id: this.clientId,\n      scope: \"read:jira-work write:jira-work read:jira-user offline_access\",\n      redirect_uri: this.redirectUri,\n      state: state,\n      response_type: \"code\",\n      prompt: \"consent\",\n    });\n\n    return `https://auth.atlassian.com/authorize?${params.toString()}`;\n  }\n\n  /**\n   * Exchange authorization code for tokens\n   */\n  async exchangeCodeForTokens(code: string): Promise<{\n    accessToken: string;\n    refreshToken?: string;\n    expiresAt?: Date;\n  }> {\n    const response = await fetch(\"https://auth.atlassian.com/oauth/token\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        grant_type: \"authorization_code\",\n        client_id: this.clientId,\n        client_secret: this.clientSecret,\n        code: code,\n        redirect_uri: this.redirectUri,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to exchange code for tokens: ${error}`);\n    }\n\n    const data = await response.json();\n\n    return {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token,\n      expiresAt: data.expires_in\n        ? new Date(Date.now() + data.expires_in * 1000)\n        : undefined,\n    };\n  }\n\n  /**\n   * Refresh OAuth tokens\n   */\n  async refreshTokens(refreshToken: string): Promise<{\n    accessToken: string;\n    refreshToken?: string;\n    expiresAt?: Date;\n  }> {\n    const response = await fetch(\"https://auth.atlassian.com/oauth/token\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        grant_type: \"refresh_token\",\n        client_id: this.clientId,\n        client_secret: this.clientSecret,\n        refresh_token: refreshToken,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to refresh tokens: ${error}`);\n    }\n\n    const data = await response.json();\n\n    return {\n      accessToken: data.access_token,\n      refreshToken: data.refresh_token || refreshToken,\n      expiresAt: data.expires_in\n        ? new Date(Date.now() + data.expires_in * 1000)\n        : undefined,\n    };\n  }\n\n  /**\n   * Get accessible Jira resources\n   */\n  private async getAccessibleResources(accessToken: string): Promise<\n    Array<{\n      id: string;\n      url: string;\n      name: string;\n      scopes: string[];\n    }>\n  > {\n    const response = await fetch(\n      \"https://api.atlassian.com/oauth/token/accessible-resources\",\n      {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          Accept: \"application/json\",\n        },\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(\"Failed to get accessible resources\");\n    }\n\n    return response.json();\n  }\n\n  protected buildUrl(path: string): string {\n    // For API key auth, use the base URL directly\n    if (this.apiEmail && this.apiToken && this.baseUrl) {\n      return `${this.baseUrl}${path}`;\n    }\n\n    // For OAuth, use cloud ID\n    if (!this.cloudId) {\n      throw new Error(\"Cloud ID not set. Please authenticate first.\");\n    }\n    return `https://api.atlassian.com/ex/jira/${this.cloudId}${path}`;\n  }\n\n  /**\n   * Override makeRequest to handle Jira's API key authentication\n   */\n  protected async makeRequest<T = any>(\n    url: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    // If using API key auth, bypass the base class and handle it directly\n    if (this.apiEmail && this.apiToken) {\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        ...((options.headers as any) || {}),\n      };\n\n      // Jira uses Basic auth with email:apiToken\n      const credentials = Buffer.from(\n        `${this.apiEmail}:${this.apiToken}`\n      ).toString(\"base64\");\n      headers[\"Authorization\"] = `Basic ${credentials}`;\n\n      const response = await fetch(url, {\n        ...options,\n        headers,\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`HTTP ${response.status}: ${errorText}`);\n      }\n\n      return response.json();\n    }\n\n    // Otherwise use the base class implementation for OAuth\n    return super.makeRequest<T>(url, options);\n  }\n\n  async createIssue(data: CreateIssueData): Promise<IssueData> {\n    // Determine if projectId is a key (e.g., \"TPI\") or an ID (numeric)\n    const projectField = isNaN(Number(data.projectId))\n      ? { key: data.projectId } // It's a project key\n      : { id: data.projectId }; // It's a project ID\n\n    // Convert description to ADF format\n    let descriptionField;\n    if (data.description) {\n      // console.log('[JiraAdapter] Raw description:', data.description);\n\n      // Check if description is TipTap JSON\n      if (\n        typeof data.description === \"object\" &&\n        data.description &&\n        \"type\" in data.description &&\n        data.description.type === \"doc\"\n      ) {\n        // Direct TipTap JSON to ADF conversion\n        descriptionField = this.tiptapToAdf(data.description);\n        // console.log('[JiraAdapter] Converted ADF from TipTap:', JSON.stringify(descriptionField, null, 2));\n      } else if (\n        typeof data.description === \"string\" &&\n        data.description.includes(\"<\") &&\n        data.description.includes(\">\")\n      ) {\n        // HTML string - use HTML to ADF converter\n        descriptionField = this.htmlToAdf(data.description);\n        // console.log('[JiraAdapter] Converted ADF from HTML:', JSON.stringify(descriptionField, null, 2));\n      } else if (typeof data.description === \"string\") {\n        // Plain text\n        descriptionField = {\n          type: \"doc\",\n          version: 1,\n          content: [\n            {\n              type: \"paragraph\",\n              content: [\n                {\n                  type: \"text\",\n                  text: data.description,\n                },\n              ],\n            },\n          ],\n        };\n      }\n    } else {\n      descriptionField = null;\n    }\n\n    // Extract reporter from customFields if present\n    const { reporter, ...otherCustomFields } = data.customFields || {};\n\n    // console.log(\"[JiraAdapter] Incoming data.customFields:\", JSON.stringify(data.customFields, null, 2));\n    // console.log(\"[JiraAdapter] Extracted reporter:\", JSON.stringify(reporter, null, 2));\n    // console.log(\"[JiraAdapter] Other custom fields:\", JSON.stringify(otherCustomFields, null, 2));\n\n    const jiraPayload = {\n      fields: {\n        project: projectField,\n        summary: data.title,\n        description: descriptionField,\n        issuetype: { id: data.issueType || \"10001\" }, // Default to Task\n        priority: data.priority ? { id: data.priority } : undefined,\n        assignee: data.assigneeId ? { id: data.assigneeId } : undefined,\n        reporter: reporter || undefined, // Reporter is a system field, not custom\n        labels: data.labels || [],\n        ...otherCustomFields,\n      },\n    };\n\n    // console.log(\"[JiraAdapter] Creating issue with payload:\", JSON.stringify(jiraPayload, null, 2));\n    // console.log(\"[JiraAdapter] Reporter field in payload:\", jiraPayload.fields.reporter);\n\n    try {\n      const response = await this.makeRequest<any>(\n        this.buildUrl(\"/rest/api/3/issue\"),\n        {\n          method: \"POST\",\n          body: JSON.stringify(jiraPayload),\n        }\n      );\n\n      // console.log(\"[JiraAdapter] Create issue response:\", JSON.stringify(response, null, 2));\n\n      // The create response only contains id, key, and self\n      // We need to fetch the full issue details\n      if (response.key) {\n        const fullIssue = await this.getIssue(response.key);\n        // console.log(\"[JiraAdapter] Created issue reporter:\", fullIssue.reporter);\n        return fullIssue;\n      }\n\n      throw new Error(\"Failed to create issue - no key returned\");\n    } catch (error) {\n      console.error(\"[JiraAdapter] Failed to create issue:\", error);\n      if (error instanceof Error) {\n        throw error;\n      }\n      throw new Error(\"Failed to create issue in Jira\");\n    }\n  }\n\n  async updateIssue(\n    issueId: string,\n    data: UpdateIssueData\n  ): Promise<IssueData> {\n    const updatePayload: any = { fields: {} };\n\n    if (data.title !== undefined) {\n      updatePayload.fields.summary = data.title;\n    }\n\n    if (data.description !== undefined) {\n      // Check if description is TipTap JSON\n      if (\n        typeof data.description === \"object\" &&\n        data.description &&\n        \"type\" in data.description &&\n        data.description.type === \"doc\"\n      ) {\n        // Direct TipTap JSON to ADF conversion\n        updatePayload.fields.description = this.tiptapToAdf(data.description);\n      } else if (\n        typeof data.description === \"string\" &&\n        data.description.includes(\"<\") &&\n        data.description.includes(\">\")\n      ) {\n        // HTML string - use HTML to ADF converter\n        updatePayload.fields.description = this.htmlToAdf(data.description);\n      } else if (typeof data.description === \"string\") {\n        // Plain text\n        updatePayload.fields.description = {\n          type: \"doc\",\n          version: 1,\n          content: [\n            {\n              type: \"paragraph\",\n              content: [\n                {\n                  type: \"text\",\n                  text: data.description,\n                },\n              ],\n            },\n          ],\n        };\n      }\n    }\n\n    if (data.priority !== undefined) {\n      updatePayload.fields.priority = { id: data.priority };\n    }\n\n    if (data.assigneeId !== undefined) {\n      updatePayload.fields.assignee = { id: data.assigneeId };\n    }\n\n    if (data.labels !== undefined) {\n      updatePayload.fields.labels = data.labels;\n    }\n\n    if (data.customFields) {\n      Object.assign(updatePayload.fields, data.customFields);\n    }\n\n    await this.makeRequest<any>(this.buildUrl(`/rest/api/3/issue/${issueId}`), {\n      method: \"PUT\",\n      body: JSON.stringify(updatePayload),\n    });\n\n    // Handle status transition separately if provided\n    if (data.status !== undefined) {\n      await this.transitionIssue(issueId, data.status);\n    }\n\n    return this.getIssue(issueId);\n  }\n\n  async getIssue(issueId: string): Promise<IssueData> {\n    // Explicitly request all fields we need, including issuetype with iconUrl\n    const params = new URLSearchParams({\n      fields:\n        \"summary,description,status,priority,issuetype,assignee,reporter,labels,created,updated\",\n      expand: \"names,schema\",\n    });\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/rest/api/3/issue/${issueId}?${params.toString()}`)\n    );\n\n    return this.mapJiraIssue(response);\n  }\n\n  async searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const jql: string[] = [];\n\n    if (options.projectId) {\n      jql.push(`project = ${options.projectId}`);\n    }\n\n    if (options.query) {\n      const query = options.query.trim();\n      const jqlConditions: string[] = [];\n\n      // Check if the query looks like a complete issue key (contains hyphen and follows pattern)\n      if (/^[A-Za-z]+-\\d+$/.test(query)) {\n        // Complete issue key - use exact match\n        jqlConditions.push(`key = \"${query.toUpperCase()}\"`);\n      }\n\n      // Always include text search in summary and description\n      jqlConditions.push(`summary ~ \"${query}*\"`);\n      jqlConditions.push(`description ~ \"${query}*\"`);\n\n      jql.push(`(${jqlConditions.join(\" OR \")})`);\n    }\n\n    if (options.status && options.status.length > 0) {\n      jql.push(`status IN (${options.status.map((s) => `\"${s}\"`).join(\", \")})`);\n    }\n\n    if (options.assignee) {\n      jql.push(`assignee = ${options.assignee}`);\n    }\n\n    if (options.labels && options.labels.length > 0) {\n      jql.push(`labels IN (${options.labels.map((l) => `\"${l}\"`).join(\", \")})`);\n    }\n\n    // Ensure the query is always bounded - Jira rejects unbounded queries\n    let jqlString: string;\n    if (jql.length > 0) {\n      jqlString = jql.join(\" AND \") + \" ORDER BY created DESC\";\n    } else if (options.fullSync) {\n      // Manual full sync without project filter - sync last year of issues\n      // Jira requires bounded queries, so we use a generous 1-year window\n      jqlString = \"created >= -365d ORDER BY created DESC\";\n    } else {\n      // Automatic/incremental sync - limit to last 30 days\n      jqlString = \"created >= -30d ORDER BY created DESC\";\n    }\n    const params = new URLSearchParams({\n      jql: jqlString,\n      startAt: (options.offset || 0).toString(),\n      maxResults: (options.limit || 50).toString(),\n      fields:\n        \"summary,description,status,priority,issuetype,assignee,reporter,labels,created,updated\",\n      expand: \"names,schema\",\n    });\n\n    const searchUrl = this.buildUrl(\n      `/rest/api/3/search/jql?${params.toString()}`\n    );\n\n    const response = await this.makeRequest<any>(searchUrl);\n\n    return {\n      issues: response.issues.map((issue: any) => this.mapJiraIssue(issue)),\n      total: response.total,\n      hasMore: response.startAt + response.issues.length < response.total,\n    };\n  }\n\n  protected async addComment(issueId: string, comment: string): Promise<void> {\n    await this.makeRequest(\n      this.buildUrl(`/rest/api/3/issue/${issueId}/comment`),\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          body: {\n            type: \"doc\",\n            version: 1,\n            content: [\n              {\n                type: \"paragraph\",\n                content: [\n                  {\n                    type: \"text\",\n                    text: comment,\n                  },\n                ],\n              },\n            ],\n          },\n        }),\n      }\n    );\n  }\n\n  private async transitionIssue(\n    issueId: string,\n    targetStatus: string\n  ): Promise<void> {\n    // Get available transitions\n    const transitions = await this.makeRequest<any>(\n      this.buildUrl(`/rest/api/3/issue/${issueId}/transitions`)\n    );\n\n    // Find the transition that leads to the target status\n    const transition = transitions.transitions.find(\n      (t: any) => t.to.name.toLowerCase() === targetStatus.toLowerCase()\n    );\n\n    if (!transition) {\n      throw new Error(`No transition available to status: ${targetStatus}`);\n    }\n\n    // Execute the transition\n    await this.makeRequest(\n      this.buildUrl(`/rest/api/3/issue/${issueId}/transitions`),\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          transition: { id: transition.id },\n        }),\n      }\n    );\n  }\n\n  private mapJiraIssue(jiraIssue: any): IssueData {\n    // Validate that we have the required data structure\n    if (!jiraIssue) {\n      throw new Error(\"Invalid Jira issue: issue object is null or undefined\");\n    }\n    if (!jiraIssue.fields) {\n      throw new Error(\n        `Invalid Jira issue ${jiraIssue.key || jiraIssue.id}: missing fields object`\n      );\n    }\n\n    const fields = jiraIssue.fields;\n\n    // Validate required fields\n    if (!fields.summary) {\n      throw new Error(\n        `Invalid Jira issue ${jiraIssue.key || jiraIssue.id}: missing summary field`\n      );\n    }\n    if (!fields.status) {\n      throw new Error(\n        `Invalid Jira issue ${jiraIssue.key || jiraIssue.id}: missing status field`\n      );\n    }\n\n    return {\n      id: jiraIssue.id,\n      key: jiraIssue.key,\n      title: fields.summary,\n      description: this.extractDescription(fields.description),\n      status: fields.status.name,\n      priority: fields.priority?.name,\n      issueType: fields.issuetype\n        ? {\n            id: fields.issuetype.id,\n            name: fields.issuetype.name,\n            iconUrl: fields.issuetype.iconUrl,\n          }\n        : undefined,\n      assignee: fields.assignee\n        ? {\n            id: fields.assignee.accountId,\n            name: fields.assignee.displayName,\n            email: fields.assignee.emailAddress,\n          }\n        : undefined,\n      reporter: fields.reporter\n        ? {\n            id: fields.reporter.accountId,\n            name: fields.reporter.displayName,\n            email: fields.reporter.emailAddress,\n          }\n        : undefined,\n      labels: fields.labels || [],\n      customFields: this.extractCustomFields(fields),\n      createdAt: new Date(fields.created),\n      updatedAt: new Date(fields.updated),\n      url: `${jiraIssue.self.split(\"/rest/\")[0]}/browse/${jiraIssue.key}`,\n    };\n  }\n\n  private extractDescription(description: any): string | undefined {\n    if (!description) return undefined;\n\n    // Handle ADF (Atlassian Document Format)\n    if (description.type === \"doc\" && description.content) {\n      return this.adfToHtml(description.content);\n    }\n\n    // Handle plain text\n    return description.toString();\n  }\n\n  private adfToHtml(content: any[]): string {\n    let html = \"\";\n\n    for (const node of content) {\n      html += this.convertAdfNodeToHtml(node);\n    }\n\n    return html.trim();\n  }\n\n  private convertAdfNodeToHtml(node: any): string {\n    if (!node) return \"\";\n\n    switch (node.type) {\n      case \"paragraph\":\n        let paragraphContent = \"\";\n        if (node.content) {\n          paragraphContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<p>${paragraphContent}</p>`;\n\n      case \"heading\":\n        let headingContent = \"\";\n        if (node.content) {\n          headingContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        const level = Math.min(node.attrs?.level || 1, 6);\n        return `<h${level}>${headingContent}</h${level}>`;\n\n      case \"bulletList\":\n        let bulletListContent = \"\";\n        if (node.content) {\n          bulletListContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<ul>${bulletListContent}</ul>`;\n\n      case \"orderedList\":\n        let orderedListContent = \"\";\n        if (node.content) {\n          orderedListContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<ol>${orderedListContent}</ol>`;\n\n      case \"listItem\":\n        let itemContent = \"\";\n        if (node.content) {\n          // For list items, we need to handle nested content properly\n          itemContent = node.content\n            .map((child: any) => {\n              // If it's a paragraph inside a list item, don't wrap it in <p> tags\n              if (child.type === \"paragraph\") {\n                return child.content\n                  ? child.content\n                      .map((grandChild: any) =>\n                        this.convertAdfNodeToHtml(grandChild)\n                      )\n                      .join(\"\")\n                  : \"\";\n              }\n              return this.convertAdfNodeToHtml(child);\n            })\n            .join(\"\");\n        }\n        return `<li>${itemContent}</li>`;\n\n      case \"blockquote\":\n        let quoteContent = \"\";\n        if (node.content) {\n          quoteContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<blockquote>${quoteContent}</blockquote>`;\n\n      case \"codeBlock\":\n        let codeContent = \"\";\n        if (node.content) {\n          codeContent = node.content\n            .map((child: any) => {\n              if (child.type === \"text\") {\n                return child.text || \"\";\n              }\n              return this.convertAdfNodeToHtml(child);\n            })\n            .join(\"\");\n        }\n        const language = node.attrs?.language || \"\";\n        return `<pre><code${language ? ` class=\"language-${language}\"` : \"\"}>${this.escapeHtml(codeContent)}</code></pre>`;\n\n      case \"text\":\n        let textContent = node.text || \"\";\n\n        // Escape HTML entities first\n        textContent = this.escapeHtml(textContent);\n\n        // Apply marks (formatting)\n        if (node.marks && Array.isArray(node.marks)) {\n          for (const mark of node.marks) {\n            switch (mark.type) {\n              case \"strong\":\n                textContent = `<strong>${textContent}</strong>`;\n                break;\n              case \"em\":\n                textContent = `<em>${textContent}</em>`;\n                break;\n              case \"underline\":\n                textContent = `<u>${textContent}</u>`;\n                break;\n              case \"strike\":\n                textContent = `<s>${textContent}</s>`;\n                break;\n              case \"code\":\n                textContent = `<code>${textContent}</code>`;\n                break;\n              case \"link\":\n                const href = this.escapeHtml(mark.attrs?.href || \"\");\n                textContent = `<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${textContent}</a>`;\n                break;\n            }\n          }\n        }\n\n        return textContent;\n\n      case \"hardBreak\":\n        return \"<br>\";\n\n      case \"rule\":\n        return \"<hr>\";\n\n      case \"mention\":\n        // Handle user mentions\n        const mentionText =\n          node.attrs?.text || node.attrs?.displayName || \"@user\";\n        return `<span class=\"mention\">${this.escapeHtml(mentionText)}</span>`;\n\n      case \"emoji\":\n        // Handle emojis\n        const emojiText = node.attrs?.shortName || node.attrs?.text || \"\";\n        return this.escapeHtml(emojiText);\n\n      case \"table\":\n        let tableContent = \"\";\n        if (node.content) {\n          tableContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<table>${tableContent}</table>`;\n\n      case \"tableRow\":\n        let rowContent = \"\";\n        if (node.content) {\n          rowContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        return `<tr>${rowContent}</tr>`;\n\n      case \"tableCell\":\n      case \"tableHeader\":\n        let cellContent = \"\";\n        if (node.content) {\n          cellContent = node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        const tag = node.type === \"tableHeader\" ? \"th\" : \"td\";\n        return `<${tag}>${cellContent}</${tag}>`;\n\n      default:\n        // For unknown types, try to extract content from children\n        if (node.content) {\n          return node.content\n            .map((child: any) => this.convertAdfNodeToHtml(child))\n            .join(\"\");\n        }\n        // If it has text directly, return it escaped\n        if (node.text) {\n          return this.escapeHtml(node.text);\n        }\n        return \"\";\n    }\n  }\n\n  private escapeHtml(text: string): string {\n    const map: { [key: string]: string } = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&#39;\",\n    };\n    return text.replace(/[&<>\"']/g, (m) => map[m]);\n  }\n\n  async getIssueTypes(\n    projectKey: string\n  ): Promise<Array<{ id: string; name: string }>> {\n    try {\n      // First, get the project details to get available issue types\n      const projectUrl = this.buildUrl(`/rest/api/3/project/${projectKey}`);\n      const project = await this.makeRequest<any>(projectUrl);\n\n      // Extract issue types from the project\n      const issueTypes = project.issueTypes || [];\n\n      return issueTypes.map((type: any) => ({\n        id: type.id,\n        name: type.name,\n      }));\n    } catch (error) {\n      console.error(\"Failed to fetch issue types:\", error);\n      // If that fails, try to get all issue types and filter by project\n      try {\n        const allTypesUrl = this.buildUrl(`/rest/api/3/issuetype`);\n        const allTypes = await this.makeRequest<any[]>(allTypesUrl);\n\n        // For now, return all non-subtask issue types as a fallback\n        return allTypes\n          .filter((type: any) => !type.subtask)\n          .map((type: any) => ({\n            id: type.id,\n            name: type.name,\n          }));\n      } catch (fallbackError) {\n        console.error(\"Failed to fetch issue types (fallback):\", fallbackError);\n        throw new Error(\"Failed to fetch issue types from Jira\");\n      }\n    }\n  }\n\n  async getIssueTypeFields(\n    projectKey: string,\n    issueTypeId: string\n  ): Promise<any[]> {\n    try {\n      // Get create issue metadata for the specific issue type\n      const url = this.buildUrl(\n        `/rest/api/3/issue/createmeta?projectKeys=${projectKey}&issuetypeIds=${issueTypeId}&expand=projects.issuetypes.fields`\n      );\n\n      const metadata = await this.makeRequest<any>(url);\n\n      // Extract fields from the response\n      const project = metadata.projects?.[0];\n      const issueType = project?.issuetypes?.[0];\n\n      if (!issueType?.fields) {\n        return [];\n      }\n\n      // Convert fields object to array and filter out system fields we handle separately\n      const fields = Object.entries(issueType.fields)\n        .filter(([key]) => {\n          // Exclude fields we already handle in the UI\n          const excludedFields = [\n            \"summary\",\n            \"description\",\n            \"issuetype\",\n            \"project\",\n            \"reporter\",\n          ];\n          return !excludedFields.includes(key);\n        })\n        .map(([key, field]: [string, any]) => ({\n          key,\n          name: field.name,\n          required: field.required || false,\n          schema: field.schema,\n          allowedValues: field.allowedValues,\n          hasDefaultValue: field.hasDefaultValue || false,\n          defaultValue: field.defaultValue,\n          autoCompleteUrl: field.autoCompleteUrl,\n        }));\n\n      return fields;\n    } catch (error) {\n      console.error(\"Failed to fetch issue type fields:\", error);\n      return [];\n    }\n  }\n\n  private extractCustomFields(fields: any): Record<string, any> {\n    const customFields: Record<string, any> = {};\n\n    // Extract fields that start with \"customfield_\"\n    for (const [key, value] of Object.entries(fields)) {\n      if (key.startsWith(\"customfield_\") && value !== null) {\n        customFields[key] = value;\n      }\n    }\n\n    return customFields;\n  }\n\n  private tiptapToAdf(tiptapJson: any): any {\n    // Convert TipTap JSON directly to Atlassian Document Format (ADF)\n    const doc: any = {\n      type: \"doc\",\n      version: 1,\n      content: [],\n    };\n\n    if (!tiptapJson || !tiptapJson.content) {\n      return doc;\n    }\n\n    // Process each node in the TipTap content\n    tiptapJson.content.forEach((node: any) => {\n      const adfNode = this.convertTiptapNodeToAdf(node);\n      if (adfNode) {\n        doc.content.push(adfNode);\n      }\n    });\n\n    // If no content was added, add empty paragraph\n    if (doc.content.length === 0) {\n      doc.content.push({\n        type: \"paragraph\",\n        content: [],\n      });\n    }\n\n    return doc;\n  }\n\n  private convertTiptapNodeToAdf(node: any): any {\n    if (!node) return null;\n\n    switch (node.type) {\n      case \"paragraph\":\n        return {\n          type: \"paragraph\",\n          content: this.convertTiptapMarks(node.content || []),\n        };\n\n      case \"heading\":\n        return {\n          type: \"heading\",\n          attrs: {\n            level: node.attrs?.level || 1,\n          },\n          content: this.convertTiptapMarks(node.content || []),\n        };\n\n      case \"bulletList\":\n        return {\n          type: \"bulletList\",\n          content: (node.content || [])\n            .map((item: any) => this.convertTiptapNodeToAdf(item))\n            .filter(Boolean),\n        };\n\n      case \"orderedList\":\n        return {\n          type: \"orderedList\",\n          content: (node.content || [])\n            .map((item: any) => this.convertTiptapNodeToAdf(item))\n            .filter(Boolean),\n        };\n\n      case \"listItem\":\n        return {\n          type: \"listItem\",\n          content: (node.content || [])\n            .map((item: any) => this.convertTiptapNodeToAdf(item))\n            .filter(Boolean),\n        };\n\n      case \"blockquote\":\n        return {\n          type: \"blockquote\",\n          content: (node.content || [])\n            .map((item: any) => this.convertTiptapNodeToAdf(item))\n            .filter(Boolean),\n        };\n\n      case \"codeBlock\":\n        return {\n          type: \"codeBlock\",\n          attrs: {\n            language: node.attrs?.language || null,\n          },\n          content: [\n            {\n              type: \"text\",\n              text: node.content?.map((c: any) => c.text || \"\").join(\"\") || \"\",\n            },\n          ],\n        };\n\n      case \"horizontalRule\":\n        return {\n          type: \"rule\",\n        };\n\n      case \"hardBreak\":\n        return {\n          type: \"hardBreak\",\n        };\n\n      case \"text\":\n        // Text nodes are handled by convertTiptapMarks\n        return null;\n\n      default:\n        // For unknown types, try to extract text content\n        if (node.content) {\n          return {\n            type: \"paragraph\",\n            content: this.convertTiptapMarks(node.content),\n          };\n        }\n        return null;\n    }\n  }\n\n  private convertTiptapMarks(content: any[]): any[] {\n    if (!content || !Array.isArray(content)) return [];\n\n    const result: any[] = [];\n\n    content.forEach((node: any) => {\n      if (node.type === \"text\") {\n        const textNode: any = {\n          type: \"text\",\n          text: node.text || \"\",\n        };\n\n        // Convert TipTap marks to ADF marks\n        if (node.marks && Array.isArray(node.marks)) {\n          const adfMarks: any[] = [];\n\n          node.marks.forEach((mark: any) => {\n            switch (mark.type) {\n              case \"bold\":\n              case \"strong\":\n                adfMarks.push({ type: \"strong\" });\n                break;\n              case \"italic\":\n              case \"em\":\n                adfMarks.push({ type: \"em\" });\n                break;\n              case \"underline\":\n                adfMarks.push({ type: \"underline\" });\n                break;\n              case \"strike\":\n                adfMarks.push({ type: \"strike\" });\n                break;\n              case \"code\":\n                adfMarks.push({ type: \"code\" });\n                break;\n              case \"link\":\n                adfMarks.push({\n                  type: \"link\",\n                  attrs: {\n                    href: mark.attrs?.href || \"\",\n                  },\n                });\n                break;\n            }\n          });\n\n          if (adfMarks.length > 0) {\n            textNode.marks = adfMarks;\n          }\n        }\n\n        result.push(textNode);\n      } else {\n        // Handle nested nodes\n        const converted = this.convertTiptapNodeToAdf(node);\n        if (converted) {\n          result.push(converted);\n        }\n      }\n    });\n\n    return result;\n  }\n\n  private htmlToAdf(html: string): any {\n    // Enhanced HTML to ADF conversion for TipTap output\n    const doc: any = {\n      type: \"doc\",\n      version: 1,\n      content: [],\n    };\n\n    // Parse HTML more carefully to preserve formatting\n    // Split by paragraphs first\n    const paragraphs = html.split(/<\\/p>|<\\/h[1-6]>|<\\/li>|<\\/blockquote>/);\n\n    paragraphs.forEach((paragraph) => {\n      if (!paragraph.trim()) return;\n\n      // Handle headings\n      const headingMatch = paragraph.match(/<h([1-6])>/);\n      if (headingMatch) {\n        const level = parseInt(headingMatch[1]);\n        const text = paragraph.replace(/<[^>]*>/g, \"\").trim();\n        if (text) {\n          doc.content.push({\n            type: \"heading\",\n            attrs: { level: Math.min(level, 6) },\n            content: [\n              {\n                type: \"text\",\n                text: text,\n              },\n            ],\n          });\n        }\n        return;\n      }\n\n      // Handle lists\n      if (paragraph.includes(\"<ul>\") || paragraph.includes(\"<ol>\")) {\n        const listType = paragraph.includes(\"<ul>\")\n          ? \"bulletList\"\n          : \"orderedList\";\n        const listItems = paragraph.split(/<\\/li>/);\n        const listContent: any[] = [];\n\n        listItems.forEach((item) => {\n          const itemText = item.replace(/<[^>]*>/g, \"\").trim();\n          if (itemText) {\n            listContent.push({\n              type: \"listItem\",\n              content: [\n                {\n                  type: \"paragraph\",\n                  content: [\n                    {\n                      type: \"text\",\n                      text: itemText,\n                    },\n                  ],\n                },\n              ],\n            });\n          }\n        });\n\n        if (listContent.length > 0) {\n          doc.content.push({\n            type: listType,\n            content: listContent,\n          });\n        }\n        return;\n      }\n\n      // Handle blockquotes\n      if (paragraph.includes(\"<blockquote>\")) {\n        const text = paragraph.replace(/<[^>]*>/g, \"\").trim();\n        if (text) {\n          doc.content.push({\n            type: \"blockquote\",\n            content: [\n              {\n                type: \"paragraph\",\n                content: [\n                  {\n                    type: \"text\",\n                    text: text,\n                  },\n                ],\n              },\n            ],\n          });\n        }\n        return;\n      }\n\n      // Handle regular paragraphs with inline formatting\n      const cleanedParagraph = paragraph.replace(/<p[^>]*>/, \"\");\n      if (!cleanedParagraph.trim()) return;\n\n      const paragraphContent: any[] = [];\n      let remainingText = cleanedParagraph;\n\n      // Process inline formatting\n      while (remainingText.length > 0) {\n        // Check for bold\n        const boldMatch = remainingText.match(\n          /<(strong|b)>(.*?)<\\/(strong|b)>/\n        );\n        if (boldMatch) {\n          const beforeText = remainingText\n            .substring(0, boldMatch.index)\n            .replace(/<[^>]*>/g, \"\");\n          if (beforeText) {\n            paragraphContent.push({ type: \"text\", text: beforeText });\n          }\n          paragraphContent.push({\n            type: \"text\",\n            text: boldMatch[2],\n            marks: [{ type: \"strong\" }],\n          });\n          remainingText = remainingText.substring(\n            boldMatch.index! + boldMatch[0].length\n          );\n          continue;\n        }\n\n        // Check for italic\n        const italicMatch = remainingText.match(/<(em|i)>(.*?)<\\/(em|i)>/);\n        if (italicMatch) {\n          const beforeText = remainingText\n            .substring(0, italicMatch.index)\n            .replace(/<[^>]*>/g, \"\");\n          if (beforeText) {\n            paragraphContent.push({ type: \"text\", text: beforeText });\n          }\n          paragraphContent.push({\n            type: \"text\",\n            text: italicMatch[2],\n            marks: [{ type: \"em\" }],\n          });\n          remainingText = remainingText.substring(\n            italicMatch.index! + italicMatch[0].length\n          );\n          continue;\n        }\n\n        // Check for underline\n        const underlineMatch = remainingText.match(/<u>(.*?)<\\/u>/);\n        if (underlineMatch) {\n          const beforeText = remainingText\n            .substring(0, underlineMatch.index)\n            .replace(/<[^>]*>/g, \"\");\n          if (beforeText) {\n            paragraphContent.push({ type: \"text\", text: beforeText });\n          }\n          paragraphContent.push({\n            type: \"text\",\n            text: underlineMatch[1],\n            marks: [{ type: \"underline\" }],\n          });\n          remainingText = remainingText.substring(\n            underlineMatch.index! + underlineMatch[0].length\n          );\n          continue;\n        }\n\n        // Check for code\n        const codeMatch = remainingText.match(/<code>(.*?)<\\/code>/);\n        if (codeMatch) {\n          const beforeText = remainingText\n            .substring(0, codeMatch.index)\n            .replace(/<[^>]*>/g, \"\");\n          if (beforeText) {\n            paragraphContent.push({ type: \"text\", text: beforeText });\n          }\n          paragraphContent.push({\n            type: \"text\",\n            text: codeMatch[1],\n            marks: [{ type: \"code\" }],\n          });\n          remainingText = remainingText.substring(\n            codeMatch.index! + codeMatch[0].length\n          );\n          continue;\n        }\n\n        // No more formatting, add the rest as plain text\n        const plainText = remainingText.replace(/<[^>]*>/g, \"\").trim();\n        if (plainText) {\n          paragraphContent.push({ type: \"text\", text: plainText });\n        }\n        break;\n      }\n\n      if (paragraphContent.length > 0) {\n        doc.content.push({\n          type: \"paragraph\",\n          content: paragraphContent,\n        });\n      }\n    });\n\n    // If no content was added, add empty paragraph\n    if (doc.content.length === 0) {\n      doc.content.push({\n        type: \"paragraph\",\n        content: [],\n      });\n    }\n\n    return doc;\n  }\n\n  async searchUsers(\n    query: string,\n    projectKey?: string,\n    startAt: number = 0,\n    maxResults: number = 50\n  ): Promise<\n    | Array<{\n        accountId: string;\n        displayName: string;\n        emailAddress?: string;\n        avatarUrls?: any;\n      }>\n    | {\n        users: Array<{\n          accountId: string;\n          displayName: string;\n          emailAddress?: string;\n          avatarUrls?: any;\n        }>;\n        total: number;\n      }\n  > {\n    try {\n      // console.log(`[JiraAdapter.searchUsers] Query: \"${query}\", ProjectKey: \"${projectKey}\", StartAt: ${startAt}, MaxResults: ${maxResults}`);\n\n      // Check if query looks like an email address\n      const isEmail = query.includes(\"@\");\n      // console.log(`[JiraAdapter.searchUsers] Is email search: ${isEmail}`);\n\n      // Try multiple search approaches for better user matching\n      const allUsers: any[] = [];\n\n      // 1. First try email search if it's an email\n      if (isEmail) {\n        try {\n          // Try the user/search endpoint with email\n          const emailSearchUrl = this.buildUrl(\n            `/rest/api/3/user/search?query=${encodeURIComponent(query)}&startAt=${startAt}&maxResults=${maxResults}`\n          );\n          // console.log(`[JiraAdapter.searchUsers] Trying email search: ${emailSearchUrl}`);\n          const emailUsers = await this.makeRequest<any[]>(emailSearchUrl);\n          allUsers.push(...emailUsers);\n\n          // Also try searching by accountId with the email (sometimes works)\n          const accountSearchUrl = this.buildUrl(\n            `/rest/api/3/user/search?accountId=${encodeURIComponent(query)}`\n          );\n          // console.log(`[JiraAdapter.searchUsers] Trying account search with email: ${accountSearchUrl}`);\n          try {\n            const accountUsers =\n              await this.makeRequest<any[]>(accountSearchUrl);\n            allUsers.push(...accountUsers);\n          } catch (e) {\n            // This might fail, that's ok\n            // console.log(`[JiraAdapter.searchUsers] Account search failed (expected): ${e}`);\n          }\n        } catch (error) {\n          // console.log(`[JiraAdapter.searchUsers] Email search error: ${error}`);\n        }\n      }\n\n      // 2. Try general search\n      let endpoint: string;\n      if (projectKey && !isEmail) {\n        // Search assignable users for the project\n        endpoint = `/rest/api/3/user/assignable/search?project=${projectKey}&query=${encodeURIComponent(query)}&startAt=${startAt}&maxResults=${maxResults}`;\n      } else {\n        // General user search\n        endpoint = `/rest/api/3/user/search?query=${encodeURIComponent(query)}&startAt=${startAt}&maxResults=${maxResults}`;\n      }\n\n      // console.log(`[JiraAdapter.searchUsers] Using general endpoint: ${endpoint}`);\n      const url = this.buildUrl(endpoint);\n      const generalUsers = await this.makeRequest<any[]>(url);\n      allUsers.push(...generalUsers);\n\n      // Deduplicate users by accountId\n      const uniqueUsers = new Map<string, any>();\n      allUsers.forEach((user) => {\n        if (user.accountId && !uniqueUsers.has(user.accountId)) {\n          uniqueUsers.set(user.accountId, user);\n        }\n      });\n\n      const users = Array.from(uniqueUsers.values());\n      // console.log(`[JiraAdapter.searchUsers] Total unique users found: ${users.length}`);\n\n      const mappedUsers = users.map((user: any) => {\n        const mapped = {\n          accountId: user.accountId,\n          displayName: user.displayName,\n          emailAddress: user.emailAddress,\n          avatarUrls: user.avatarUrls,\n        };\n        // console.log(`[JiraAdapter.searchUsers] User: ${mapped.displayName} (${mapped.accountId}) - Email: ${mapped.emailAddress || 'NOT AVAILABLE'}`);\n        return mapped;\n      });\n\n      // Return paginated result with total\n      // Jira doesn't return total, so we estimate: if we got fewer than maxResults, we're at the end\n      // Otherwise, assume there might be more pages\n      const hasMore = mappedUsers.length >= maxResults;\n      const estimatedTotal = hasMore\n        ? startAt + mappedUsers.length + 1\n        : startAt + mappedUsers.length;\n\n      return {\n        users: mappedUsers,\n        total: estimatedTotal,\n      };\n    } catch (error) {\n      console.error(\"[JiraAdapter.searchUsers] Failed to search users:\", error);\n      return { users: [], total: 0 };\n    }\n  }\n\n  async getCurrentUser(): Promise<{\n    accountId: string;\n    displayName: string;\n    emailAddress?: string;\n  } | null> {\n    try {\n      // console.log(`[JiraAdapter.getCurrentUser] Getting current authenticated user`);\n      const url = this.buildUrl(\"/rest/api/3/myself\");\n      const user = await this.makeRequest<any>(url);\n\n      // console.log(`[JiraAdapter.getCurrentUser] Current user: ${user.displayName} (${user.accountId}) - Email: ${user.emailAddress || 'NOT AVAILABLE'}`);\n\n      return {\n        accountId: user.accountId,\n        displayName: user.displayName,\n        emailAddress: user.emailAddress,\n      };\n    } catch (error) {\n      console.error(\n        \"[JiraAdapter.getCurrentUser] Failed to get current user:\",\n        error\n      );\n      return null;\n    }\n  }\n}\n", "import { BaseAdapter } from \"./BaseAdapter\";\nimport {\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n} from \"./IssueAdapter\";\n\n/**\n * GitHub integration adapter using Personal Access Token authentication\n */\nexport class GitHubAdapter extends BaseAdapter {\n  private owner?: string;\n  private repo?: string;\n  private baseUrl = \"https://api.github.com\";\n\n  constructor(config: any) {\n    super(config);\n\n    // GitHub repository can be specified in settings\n    if (config.repository) {\n      const [owner, repo] = config.repository.split(\"/\");\n      this.owner = owner;\n      this.repo = repo;\n    }\n  }\n\n  getCapabilities(): IssueAdapterCapabilities {\n    return {\n      createIssue: true,\n      updateIssue: true,\n      linkIssue: true,\n      syncIssue: true,\n      searchIssues: true,\n      webhooks: true,\n      customFields: false, // GitHub doesn't have custom fields like Jira\n      attachments: false, // GitHub doesn't support direct attachments on issues\n    };\n  }\n\n  protected async performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void> {\n    if (authData.type !== \"api_key\") {\n      throw new Error(\n        \"GitHub adapter only supports Personal Access Token authentication\"\n      );\n    }\n\n    if (!authData.apiKey) {\n      throw new Error(\n        \"Personal Access Token is required for GitHub authentication\"\n      );\n    }\n\n    // Validate the token by making a test request\n    try {\n      await this.makeRequest(`${this.baseUrl}/user`);\n    } catch (error) {\n      throw new Error(\"Invalid GitHub Personal Access Token\");\n    }\n  }\n\n  protected buildUrl(path: string): string {\n    if (path.startsWith(\"/repos/\") && this.owner && this.repo) {\n      // Replace placeholder with actual owner/repo\n      return `${this.baseUrl}${path.replace(\"{owner}/{repo}\", `${this.owner}/${this.repo}`)}`;\n    }\n    return `${this.baseUrl}${path}`;\n  }\n\n  async createIssue(data: CreateIssueData): Promise<IssueData> {\n    // Ensure we have owner/repo from either config or projectId\n    if (!this.owner || !this.repo) {\n      if (data.projectId.includes(\"/\")) {\n        const [owner, repo] = data.projectId.split(\"/\");\n        this.owner = owner;\n        this.repo = repo;\n      } else {\n        throw new Error(\n          \"GitHub repository not configured. Expected format: owner/repo\"\n        );\n      }\n    }\n\n    const githubPayload = {\n      title: data.title,\n      body: data.description || \"\",\n      labels: data.labels || [],\n      assignees: data.assigneeId ? [data.assigneeId] : undefined,\n    };\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/repos/{owner}/{repo}/issues`),\n      {\n        method: \"POST\",\n        body: JSON.stringify(githubPayload),\n      }\n    );\n\n    return this.mapGitHubIssue(response);\n  }\n\n  async updateIssue(\n    issueId: string,\n    data: UpdateIssueData\n  ): Promise<IssueData> {\n    const updatePayload: any = {};\n\n    if (data.title !== undefined) {\n      updatePayload.title = data.title;\n    }\n\n    if (data.description !== undefined) {\n      updatePayload.body = data.description;\n    }\n\n    if (data.status !== undefined) {\n      updatePayload.state = this.mapStatusToGitHub(data.status);\n    }\n\n    if (data.labels !== undefined) {\n      updatePayload.labels = data.labels;\n    }\n\n    if (data.assigneeId !== undefined) {\n      updatePayload.assignees = [data.assigneeId];\n    }\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/repos/{owner}/{repo}/issues/${issueId}`),\n      {\n        method: \"PATCH\",\n        body: JSON.stringify(updatePayload),\n      }\n    );\n\n    return this.mapGitHubIssue(response);\n  }\n\n  async getIssue(issueId: string): Promise<IssueData> {\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/repos/{owner}/{repo}/issues/${issueId}`)\n    );\n\n    return this.mapGitHubIssue(response);\n  }\n\n  async searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const searchQuery: string[] = [];\n\n    // Add repo filter\n    if (this.owner && this.repo) {\n      searchQuery.push(`repo:${this.owner}/${this.repo}`);\n    } else if (options.projectId) {\n      searchQuery.push(`repo:${options.projectId}`);\n    }\n\n    // Add search query\n    if (options.query) {\n      searchQuery.push(options.query);\n    }\n\n    // Add status filter\n    if (options.status && options.status.length > 0) {\n      const states = options.status.map((s) => this.mapStatusToGitHub(s));\n      searchQuery.push(`is:${states.join(\" is:\")}`);\n    }\n\n    // Add assignee filter\n    if (options.assignee) {\n      searchQuery.push(`assignee:${options.assignee}`);\n    }\n\n    // Add label filter\n    if (options.labels && options.labels.length > 0) {\n      searchQuery.push(options.labels.map((l) => `label:\"${l}\"`).join(\" \"));\n    }\n\n    const params = new URLSearchParams({\n      q: searchQuery.join(\" \") || \"is:issue\",\n      per_page: (options.limit || 30).toString(),\n      page: Math.floor(\n        (options.offset || 0) / (options.limit || 30) + 1\n      ).toString(),\n      sort: \"created\",\n      order: \"desc\",\n    });\n\n    const response = await this.makeRequest<any>(\n      `${this.baseUrl}/search/issues?${params.toString()}`\n    );\n\n    return {\n      issues: response.items.map((issue: any) => this.mapGitHubIssue(issue)),\n      total: response.total_count,\n      hasMore:\n        response.incomplete_results ||\n        response.total_count > (options.offset || 0) + response.items.length,\n    };\n  }\n\n  protected async addComment(issueId: string, comment: string): Promise<void> {\n    await this.makeRequest(\n      this.buildUrl(`/repos/{owner}/{repo}/issues/${issueId}/comments`),\n      {\n        method: \"POST\",\n        body: JSON.stringify({ body: comment }),\n      }\n    );\n  }\n\n  /**\n   * Get available repositories for the authenticated user\n   */\n  async getProjects(): Promise<\n    Array<{ id: string; key: string; name: string }>\n  > {\n    const repos = await this.makeRequest<any[]>(\n      `${this.baseUrl}/user/repos?per_page=100&sort=updated`\n    );\n\n    return repos.map((repo) => ({\n      id: repo.full_name,\n      key: repo.name,\n      name: repo.full_name,\n    }));\n  }\n\n  /**\n   * Get available labels for a repository\n   */\n  async getLabels(): Promise<\n    Array<{ id: string; name: string; color: string }>\n  > {\n    if (!this.owner || !this.repo) {\n      throw new Error(\"Repository not configured\");\n    }\n\n    const labels = await this.makeRequest<any[]>(\n      this.buildUrl(`/repos/{owner}/{repo}/labels`)\n    );\n\n    return labels.map((label) => ({\n      id: label.name,\n      name: label.name,\n      color: label.color,\n    }));\n  }\n\n  /**\n   * Get available milestones for a repository\n   */\n  async getMilestones(): Promise<\n    Array<{ id: string; title: string; state: string }>\n  > {\n    if (!this.owner || !this.repo) {\n      throw new Error(\"Repository not configured\");\n    }\n\n    const milestones = await this.makeRequest<any[]>(\n      this.buildUrl(`/repos/{owner}/{repo}/milestones`)\n    );\n\n    return milestones.map((milestone) => ({\n      id: milestone.number.toString(),\n      title: milestone.title,\n      state: milestone.state,\n    }));\n  }\n\n  private mapStatusToGitHub(status: string): string {\n    const lowerStatus = status.toLowerCase();\n    if (\n      lowerStatus === \"closed\" ||\n      lowerStatus === \"done\" ||\n      lowerStatus === \"resolved\"\n    ) {\n      return \"closed\";\n    }\n    return \"open\";\n  }\n\n  private mapGitHubIssue(githubIssue: any): IssueData {\n    return {\n      id: githubIssue.number.toString(),\n      key: `#${githubIssue.number}`,\n      title: githubIssue.title,\n      description: githubIssue.body,\n      status: githubIssue.state,\n      priority: undefined, // GitHub doesn't have priority\n      assignee: githubIssue.assignee\n        ? {\n            id: githubIssue.assignee.login,\n            name: githubIssue.assignee.login,\n            email: githubIssue.assignee.email,\n          }\n        : undefined,\n      reporter: githubIssue.user\n        ? {\n            id: githubIssue.user.login,\n            name: githubIssue.user.login,\n            email: githubIssue.user.email,\n          }\n        : undefined,\n      labels: githubIssue.labels.map((label: any) => label.name),\n      customFields: {},\n      createdAt: new Date(githubIssue.created_at),\n      updatedAt: new Date(githubIssue.updated_at),\n      url: githubIssue.html_url,\n    };\n  }\n\n  async linkToTestCase(\n    issueId: string,\n    testCaseId: string,\n    metadata?: any\n  ): Promise<void> {\n    const comment = `Linked to test case: ${testCaseId}${\n      metadata ? `\\n\\nMetadata: ${JSON.stringify(metadata, null, 2)}` : \"\"\n    }`;\n    await this.addComment(issueId, comment);\n  }\n\n  async syncIssue(issueId: string): Promise<IssueData> {\n    return this.getIssue(issueId);\n  }\n}\n", "import { BaseAdapter } from \"./BaseAdapter\";\nimport {\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n} from \"./IssueAdapter\";\n\n/**\n * Azure DevOps integration adapter using Personal Access Token authentication\n */\nexport class AzureDevOpsAdapter extends BaseAdapter {\n  private organizationUrl?: string;\n  private project?: string;\n  private apiVersion = \"7.0\";\n\n  constructor(config: any) {\n    super(config);\n\n    // Azure DevOps configuration from settings\n    this.organizationUrl = config.organizationUrl;\n    this.project = config.project;\n  }\n\n  getCapabilities(): IssueAdapterCapabilities {\n    return {\n      createIssue: true,\n      updateIssue: true,\n      linkIssue: true,\n      syncIssue: true,\n      searchIssues: true,\n      webhooks: true,\n      customFields: true,\n      attachments: true,\n    };\n  }\n\n  protected async performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void> {\n    if (authData.type !== \"api_key\") {\n      throw new Error(\n        \"Azure DevOps adapter only supports Personal Access Token authentication\"\n      );\n    }\n\n    if (!authData.apiKey) {\n      throw new Error(\n        \"Personal Access Token is required for Azure DevOps authentication\"\n      );\n    }\n\n    if (!this.organizationUrl) {\n      throw new Error(\"Organization URL is required for Azure DevOps\");\n    }\n\n    // Validate the token by making a test request\n    try {\n      await this.makeRequest(\n        `${this.organizationUrl}/_apis/projects?api-version=${this.apiVersion}`\n      );\n    } catch (error) {\n      throw new Error(\n        \"Invalid Azure DevOps Personal Access Token or Organization URL\"\n      );\n    }\n  }\n\n  protected buildUrl(path: string): string {\n    if (!this.organizationUrl) {\n      throw new Error(\"Organization URL not configured\");\n    }\n\n    // Handle project-specific paths\n    if (path.includes(\"{project}\") && this.project) {\n      path = path.replace(\"{project}\", encodeURIComponent(this.project));\n    }\n\n    return `${this.organizationUrl}${path}`;\n  }\n\n  async createIssue(data: CreateIssueData): Promise<IssueData> {\n    // Ensure we have a project\n    if (!this.project && data.projectId) {\n      this.project = data.projectId;\n    }\n\n    if (!this.project) {\n      throw new Error(\"Azure DevOps project not configured\");\n    }\n\n    // Build work item patch document\n    const patchDocument = [\n      {\n        op: \"add\",\n        path: \"/fields/System.Title\",\n        value: data.title,\n      },\n    ];\n\n    if (data.description) {\n      // Convert TipTap JSON to HTML if needed\n      let descriptionValue: string;\n      if (typeof data.description === 'object' && data.description && 'type' in data.description && data.description.type === 'doc') {\n        // For now, extract plain text from TipTap JSON\n        // Azure DevOps expects HTML or plain text\n        descriptionValue = this.extractTextFromTiptap(data.description);\n      } else {\n        descriptionValue = data.description as string;\n      }\n      \n      patchDocument.push({\n        op: \"add\",\n        path: \"/fields/System.Description\",\n        value: descriptionValue,\n      });\n    }\n\n    if (data.priority) {\n      patchDocument.push({\n        op: \"add\",\n        path: \"/fields/Microsoft.VSTS.Common.Priority\",\n        value: parseInt(data.priority),\n      } as any);\n    }\n\n    if (data.assigneeId) {\n      patchDocument.push({\n        op: \"add\",\n        path: \"/fields/System.AssignedTo\",\n        value: data.assigneeId,\n      });\n    }\n\n    if (data.labels && data.labels.length > 0) {\n      patchDocument.push({\n        op: \"add\",\n        path: \"/fields/System.Tags\",\n        value: data.labels.join(\"; \"),\n      });\n    }\n\n    // Add custom fields\n    if (data.customFields) {\n      for (const [field, value] of Object.entries(data.customFields)) {\n        patchDocument.push({\n          op: \"add\",\n          path: `/fields/${field}`,\n          value: value,\n        });\n      }\n    }\n\n    const workItemType = data.issueType || \"Bug\";\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/{project}/_apis/wit/workitems/$${workItemType}?api-version=${this.apiVersion}`\n      ),\n      {\n        method: \"POST\",\n        body: JSON.stringify(patchDocument),\n        headers: {\n          \"Content-Type\": \"application/json-patch+json\",\n        },\n      }\n    );\n\n    return this.mapAzureDevOpsWorkItem(response);\n  }\n\n  async updateIssue(\n    issueId: string,\n    data: UpdateIssueData\n  ): Promise<IssueData> {\n    const patchDocument = [];\n\n    if (data.title !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.Title\",\n        value: data.title,\n      });\n    }\n\n    if (data.description !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.Description\",\n        value: data.description,\n      });\n    }\n\n    if (data.status !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.State\",\n        value: data.status,\n      });\n    }\n\n    if (data.priority !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/Microsoft.VSTS.Common.Priority\",\n        value: parseInt(data.priority),\n      } as any);\n    }\n\n    if (data.assigneeId !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.AssignedTo\",\n        value: data.assigneeId,\n      });\n    }\n\n    if (data.labels !== undefined) {\n      patchDocument.push({\n        op: \"replace\",\n        path: \"/fields/System.Tags\",\n        value: data.labels.join(\"; \"),\n      });\n    }\n\n    // Update custom fields\n    if (data.customFields) {\n      for (const [field, value] of Object.entries(data.customFields)) {\n        patchDocument.push({\n          op: \"replace\",\n          path: `/fields/${field}`,\n          value: value,\n        });\n      }\n    }\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/workitems/${issueId}?api-version=${this.apiVersion}`\n      ),\n      {\n        method: \"PATCH\",\n        body: JSON.stringify(patchDocument),\n        headers: {\n          \"Content-Type\": \"application/json-patch+json\",\n        },\n      }\n    );\n\n    return this.mapAzureDevOpsWorkItem(response);\n  }\n\n  async getIssue(issueId: string): Promise<IssueData> {\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/workitems/${issueId}?api-version=${this.apiVersion}&$expand=all`\n      )\n    );\n\n    return this.mapAzureDevOpsWorkItem(response);\n  }\n\n  async searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    // Build WIQL query\n    const conditions: string[] = [];\n\n    if (this.project) {\n      conditions.push(`[System.TeamProject] = '${this.project}'`);\n    } else if (options.projectId) {\n      conditions.push(`[System.TeamProject] = '${options.projectId}'`);\n    }\n\n    if (options.query) {\n      conditions.push(\n        `([System.Title] CONTAINS '${options.query}' OR [System.Description] CONTAINS '${options.query}')`\n      );\n    }\n\n    if (options.status && options.status.length > 0) {\n      const statusCondition = options.status\n        .map((s) => `[System.State] = '${s}'`)\n        .join(\" OR \");\n      conditions.push(`(${statusCondition})`);\n    }\n\n    if (options.assignee) {\n      conditions.push(`[System.AssignedTo] = '${options.assignee}'`);\n    }\n\n    if (options.labels && options.labels.length > 0) {\n      const labelConditions = options.labels.map(\n        (l) => `[System.Tags] CONTAINS '${l}'`\n      );\n      conditions.push(`(${labelConditions.join(\" OR \")})`);\n    }\n\n    const whereClause =\n      conditions.length > 0 ? `WHERE ${conditions.join(\" AND \")}` : \"\";\n    const wiql = `SELECT [System.Id] FROM WorkItems ${whereClause} ORDER BY [System.CreatedDate] DESC`;\n\n    const wiqlResponse = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/wiql?api-version=${this.apiVersion}&$top=${options.limit || 200}`\n      ),\n      {\n        method: \"POST\",\n        body: JSON.stringify({ query: wiql }),\n      }\n    );\n\n    if (!wiqlResponse.workItems || wiqlResponse.workItems.length === 0) {\n      return {\n        issues: [],\n        total: 0,\n        hasMore: false,\n      };\n    }\n\n    // Get the work items details\n    const ids = wiqlResponse.workItems\n      .slice(options.offset || 0, (options.offset || 0) + (options.limit || 50))\n      .map((item: any) => item.id);\n\n    if (ids.length === 0) {\n      return {\n        issues: [],\n        total: wiqlResponse.workItems.length,\n        hasMore: false,\n      };\n    }\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/workitems?ids=${ids.join(\",\")}&api-version=${this.apiVersion}&$expand=all`\n      )\n    );\n\n    return {\n      issues: response.value.map((item: any) =>\n        this.mapAzureDevOpsWorkItem(item)\n      ),\n      total: wiqlResponse.workItems.length,\n      hasMore:\n        (options.offset || 0) + ids.length < wiqlResponse.workItems.length,\n    };\n  }\n\n  protected async addComment(issueId: string, comment: string): Promise<void> {\n    await this.makeRequest(\n      this.buildUrl(\n        `/_apis/wit/workitems/${issueId}/comments?api-version=${this.apiVersion}-preview`\n      ),\n      {\n        method: \"POST\",\n        body: JSON.stringify({ text: comment }),\n      }\n    );\n  }\n\n  /**\n   * Get available projects\n   */\n  async getProjects(): Promise<\n    Array<{ id: string; key: string; name: string }>\n  > {\n    const response = await this.makeRequest<any>(\n      this.buildUrl(`/_apis/projects?api-version=${this.apiVersion}`)\n    );\n\n    return response.value.map((project: any) => ({\n      id: project.id,\n      key: project.name,\n      name: project.name,\n    }));\n  }\n\n  /**\n   * Get work item types for a project\n   */\n  async getIssueTypes(\n    projectId: string\n  ): Promise<Array<{ id: string; name: string }>> {\n    const project = projectId || this.project;\n    if (!project) {\n      throw new Error(\"Project not specified\");\n    }\n\n    const response = await this.makeRequest<any>(\n      this.buildUrl(\n        `/${project}/_apis/wit/workitemtypes?api-version=${this.apiVersion}`\n      )\n    );\n\n    return response.value.map((type: any) => ({\n      id: type.name,\n      name: type.name,\n    }));\n  }\n\n  /**\n   * Get available states for work items\n   */\n  async getStatuses(): Promise<Array<{ id: string; name: string }>> {\n    // Azure DevOps states are defined per work item type and process\n    // Return common states\n    return [\n      { id: \"New\", name: \"New\" },\n      { id: \"Active\", name: \"Active\" },\n      { id: \"Resolved\", name: \"Resolved\" },\n      { id: \"Closed\", name: \"Closed\" },\n      { id: \"Removed\", name: \"Removed\" },\n    ];\n  }\n\n  /**\n   * Get priorities\n   */\n  async getPriorities(): Promise<Array<{ id: string; name: string }>> {\n    return [\n      { id: \"1\", name: \"1 - Critical\" },\n      { id: \"2\", name: \"2 - High\" },\n      { id: \"3\", name: \"3 - Medium\" },\n      { id: \"4\", name: \"4 - Low\" },\n    ];\n  }\n\n  /**\n   * Upload attachment to a work item\n   */\n  async uploadAttachment(\n    issueId: string,\n    file: Buffer,\n    filename: string\n  ): Promise<{ id: string; url: string }> {\n    // First, upload the attachment\n    const uploadResponse = await this.makeRequest<any>(\n      this.buildUrl(\n        `/_apis/wit/attachments?fileName=${encodeURIComponent(filename)}&api-version=${this.apiVersion}`\n      ),\n      {\n        method: \"POST\",\n        body: file as any,\n        headers: {\n          \"Content-Type\": \"application/octet-stream\",\n        },\n      }\n    );\n\n    // Then, link it to the work item\n    const patchDocument = [\n      {\n        op: \"add\",\n        path: \"/relations/-\",\n        value: {\n          rel: \"AttachedFile\",\n          url: uploadResponse.url,\n        },\n      },\n    ];\n\n    await this.makeRequest(\n      this.buildUrl(\n        `/_apis/wit/workitems/${issueId}?api-version=${this.apiVersion}`\n      ),\n      {\n        method: \"PATCH\",\n        body: JSON.stringify(patchDocument),\n        headers: {\n          \"Content-Type\": \"application/json-patch+json\",\n        },\n      }\n    );\n\n    return {\n      id: uploadResponse.id,\n      url: uploadResponse.url,\n    };\n  }\n\n  private mapAzureDevOpsWorkItem(workItem: any): IssueData {\n    const fields = workItem.fields;\n\n    return {\n      id: workItem.id.toString(),\n      key: workItem.id.toString(),\n      title: fields[\"System.Title\"],\n      description: fields[\"System.Description\"],\n      status: fields[\"System.State\"],\n      priority: fields[\"Microsoft.VSTS.Common.Priority\"]?.toString(),\n      assignee: fields[\"System.AssignedTo\"]\n        ? {\n            id:\n              fields[\"System.AssignedTo\"].uniqueName ||\n              fields[\"System.AssignedTo\"],\n            name:\n              fields[\"System.AssignedTo\"].displayName ||\n              fields[\"System.AssignedTo\"],\n            email: fields[\"System.AssignedTo\"].uniqueName,\n          }\n        : undefined,\n      reporter: fields[\"System.CreatedBy\"]\n        ? {\n            id:\n              fields[\"System.CreatedBy\"].uniqueName ||\n              fields[\"System.CreatedBy\"],\n            name:\n              fields[\"System.CreatedBy\"].displayName ||\n              fields[\"System.CreatedBy\"],\n            email: fields[\"System.CreatedBy\"].uniqueName,\n          }\n        : undefined,\n      labels: fields[\"System.Tags\"]\n        ? fields[\"System.Tags\"].split(\";\").map((tag: string) => tag.trim())\n        : [],\n      customFields: this.extractCustomFields(fields),\n      createdAt: new Date(fields[\"System.CreatedDate\"]),\n      updatedAt: new Date(fields[\"System.ChangedDate\"]),\n      url: workItem._links?.html?.href || workItem.url,\n    };\n  }\n\n  private extractCustomFields(fields: any): Record<string, any> {\n    const customFields: Record<string, any> = {};\n    const systemFields = [\n      \"System.Id\",\n      \"System.Title\",\n      \"System.Description\",\n      \"System.State\",\n      \"System.AssignedTo\",\n      \"System.CreatedBy\",\n      \"System.CreatedDate\",\n      \"System.ChangedDate\",\n      \"System.Tags\",\n      \"System.TeamProject\",\n      \"System.WorkItemType\",\n      \"Microsoft.VSTS.Common.Priority\",\n    ];\n\n    for (const [key, value] of Object.entries(fields)) {\n      if (\n        !systemFields.includes(key) &&\n        value !== null &&\n        value !== undefined\n      ) {\n        customFields[key] = value;\n      }\n    }\n\n    return customFields;\n  }\n\n  async linkToTestCase(\n    issueId: string,\n    testCaseId: string,\n    metadata?: any\n  ): Promise<void> {\n    const comment = `Linked to test case: ${testCaseId}${\n      metadata ? `\\n\\nMetadata: ${JSON.stringify(metadata, null, 2)}` : \"\"\n    }`;\n    await this.addComment(issueId, comment);\n  }\n\n  async syncIssue(issueId: string): Promise<IssueData> {\n    return this.getIssue(issueId);\n  }\n\n  private extractTextFromTiptap(tiptapJson: any): string {\n    // Simple text extraction from TipTap JSON\n    let text = '';\n    \n    if (tiptapJson.content && Array.isArray(tiptapJson.content)) {\n      tiptapJson.content.forEach((node: any) => {\n        if (node.type === 'text') {\n          text += node.text || '';\n        } else if (node.content && Array.isArray(node.content)) {\n          text += this.extractTextFromTiptap(node) + '\\n';\n        }\n      });\n    }\n    \n    return text.trim();\n  }\n}\n", "import {\n  IssueAdapterCapabilities,\n  AuthenticationData,\n  IssueData,\n  CreateIssueData,\n  UpdateIssueData,\n  IssueSearchOptions,\n} from \"./IssueAdapter\";\nimport { BaseAdapter } from \"./BaseAdapter\";\nimport { prisma } from \"@/lib/prisma\";\n\n/**\n * Simple URL adapter for basic issue tracking integrations\n * This adapter provides basic functionality for URL-based issue tracking systems\n */\nexport class SimpleUrlAdapter extends BaseAdapter {\n  /**\n   * Get the capabilities of this adapter\n   */\n  getCapabilities(): IssueAdapterCapabilities {\n    return {\n      createIssue: false, // Simple URL adapters typically can't create issues\n      updateIssue: false, // Simple URL adapters typically can't update issues\n      linkIssue: true,    // Can link to existing issues via URL\n      syncIssue: false,   // Can't sync since no API access\n      searchIssues: true, // Can provide basic search functionality\n      webhooks: false,    // No webhook support\n      customFields: false, // No custom field support\n      attachments: false, // No attachment support\n    };\n  }\n\n  /**\n   * Perform adapter-specific authentication\n   * Simple URL adapters don't typically require authentication\n   */\n  protected async performAuthentication(\n    authData: AuthenticationData\n  ): Promise<void> {\n    // Simple URL adapters don't require authentication\n    // Just validate that we have a base URL\n    if (!authData.baseUrl && !this.config.baseUrl) {\n      throw new Error(\"Base URL is required for Simple URL integration\");\n    }\n  }\n\n  /**\n   * Create a new issue - not supported by Simple URL adapters\n   */\n  async createIssue(_data: CreateIssueData): Promise<IssueData> {\n    throw new Error(\"Creating issues is not supported by Simple URL integration\");\n  }\n\n  /**\n   * Update an existing issue - not supported by Simple URL adapters\n   */\n  async updateIssue(\n    _issueId: string,\n    _data: UpdateIssueData\n  ): Promise<IssueData> {\n    throw new Error(\"Updating issues is not supported by Simple URL integration\");\n  }\n\n  /**\n   * Get a single issue by ID - creates a mock issue based on URL pattern\n   */\n  async getIssue(issueId: string): Promise<IssueData> {\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      throw new Error(\"Base URL not configured\");\n    }\n\n    // Generate URL by replacing {issueId} placeholder\n    const url = baseUrl.replace(\"{issueId}\", issueId).replace(\"'{issueId}'\", issueId);\n\n    return {\n      id: issueId,\n      key: issueId,\n      title: `Issue ${issueId}`,\n      description: `Issue linked via Simple URL integration`,\n      status: \"Unknown\",\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      url: url,\n    };\n  }\n\n  /**\n   * Search for issues - searches the internal database for issues linked to this integration\n   */\n  async searchIssues(options: IssueSearchOptions): Promise<{\n    issues: IssueData[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const { query = \"\", limit = 10 } = options;\n    \n    // For Simple URL integrations, we search the internal TestPlanIt database\n    // for issues that are linked to this integration\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      throw new Error(\"Base URL not configured\");\n    }\n\n    // Get the integration ID from config\n    const integrationId = this.config.integrationId;\n    if (!integrationId) {\n      throw new Error(\"Integration ID not configured\");\n    }\n\n    // Search issues in the database that belong to this integration\n    const where: any = {\n      integrationId: integrationId,\n      isDeleted: false,\n    };\n\n    // Add search filter if query is provided\n    if (query.trim()) {\n      where.OR = [\n        { name: { contains: query, mode: \"insensitive\" } },\n        { title: { contains: query, mode: \"insensitive\" } },\n        { description: { contains: query, mode: \"insensitive\" } },\n        { externalId: { contains: query, mode: \"insensitive\" } },\n        { externalKey: { contains: query, mode: \"insensitive\" } },\n      ];\n    }\n\n    // Get total count for pagination\n    const total = await prisma.issue.count({ where });\n\n    // Get the actual issues\n    const dbIssues = await prisma.issue.findMany({\n      where,\n      take: limit,\n      orderBy: { createdAt: \"desc\" },\n      select: {\n        id: true,\n        name: true,\n        title: true,\n        description: true,\n        status: true,\n        priority: true,\n        externalId: true,\n        externalKey: true,\n        externalUrl: true,\n        externalStatus: true,\n        createdAt: true,\n      },\n    });\n\n    // Convert database issues to IssueData format\n    const issues: IssueData[] = dbIssues.map((dbIssue) => {\n      // Use existing external URL if available, otherwise generate from pattern\n      let url = dbIssue.externalUrl;\n      if (!url && (dbIssue.externalId || dbIssue.externalKey)) {\n        const issueId = dbIssue.externalId || dbIssue.externalKey || dbIssue.id.toString();\n        url = baseUrl.replace(\"{issueId}\", issueId).replace(\"'{issueId}'\", issueId);\n      }\n\n      return {\n        id: dbIssue.externalId || dbIssue.externalKey || dbIssue.id.toString(),\n        key: dbIssue.externalKey || dbIssue.externalId || dbIssue.name,\n        title: dbIssue.title,\n        description: dbIssue.description || undefined,\n        status: dbIssue.externalStatus || dbIssue.status || \"Unknown\",\n        priority: dbIssue.priority || undefined,\n        createdAt: dbIssue.createdAt,\n        updatedAt: dbIssue.createdAt, // Use createdAt since Issue model doesn't have updatedAt\n        url: url || undefined,\n      };\n    });\n\n    return {\n      issues,\n      total,\n      hasMore: dbIssues.length === limit && total > limit,\n    };\n  }\n\n  /**\n   * Link an issue to a test case\n   */\n  async linkToTestCase(\n    issueId: string,\n    _testCaseId: string,\n    _metadata?: any\n  ): Promise<void> {\n    // For Simple URL integrations, we just validate that we can generate a valid URL\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      throw new Error(\"Base URL not configured\");\n    }\n\n    const url = baseUrl.replace(\"{issueId}\", issueId).replace(\"'{issueId}'\", issueId);\n    \n    // Basic URL validation\n    try {\n      new URL(url);\n    } catch (error) {\n      throw new Error(`Invalid URL generated: ${url}`);\n    }\n\n    // Since we can't actually link in the external system, this is a no-op\n    // The link will be stored in the TestPlanIt database\n  }\n\n  /**\n   * Validate configuration\n   */\n  async validateConfiguration(): Promise<{\n    valid: boolean;\n    errors?: string[];\n  }> {\n    const errors: string[] = [];\n\n    const baseUrl = this.authData?.baseUrl || this.config.baseUrl;\n    if (!baseUrl) {\n      errors.push(\"Base URL is required\");\n    } else {\n      // Validate URL pattern contains placeholder\n      if (!baseUrl.includes(\"{issueId}\") && !baseUrl.includes(\"'{issueId}'\")) {\n        errors.push(\"Base URL must contain {issueId} placeholder\");\n      }\n\n      // Try to validate URL format\n      try {\n        const testUrl = baseUrl.replace(\"{issueId}\", \"TEST-1\").replace(\"'{issueId}'\", \"TEST-1\");\n        new URL(testUrl);\n      } catch (error) {\n        errors.push(\"Base URL pattern is not a valid URL format\");\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined,\n    };\n  }\n}", "import crypto from \"crypto\";\n\nconst algorithm = \"aes-256-gcm\";\nconst ivLength = 16;\nconst saltLength = 32;\nconst tagLength = 16;\nconst iterations = 100000;\nconst keyLength = 32;\n\n// Get encryption key from environment variable or generate a default one for development\nexport const getMasterKey = (): string => {\n  const key = process.env.ENCRYPTION_KEY;\n  if (!key) {\n    // In development, use a default key (DO NOT use in production)\n    console.warn(\"ENCRYPTION_KEY not set, using default key for development\");\n    return \"development-key-do-not-use-in-production-please!\";\n  }\n  return key;\n};\n\n// Alias for backward compatibility\nconst getEncryptionKey = getMasterKey;\n\n// Derive key from password using PBKDF2\nconst deriveKey = (password: string, salt: Buffer): Buffer => {\n  return crypto.pbkdf2Sync(password, salt, iterations, keyLength, \"sha256\");\n};\n\n// Encrypt a value\nexport const encrypt = async (text: string): Promise<string> => {\n  try {\n    const password = getEncryptionKey();\n    const salt = crypto.randomBytes(saltLength);\n    const key = deriveKey(password, salt);\n    const iv = crypto.randomBytes(ivLength);\n\n    const cipher = crypto.createCipheriv(algorithm, key, iv);\n\n    const encrypted = Buffer.concat([\n      cipher.update(text, \"utf8\"),\n      cipher.final(),\n    ]);\n\n    const tag = cipher.getAuthTag();\n\n    // Combine salt, iv, tag, and encrypted data\n    const combined = Buffer.concat([salt, iv, tag, encrypted]);\n\n    return combined.toString(\"base64\");\n  } catch (error) {\n    console.error(\"Encryption error:\", error);\n    throw new Error(\"Failed to encrypt data\");\n  }\n};\n\n// Decrypt a value\nexport const decrypt = async (encryptedText: string): Promise<string> => {\n  try {\n    const password = getEncryptionKey();\n    const combined = Buffer.from(encryptedText, \"base64\");\n\n    // Extract components\n    const salt = combined.slice(0, saltLength);\n    const iv = combined.slice(saltLength, saltLength + ivLength);\n    const tag = combined.slice(\n      saltLength + ivLength,\n      saltLength + ivLength + tagLength\n    );\n    const encrypted = combined.slice(saltLength + ivLength + tagLength);\n\n    const key = deriveKey(password, salt);\n\n    const decipher = crypto.createDecipheriv(algorithm, key, iv);\n    decipher.setAuthTag(tag);\n\n    const decrypted = Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final(),\n    ]);\n\n    return decrypted.toString(\"utf8\");\n  } catch (error) {\n    console.error(\"Decryption error:\", error);\n    throw new Error(\"Failed to decrypt data\");\n  }\n};\n\n// Utility to check if a string is encrypted (base64 format check)\nexport const isEncrypted = (value: string): boolean => {\n  try {\n    const decoded = Buffer.from(value, \"base64\");\n    // Check if the decoded buffer has the expected minimum length\n    return decoded.length >= saltLength + ivLength + tagLength;\n  } catch {\n    return false;\n  }\n};\n\n// EncryptionService class for object encryption/decryption\nexport class EncryptionService {\n  static encrypt(text: string, key: string): string {\n    const salt = crypto.randomBytes(saltLength);\n    const derivedKey = deriveKey(key, salt);\n    const iv = crypto.randomBytes(ivLength);\n\n    const cipher = crypto.createCipheriv(algorithm, derivedKey, iv);\n\n    const encrypted = Buffer.concat([\n      cipher.update(text, \"utf8\"),\n      cipher.final(),\n    ]);\n\n    const tag = cipher.getAuthTag();\n\n    // Combine salt, iv, tag, and encrypted data\n    const combined = Buffer.concat([salt, iv, tag, encrypted]);\n\n    return combined.toString(\"base64\");\n  }\n\n  static decrypt(encryptedText: string, key: string): string {\n    const combined = Buffer.from(encryptedText, \"base64\");\n\n    // Extract components\n    const salt = combined.slice(0, saltLength);\n    const iv = combined.slice(saltLength, saltLength + ivLength);\n    const tag = combined.slice(\n      saltLength + ivLength,\n      saltLength + ivLength + tagLength\n    );\n    const encrypted = combined.slice(saltLength + ivLength + tagLength);\n\n    const derivedKey = deriveKey(key, salt);\n\n    const decipher = crypto.createDecipheriv(algorithm, derivedKey, iv);\n    decipher.setAuthTag(tag);\n\n    const decrypted = Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final(),\n    ]);\n\n    return decrypted.toString(\"utf8\");\n  }\n\n  static encryptObject(obj: any, key: string): string {\n    return this.encrypt(JSON.stringify(obj), key);\n  }\n\n  static decryptObject(encryptedText: string, key: string): any {\n    return JSON.parse(this.decrypt(encryptedText, key));\n  }\n}\n", "import { prisma } from \"@/lib/prisma\";\nimport type { Integration, IntegrationProvider } from \"@prisma/client\";\nimport { IssueAdapter } from \"./adapters/IssueAdapter\";\nimport { JiraAdapter } from \"./adapters/JiraAdapter\";\nimport { GitHubAdapter } from \"./adapters/GitHubAdapter\";\nimport { AzureDevOpsAdapter } from \"./adapters/AzureDevOpsAdapter\";\nimport { SimpleUrlAdapter } from \"./adapters/SimpleUrlAdapter\";\nimport { EncryptionService, getMasterKey } from \"@/utils/encryption\";\n\n/**\n * Central service for managing integrations and their adapters\n */\nexport class IntegrationManager {\n  private static instance: IntegrationManager;\n  private adapterRegistry: Map<\n    IntegrationProvider,\n    new (config: any) => IssueAdapter\n  > = new Map();\n  private adapterCache: Map<string, IssueAdapter> = new Map();\n\n  private constructor() {\n    // Initialize with built-in adapters\n    this.registerAdapters();\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(): IntegrationManager {\n    if (!IntegrationManager.instance) {\n      IntegrationManager.instance = new IntegrationManager();\n    }\n    return IntegrationManager.instance;\n  }\n\n  /**\n   * Register built-in adapters\n   */\n  private registerAdapters(): void {\n    // Register Jira adapter\n    this.registerAdapter(\"JIRA\", JiraAdapter);\n\n    // Register GitHub adapter\n    this.registerAdapter(\"GITHUB\", GitHubAdapter);\n\n    // Register Azure DevOps adapter\n    this.registerAdapter(\"AZURE_DEVOPS\", AzureDevOpsAdapter);\n\n    // Register Simple URL adapter\n    this.registerAdapter(\"SIMPLE_URL\", SimpleUrlAdapter);\n  }\n\n  /**\n   * Register a new adapter type\n   */\n  registerAdapter(\n    type: IntegrationProvider,\n    adapterClass: new (config: any) => IssueAdapter\n  ): void {\n    this.adapterRegistry.set(type, adapterClass);\n  }\n\n  /**\n   * Get adapter for a specific integration\n   */\n  async getAdapter(integrationId: string): Promise<IssueAdapter | null> {\n    // Check cache first\n    if (this.adapterCache.has(integrationId)) {\n      return this.adapterCache.get(integrationId)!;\n    }\n\n    // Fetch integration from database\n    const integration = await prisma.integration.findUnique({\n      where: { id: parseInt(integrationId) },\n      include: {\n        userIntegrationAuths: {\n          where: { isActive: true },\n          orderBy: { updatedAt: \"desc\" },\n          take: 1,\n        },\n      },\n    });\n\n    if (!integration) {\n      throw new Error(`Integration not found: ${integrationId}`);\n    }\n\n    if (integration.status !== \"ACTIVE\") {\n      throw new Error(`Integration is not active: ${integrationId}`);\n    }\n\n    const AdapterClass = this.adapterRegistry.get(integration.provider);\n    if (!AdapterClass) {\n      throw new Error(\n        `No adapter registered for integration provider: ${integration.provider}`\n      );\n    }\n\n    // Create adapter instance with configuration\n    const config = await this.buildAdapterConfig(integration);\n    const adapter = new AdapterClass(config);\n\n    const masterKey = getMasterKey();\n    const authData: any = {\n      type: this.mapAuthType(integration.authType),\n    };\n\n    // Handle API key authentication\n    if (integration.authType === \"API_KEY\" && integration.credentials) {\n      let credentials = integration.credentials as any;\n      \n      // Check if credentials are encrypted\n      if (typeof credentials === \"object\" && \"encrypted\" in credentials) {\n        // Decrypt credentials\n        const decrypted = EncryptionService.decrypt(\n          credentials.encrypted as string,\n          masterKey\n        );\n        credentials = JSON.parse(decrypted);\n      }\n      \n      // Add API key auth data from credentials\n      if (credentials.email) authData.email = credentials.email;\n      if (credentials.apiToken) authData.apiToken = credentials.apiToken;\n      \n      // Add baseUrl from settings\n      if (integration.settings && typeof integration.settings === \"object\") {\n        const settings = integration.settings as Record<string, any>;\n        if (settings.baseUrl) authData.baseUrl = settings.baseUrl;\n      }\n      \n      await adapter.authenticate(authData);\n    } \n    // Handle OAuth authentication\n    else if (integration.userIntegrationAuths.length > 0) {\n      const auth = integration.userIntegrationAuths[0];\n      authData.expiresAt = auth.tokenExpiresAt || undefined;\n\n      // Decrypt sensitive fields\n      if (auth.accessToken) {\n        authData.accessToken = EncryptionService.decrypt(\n          auth.accessToken,\n          masterKey\n        );\n      }\n      if (auth.refreshToken) {\n        authData.refreshToken = EncryptionService.decrypt(\n          auth.refreshToken,\n          masterKey\n        );\n      }\n\n      await adapter.authenticate(authData);\n    }\n\n    // Cache the adapter\n    this.adapterCache.set(integrationId, adapter);\n\n    return adapter;\n  }\n\n  /**\n   * Map IntegrationAuthType enum to authentication type string\n   */\n  private mapAuthType(authType: string): \"oauth\" | \"api_key\" | \"basic\" {\n    switch (authType) {\n      case \"OAUTH2\":\n        return \"oauth\";\n      case \"PERSONAL_ACCESS_TOKEN\":\n      case \"API_KEY\":\n        return \"api_key\";\n      default:\n        return \"basic\";\n    }\n  }\n\n  /**\n   * Build adapter configuration from integration data\n   */\n  private async buildAdapterConfig(integration: Integration): Promise<any> {\n    const config: any = {\n      integrationId: integration.id,\n      name: integration.name,\n      provider: integration.provider,\n    };\n\n    // Add provider-specific settings\n    if (integration.settings && typeof integration.settings === \"object\") {\n      Object.assign(config, integration.settings);\n    }\n\n    return config;\n  }\n\n  /**\n   * Clear adapter from cache\n   */\n  clearAdapter(integrationId: string): void {\n    this.adapterCache.delete(integrationId);\n  }\n\n  /**\n   * Clear all cached adapters\n   */\n  clearAllAdapters(): void {\n    this.adapterCache.clear();\n  }\n\n  /**\n   * Get all registered adapter types\n   */\n  getRegisteredTypes(): IntegrationProvider[] {\n    return Array.from(this.adapterRegistry.keys());\n  }\n\n  /**\n   * Check if adapter type is registered\n   */\n  isTypeRegistered(type: IntegrationProvider): boolean {\n    return this.adapterRegistry.has(type);\n  }\n\n  /**\n   * Get adapter capabilities for a specific integration\n   */\n  async getCapabilities(\n    integrationId: string\n  ): Promise<ReturnType<IssueAdapter[\"getCapabilities\"]> | null> {\n    const adapter = await this.getAdapter(integrationId);\n    return adapter ? adapter.getCapabilities() : null;\n  }\n\n  /**\n   * Validate integration configuration\n   */\n  async validateIntegration(\n    integrationId: string\n  ): Promise<{ valid: boolean; errors?: string[] }> {\n    try {\n      const adapter = await this.getAdapter(integrationId);\n      if (!adapter) {\n        return { valid: false, errors: [\"Adapter not found\"] };\n      }\n\n      // Check authentication\n      const isAuthenticated = await adapter.isAuthenticated();\n      if (!isAuthenticated) {\n        return { valid: false, errors: [\"Authentication failed\"] };\n      }\n\n      // Run adapter-specific validation if available\n      if (adapter.validateConfiguration) {\n        return await adapter.validateConfiguration();\n      }\n\n      return { valid: true };\n    } catch (error) {\n      return {\n        valid: false,\n        errors: [error instanceof Error ? error.message : \"Unknown error\"],\n      };\n    }\n  }\n}\n\n// Export singleton instance\nexport const integrationManager = IntegrationManager.getInstance();\n", "import { syncQueue } from \"../../queues\";\nimport { issueCache } from \"../cache/IssueCache\";\nimport { integrationManager } from \"../IntegrationManager\";\nimport { enhance } from \"@zenstackhq/runtime\";\nimport type { IssueData } from \"../adapters/IssueAdapter\";\nimport type { IssueAdapter } from \"../adapters/IssueAdapter\";\nimport { JobsOptions } from \"bullmq\";\nimport { prisma } from \"@/lib/prisma\";\nimport { syncIssueToElasticsearch } from \"~/services/issueSearch\";\n\nexport interface SyncJobData {\n  userId: string;\n  integrationId: number;\n  projectId?: string;\n  issueId?: string;\n  action: \"sync\" | \"create\" | \"update\" | \"refresh\";\n  data?: any;\n}\n\nexport interface SyncOptions {\n  forceRefresh?: boolean;\n  includeMetadata?: boolean;\n  limit?: number;\n}\n\nexport class SyncService {\n  /**\n   * Queue a sync job for an integration\n   */\n  async queueSync(\n    userId: string,\n    integrationId: number,\n    options: SyncOptions = {}\n  ): Promise<string | null> {\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      action: \"sync\",\n      data: options,\n    };\n\n    const jobOptions: JobsOptions = {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 2000,\n      },\n      removeOnComplete: true,\n      removeOnFail: false,\n    };\n\n    const job = await syncQueue.add(\"sync-issues\", jobData, jobOptions);\n    return job.id || null;\n  }\n\n  /**\n   * Queue a project-specific sync\n   */\n  async queueProjectSync(\n    userId: string,\n    integrationId: number,\n    projectId: string,\n    options: SyncOptions = {}\n  ): Promise<string | null> {\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      projectId,\n      action: \"sync\",\n      data: options,\n    };\n\n    const job = await syncQueue.add(\"sync-project-issues\", jobData);\n    return job.id || null;\n  }\n\n  /**\n   * Queue issue creation\n   */\n  async queueIssueCreate(\n    userId: string,\n    integrationId: number,\n    issueData: any\n  ): Promise<string | null> {\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      action: \"create\",\n      data: issueData,\n    };\n\n    const job = await syncQueue.add(\"create-issue\", jobData, {\n      attempts: 2,\n      backoff: {\n        type: \"fixed\",\n        delay: 1000,\n      },\n    });\n    return job.id || null;\n  }\n\n  /**\n   * Queue issue update\n   */\n  async queueIssueUpdate(\n    userId: string,\n    integrationId: number,\n    issueId: string,\n    updateData: any\n  ): Promise<string | null> {\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      issueId,\n      action: \"update\",\n      data: updateData,\n    };\n\n    const job = await syncQueue.add(\"update-issue\", jobData);\n    return job.id || null;\n  }\n\n  /**\n   * Queue issue refresh (sync single issue from external system)\n   */\n  async queueIssueRefresh(\n    userId: string,\n    integrationId: number,\n    issueId: string\n  ): Promise<string | null> {\n    if (!syncQueue) {\n      console.error(\"Sync queue not initialized\");\n      return null;\n    }\n\n    const jobData: SyncJobData = {\n      userId,\n      integrationId,\n      issueId,\n      action: \"refresh\",\n    };\n\n    const job = await syncQueue.add(\"refresh-issue\", jobData, {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 1000,\n      },\n      removeOnComplete: true,\n      removeOnFail: false,\n    });\n    return job.id || null;\n  }\n\n  /**\n   * Perform immediate sync (used by worker)\n   */\n  async performSync(\n    userId: string,\n    integrationId: number,\n    projectId?: string,\n    options: SyncOptions = {},\n    job?: any // BullMQ Job for progress reporting\n  ): Promise<{ synced: number; errors: string[] }> {\n    const errors: string[] = [];\n    let syncedCount = 0;\n\n    try {\n      // Get full user object for enhance\n      const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          role: {\n            include: {\n              rolePermissions: true,\n            },\n          },\n        },\n      });\n\n      if (!user) {\n        throw new Error(\"User not found\");\n      }\n\n      // Get user context for database operations\n      const userDb = enhance(prisma, { user }, { kinds: [\"delegate\"] });\n\n      // Get the integration\n      const integration = await userDb.integration.findUnique({\n        where: { id: integrationId },\n        include: {\n          userIntegrationAuths: {\n            where: { userId: userId, isActive: true },\n          },\n        },\n      });\n\n      if (!integration) {\n        throw new Error(\"Integration not found\");\n      }\n\n      // Check authentication based on auth type\n      if (integration.authType === \"OAUTH2\") {\n        // For OAuth, check if user has valid authentication\n        const userAuth = integration.userIntegrationAuths[0];\n        if (!userAuth) {\n          throw new Error(\"User not authenticated for this integration\");\n        }\n\n        // Check if token is expired\n        if (userAuth.tokenExpiresAt && userAuth.tokenExpiresAt < new Date()) {\n          throw new Error(\"Authentication token has expired\");\n        }\n      } else if (\n        integration.authType === \"API_KEY\" ||\n        integration.authType === \"PERSONAL_ACCESS_TOKEN\"\n      ) {\n        // For API key or PAT, check if integration has credentials\n        if (!integration.credentials) {\n          throw new Error(\"Integration is missing credentials\");\n        }\n      } else if (integration.authType !== \"NONE\") {\n        // For other auth types, ensure there's some form of authentication\n        const userAuth = integration.userIntegrationAuths[0];\n        if (!userAuth && !integration.credentials) {\n          throw new Error(\n            \"No authentication credentials found for this integration\"\n          );\n        }\n      }\n\n      // Get the adapter\n      const adapter = await integrationManager.getAdapter(\n        String(integrationId)\n      );\n\n      if (!adapter) {\n        throw new Error(\"Invalid adapter for issue synchronization\");\n      }\n\n      // Get total count of issues to sync\n      const totalIssues = await userDb.issue.count({\n        where: {\n          integrationId,\n          ...(projectId && { projectId: parseInt(projectId) }),\n        },\n      });\n\n      // Process issues in batches to manage memory usage\n      const BATCH_SIZE = 50;\n      let processedCount = 0;\n\n      while (processedCount < totalIssues) {\n        // Fetch a batch of issues\n        const localIssues = await userDb.issue.findMany({\n          where: {\n            integrationId,\n            ...(projectId && { projectId: parseInt(projectId) }),\n          },\n          select: {\n            id: true,\n            externalId: true,\n            externalKey: true,\n            name: true,\n          },\n          skip: processedCount,\n          take: BATCH_SIZE,\n        });\n\n        // Sync each issue in the current batch\n        for (let i = 0; i < localIssues.length; i++) {\n          const localIssue = localIssues[i];\n          const globalIndex = processedCount + i;\n\n          try {\n            // Update progress to keep job alive and inform UI\n            if (job) {\n              const progress = Math.round(((globalIndex + 1) / totalIssues) * 100);\n              await job.updateProgress({\n                current: globalIndex + 1,\n                total: totalIssues,\n                percentage: progress,\n                message: `Syncing issue ${globalIndex + 1} of ${totalIssues}`,\n              });\n            }\n\n            // Use externalId to fetch the latest data, fallback to externalKey or name\n            const issueIdentifier =\n              localIssue.externalId || localIssue.externalKey || localIssue.name;\n\n            if (!issueIdentifier) {\n              errors.push(`Issue ${localIssue.id} has no external identifier`);\n              continue;\n            }\n\n            // Fetch fresh issue data from external system\n            const issueData = await adapter.syncIssue(issueIdentifier);\n\n            // Update cache\n            await issueCache.set(integrationId, issueData.id, issueData);\n\n            // Update local database\n            await this.updateExistingIssue(userDb, integrationId, issueData);\n            syncedCount++;\n\n          } catch (error: any) {\n            errors.push(\n              `Failed to sync issue ${localIssue.externalKey || localIssue.externalId || localIssue.id}: ${error.message}`\n            );\n          }\n        }\n\n        processedCount += localIssues.length;\n\n        // Allow garbage collection between batches\n        if (processedCount < totalIssues) {\n          await new Promise(resolve => setTimeout(resolve, 10));\n        }\n      }\n\n      // Fetch metadata if requested\n      if (options.includeMetadata) {\n        try {\n          // Get metadata based on adapter capabilities\n          const metadata: any = {};\n\n          // Cast to IssueAdapter to access optional methods\n          const issueAdapter = adapter as IssueAdapter;\n\n          if (issueAdapter.getProjects) {\n            metadata.projects = await issueAdapter.getProjects();\n          }\n          if (issueAdapter.getStatuses) {\n            metadata.statuses = await issueAdapter.getStatuses();\n          }\n          if (issueAdapter.getPriorities) {\n            metadata.priorities = await issueAdapter.getPriorities();\n          }\n\n          await issueCache.setMetadata(integrationId, metadata);\n        } catch (error: any) {\n          errors.push(`Failed to fetch metadata: ${error.message}`);\n        }\n      }\n\n      return { synced: syncedCount, errors };\n    } catch (error: any) {\n      errors.push(`Sync failed: ${error.message}`);\n      return { synced: syncedCount, errors };\n    }\n  }\n\n  /**\n   * Refresh a single issue from the external system\n   */\n  async performIssueRefresh(\n    userId: string,\n    integrationId: number,\n    externalIssueId: string\n  ): Promise<{ success: boolean; error?: string }> {\n    try {\n      // Get full user object for enhance\n      const user = await prisma.user.findUnique({\n        where: { id: userId },\n        include: {\n          role: {\n            include: {\n              rolePermissions: true,\n            },\n          },\n        },\n      });\n\n      if (!user) {\n        throw new Error(\"User not found\");\n      }\n\n      // Get user context for database operations\n      const userDb = enhance(prisma, { user }, { kinds: [\"delegate\"] });\n\n      // Get the integration\n      const integration = await userDb.integration.findUnique({\n        where: { id: integrationId },\n        include: {\n          userIntegrationAuths: {\n            where: { userId: userId, isActive: true },\n          },\n        },\n      });\n\n      if (!integration) {\n        throw new Error(\"Integration not found\");\n      }\n\n      // Check authentication based on auth type\n      if (integration.authType === \"OAUTH2\") {\n        // For OAuth, check if user has valid authentication\n        const userAuth = integration.userIntegrationAuths[0];\n        if (!userAuth) {\n          throw new Error(\"User not authenticated for this integration\");\n        }\n\n        // Check if token is expired\n        if (userAuth.tokenExpiresAt && userAuth.tokenExpiresAt < new Date()) {\n          throw new Error(\"Authentication token has expired\");\n        }\n      } else if (\n        integration.authType === \"API_KEY\" ||\n        integration.authType === \"PERSONAL_ACCESS_TOKEN\"\n      ) {\n        // For API key or PAT, check if integration has credentials\n        if (!integration.credentials) {\n          throw new Error(\"Integration is missing credentials\");\n        }\n      } else if (integration.authType !== \"NONE\") {\n        // For other auth types, ensure there's some form of authentication\n        const userAuth = integration.userIntegrationAuths[0];\n        if (!userAuth && !integration.credentials) {\n          throw new Error(\n            \"No authentication credentials found for this integration\"\n          );\n        }\n      }\n\n      // Get the adapter\n      const adapter = await integrationManager.getAdapter(\n        String(integrationId)\n      );\n\n      if (!adapter) {\n        throw new Error(\"Invalid adapter for issue synchronization\");\n      }\n\n      // Check if adapter supports sync\n      const capabilities = adapter.getCapabilities();\n      if (!capabilities.syncIssue) {\n        throw new Error(\n          \"This integration does not support syncing individual issues\"\n        );\n      }\n\n      // Fetch fresh issue data from external system\n      const issueData = await adapter.syncIssue(externalIssueId);\n\n      // Update cache\n      await issueCache.set(integrationId, issueData.id, issueData);\n\n      // Update local database\n      await this.updateExistingIssue(userDb, integrationId, issueData);\n\n      return { success: true };\n    } catch (error: any) {\n      console.error(`Failed to refresh issue ${externalIssueId}:`, error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Update an existing issue in the local database with fresh data from external system\n   */\n  private async updateExistingIssue(\n    db: any,\n    integrationId: number,\n    issueData: IssueData\n  ): Promise<void> {\n    // Try to find the issue by externalId or externalKey\n    // This handles cases where the database might store either the ID or key\n    const existingIssue = await db.issue.findFirst({\n      where: {\n        integrationId,\n        OR: [\n          { externalId: issueData.id },\n          { externalId: issueData.key },\n          { externalKey: issueData.key },\n          { externalKey: issueData.id },\n        ],\n      },\n    });\n\n    if (!existingIssue) {\n      // Debug: Let's see if there are any issues with this key at all\n      const anyIssueWithKey = await db.issue.findFirst({\n        where: {\n          OR: [\n            { externalId: issueData.id },\n            { externalId: issueData.key },\n            { externalKey: issueData.key },\n            { externalKey: issueData.id },\n            { name: issueData.key },\n          ],\n        },\n        select: {\n          id: true,\n          integrationId: true,\n          externalId: true,\n          externalKey: true,\n          name: true,\n        },\n      });\n\n      throw new Error(\n        `Issue ${issueData.key || issueData.id} not found in local database. Issues must be created through the UI before they can be synced.`\n      );\n    }\n\n    const issuePayload = {\n      name: issueData.key || issueData.id, // Use key if available, otherwise use id\n      title: issueData.title,\n      description: issueData.description || \"\",\n      status: issueData.status,\n      priority: issueData.priority || \"medium\",\n      externalId: issueData.id,\n      externalKey: issueData.key,\n      externalUrl: issueData.url,\n      externalStatus: issueData.status,\n      externalData: issueData.customFields || {},\n      issueTypeId: issueData.issueType?.id,\n      issueTypeName: issueData.issueType?.name,\n      issueTypeIconUrl: issueData.issueType?.iconUrl,\n      lastSyncedAt: new Date(),\n    };\n\n    await db.issue.update({\n      where: { id: existingIssue.id },\n      data: issuePayload,\n    });\n\n    // Manually sync to Elasticsearch since enhanced Prisma client bypasses extensions\n    await syncIssueToElasticsearch(existingIssue.id).catch((error: any) => {\n      console.error(\n        `Failed to sync issue ${existingIssue.id} to Elasticsearch:`,\n        error\n      );\n    });\n  }\n}\n\nexport const syncService = new SyncService();\n"],
  "mappings": "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",
  "names": ["import_bullmq", "IORedis", "import_client", "import_client", "prisma", "prisma", "import_client", "prisma", "prisma", "import_client", "prisma", "import_client", "prisma", "prisma", "import_client", "prisma", "prisma", "import_client", "prisma", "prisma", "prisma", "credentials", "prisma", "crypto", "crypto", "prisma", "import_runtime", "prisma"]
}
