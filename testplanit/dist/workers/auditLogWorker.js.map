{
  "version": 3,
  "sources": ["../../lib/prismaBase.ts", "../../workers/auditLogWorker.ts", "../../lib/valkey.ts", "../../lib/queues.ts", "../../lib/queueNames.ts", "../../lib/multiTenantPrisma.ts"],
  "sourcesContent": ["// lib/prismaBase.ts\n// Base Prisma client without Elasticsearch sync extensions\n// Use this for workers and services that don't need auto-ES sync\n\nimport { PrismaClient } from \"@prisma/client\";\n\n// Declare global types\ndeclare global {\n  var prismaBase: PrismaClient | undefined;\n}\n\nlet prismaClient: PrismaClient;\n\n// Create a simple PrismaClient without extensions\nif (process.env.NODE_ENV === \"production\") {\n  prismaClient = new PrismaClient({ errorFormat: \"pretty\" });\n} else {\n  // Reuse global instance in development to prevent hot-reload issues\n  if (!global.prismaBase) {\n    global.prismaBase = new PrismaClient({ errorFormat: \"colorless\" });\n  }\n  prismaClient = global.prismaBase;\n}\n\nexport const prisma = prismaClient;\n", "import { Worker, Job } from \"bullmq\";\nimport type { Prisma } from \"@prisma/client\";\nimport valkeyConnection from \"../lib/valkey\";\nimport { AUDIT_LOG_QUEUE_NAME } from \"../lib/queues\";\nimport { pathToFileURL } from \"node:url\";\nimport {\n  getPrismaClientForJob,\n  isMultiTenantMode,\n  disconnectAllTenantClients,\n  validateMultiTenantJobData,\n} from \"../lib/multiTenantPrisma\";\nimport type { AuditLogJobData } from \"../lib/services/auditLog\";\n\n/**\n * Process an audit log job.\n * Writes the audit event to the database.\n */\nconst processor = async (job: Job<AuditLogJobData>) => {\n  const { event, context, queuedAt } = job.data;\n\n  console.log(\n    `[AuditLogWorker] Processing audit event: ${event.action} ${event.entityType}:${event.entityId}${\n      job.data.tenantId ? ` for tenant ${job.data.tenantId}` : \"\"\n    }`\n  );\n\n  // Validate multi-tenant job data if in multi-tenant mode\n  validateMultiTenantJobData(job.data);\n\n  // Get the appropriate Prisma client (tenant-specific or default)\n  const prisma = getPrismaClientForJob(job.data);\n\n  try {\n    // Merge user info from event (explicit) and context (request-level)\n    const userId = event.userId || context?.userId || null;\n    const userEmail = event.userEmail || context?.userEmail || null;\n    const userName = event.userName || context?.userName || null;\n\n    // Build metadata combining context and event metadata\n    const metadata: Record<string, unknown> = {\n      ...(event.metadata || {}),\n      ipAddress: context?.ipAddress,\n      userAgent: context?.userAgent,\n      requestId: context?.requestId,\n      queuedAt,\n      processedAt: new Date().toISOString(),\n    };\n\n    // Remove undefined values from metadata\n    for (const key of Object.keys(metadata)) {\n      if (metadata[key] === undefined) {\n        delete metadata[key];\n      }\n    }\n\n    // Validate projectId exists before creating audit log to prevent foreign key constraint errors\n    // The project might have been deleted between when the event was queued and now\n    let validatedProjectId: number | null = null;\n    if (event.projectId) {\n      const projectExists = await prisma.projects.findUnique({\n        where: { id: event.projectId },\n        select: { id: true },\n      });\n      if (projectExists) {\n        validatedProjectId = event.projectId;\n      } else {\n        // Project no longer exists - store the original projectId in metadata for reference\n        metadata.originalProjectId = event.projectId;\n        console.warn(\n          `[AuditLogWorker] Project ${event.projectId} no longer exists, creating audit log without project association`\n        );\n      }\n    }\n\n    // Create the audit log entry\n    // Note: We use the raw Prisma client here to bypass ZenStack access control\n    // since audit logs should be created by the system, not by users directly\n    await prisma.auditLog.create({\n      data: {\n        userId,\n        userEmail,\n        userName,\n        action: event.action,\n        entityType: event.entityType,\n        entityId: event.entityId,\n        entityName: event.entityName || null,\n        changes: event.changes as Prisma.InputJsonValue | undefined,\n        metadata: Object.keys(metadata).length > 0 ? (metadata as Prisma.InputJsonValue) : undefined,\n        projectId: validatedProjectId,\n      },\n    });\n\n    console.log(\n      `[AuditLogWorker] Successfully logged: ${event.action} ${event.entityType}:${event.entityId}`\n    );\n  } catch (error) {\n    console.error(`[AuditLogWorker] Failed to create audit log:`, error);\n    throw error; // Re-throw to trigger retry\n  }\n};\n\nlet worker: Worker | null = null;\n\n/**\n * Start the audit log worker.\n */\nconst startWorker = async () => {\n  // Log multi-tenant mode status\n  if (isMultiTenantMode()) {\n    console.log(\"[AuditLogWorker] Starting in MULTI-TENANT mode\");\n  } else {\n    console.log(\"[AuditLogWorker] Starting in SINGLE-TENANT mode\");\n  }\n\n  if (valkeyConnection) {\n    worker = new Worker(AUDIT_LOG_QUEUE_NAME, processor, {\n      connection: valkeyConnection,\n      concurrency: 10, // Higher concurrency since audit logs are independent\n    });\n\n    worker.on(\"completed\", (job) => {\n      // Don't log every completion to avoid noise\n      // console.log(`[AuditLogWorker] Job ${job.id} completed`);\n    });\n\n    worker.on(\"failed\", (job, err) => {\n      console.error(`[AuditLogWorker] Job ${job?.id} failed:`, err);\n    });\n\n    worker.on(\"error\", (err) => {\n      console.error(\"[AuditLogWorker] Worker error:\", err);\n    });\n\n    console.log(`[AuditLogWorker] Started for queue \"${AUDIT_LOG_QUEUE_NAME}\"`);\n  } else {\n    console.warn(\n      \"[AuditLogWorker] Valkey connection not available. Worker not started.\"\n    );\n  }\n\n  // Graceful shutdown\n  process.on(\"SIGINT\", async () => {\n    console.log(\"[AuditLogWorker] Shutting down...\");\n    if (worker) {\n      await worker.close();\n    }\n    if (isMultiTenantMode()) {\n      await disconnectAllTenantClients();\n    }\n    process.exit(0);\n  });\n\n  process.on(\"SIGTERM\", async () => {\n    console.log(\"[AuditLogWorker] Received SIGTERM, shutting down...\");\n    if (worker) {\n      await worker.close();\n    }\n    if (isMultiTenantMode()) {\n      await disconnectAllTenantClients();\n    }\n    process.exit(0);\n  });\n};\n\n// Run the worker if this file is executed directly\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  (typeof import.meta === \"undefined\" ||\n    (import.meta as unknown as { url?: string })?.url === undefined)\n) {\n  console.log(\"[AuditLogWorker] Running as standalone process...\");\n  startWorker().catch((err) => {\n    console.error(\"[AuditLogWorker] Failed to start:\", err);\n    process.exit(1);\n  });\n}\n\nexport default worker;\nexport { processor, startWorker };\n", "import IORedis from \"ioredis\";\n\n// Check if we should skip Valkey connection (useful during build)\nconst skipConnection = process.env.SKIP_VALKEY_CONNECTION === \"true\";\n\n// Get Valkey URL from environment\nconst valkeyUrl = process.env.VALKEY_URL;\n\nif (!valkeyUrl && !skipConnection) {\n  // Log an error, but maybe don't throw immediately\n  // depending on whether Valkey is strictly required at startup\n  console.error(\n    \"VALKEY_URL environment variable is not set. Background jobs may fail.\"\n  );\n  // Optional: throw new Error('VALKEY_URL environment variable is not set.');\n}\n\n// Configure the connection options\nconst connectionOptions = {\n  maxRetriesPerRequest: null, // Required by BullMQ\n  enableReadyCheck: false, // Optional: Sometimes helps with startup race conditions\n};\n\nlet valkeyConnection: IORedis | null = null;\n\nif (valkeyUrl && !skipConnection) {\n  // Convert valkey:// to redis:// for ioredis compatibility\n  // ioredis expects redis:// protocol but we're connecting to Valkey\n  const connectionUrl = valkeyUrl.replace(/^valkey:\\/\\//, 'redis://');\n  \n  // Create and export the connection instance only if URL is provided\n  valkeyConnection = new IORedis(connectionUrl, connectionOptions);\n\n  valkeyConnection.on(\"connect\", () => {\n    console.log(\"Successfully connected to Valkey.\");\n  });\n\n  valkeyConnection.on(\"error\", (err) => {\n    console.error(\"Valkey connection error:\", err);\n  });\n} else {\n  console.warn(\"Valkey URL not provided. Valkey connection not established.\");\n}\n\nexport default valkeyConnection;", "import { Queue } from \"bullmq\";\nimport valkeyConnection from \"./valkey\";\nimport type IORedis from \"ioredis\";\nimport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n  AUDIT_LOG_QUEUE_NAME,\n} from \"./queueNames\";\n\n// Re-export queue names for backward compatibility\nexport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n  AUDIT_LOG_QUEUE_NAME,\n};\n\n// Lazy-initialized queue instances\nlet _forecastQueue: Queue | null = null;\nlet _notificationQueue: Queue | null = null;\nlet _emailQueue: Queue | null = null;\nlet _syncQueue: Queue | null = null;\nlet _testmoImportQueue: Queue | null = null;\nlet _elasticsearchReindexQueue: Queue | null = null;\nlet _auditLogQueue: Queue | null = null;\n\n/**\n * Get the forecast queue instance (lazy initialization)\n * Only creates the queue when first accessed\n */\nexport function getForecastQueue(): Queue | null {\n  if (_forecastQueue) return _forecastQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${FORECAST_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _forecastQueue = new Queue(FORECAST_QUEUE_NAME, {\n    connection: valkeyConnection as IORedis,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${FORECAST_QUEUE_NAME}\" initialized.`);\n\n  _forecastQueue.on(\"error\", (error) => {\n    console.error(`Queue ${FORECAST_QUEUE_NAME} error:`, error);\n  });\n\n  return _forecastQueue;\n}\n\n/**\n * Get the notification queue instance (lazy initialization)\n */\nexport function getNotificationQueue(): Queue | null {\n  if (_notificationQueue) return _notificationQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${NOTIFICATION_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _notificationQueue = new Queue(NOTIFICATION_QUEUE_NAME, {\n    connection: valkeyConnection as IORedis,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${NOTIFICATION_QUEUE_NAME}\" initialized.`);\n\n  _notificationQueue.on(\"error\", (error) => {\n    console.error(`Queue ${NOTIFICATION_QUEUE_NAME} error:`, error);\n  });\n\n  return _notificationQueue;\n}\n\n/**\n * Get the email queue instance (lazy initialization)\n */\nexport function getEmailQueue(): Queue | null {\n  if (_emailQueue) return _emailQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${EMAIL_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _emailQueue = new Queue(EMAIL_QUEUE_NAME, {\n    connection: valkeyConnection as IORedis,\n    defaultJobOptions: {\n      attempts: 5,\n      backoff: {\n        type: \"exponential\",\n        delay: 10000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 5000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${EMAIL_QUEUE_NAME}\" initialized.`);\n\n  _emailQueue.on(\"error\", (error) => {\n    console.error(`Queue ${EMAIL_QUEUE_NAME} error:`, error);\n  });\n\n  return _emailQueue;\n}\n\n/**\n * Get the sync queue instance (lazy initialization)\n */\nexport function getSyncQueue(): Queue | null {\n  if (_syncQueue) return _syncQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${SYNC_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _syncQueue = new Queue(SYNC_QUEUE_NAME, {\n    connection: valkeyConnection as IORedis,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 3,\n        count: 500,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 7,\n      },\n    },\n  });\n\n  console.log(`Queue \"${SYNC_QUEUE_NAME}\" initialized.`);\n\n  _syncQueue.on(\"error\", (error) => {\n    console.error(`Queue ${SYNC_QUEUE_NAME} error:`, error);\n  });\n\n  return _syncQueue;\n}\n\n/**\n * Get the Testmo import queue instance (lazy initialization)\n */\nexport function getTestmoImportQueue(): Queue | null {\n  if (_testmoImportQueue) return _testmoImportQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _testmoImportQueue = new Queue(TESTMO_IMPORT_QUEUE_NAME, {\n    connection: valkeyConnection as IORedis,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 100,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" initialized.`);\n\n  _testmoImportQueue.on(\"error\", (error) => {\n    console.error(`Queue ${TESTMO_IMPORT_QUEUE_NAME} error:`, error);\n  });\n\n  return _testmoImportQueue;\n}\n\n/**\n * Get the Elasticsearch reindex queue instance (lazy initialization)\n */\nexport function getElasticsearchReindexQueue(): Queue | null {\n  if (_elasticsearchReindexQueue) return _elasticsearchReindexQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _elasticsearchReindexQueue = new Queue(ELASTICSEARCH_REINDEX_QUEUE_NAME, {\n    connection: valkeyConnection as IORedis,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 50,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" initialized.`);\n\n  _elasticsearchReindexQueue.on(\"error\", (error) => {\n    console.error(`Queue ${ELASTICSEARCH_REINDEX_QUEUE_NAME} error:`, error);\n  });\n\n  return _elasticsearchReindexQueue;\n}\n\n/**\n * Get the audit log queue instance (lazy initialization)\n * Used for async audit log processing to avoid blocking mutations\n */\nexport function getAuditLogQueue(): Queue | null {\n  if (_auditLogQueue) return _auditLogQueue;\n  if (!valkeyConnection) {\n    console.warn(\n      `Valkey connection not available, Queue \"${AUDIT_LOG_QUEUE_NAME}\" not initialized.`\n    );\n    return null;\n  }\n\n  _auditLogQueue = new Queue(AUDIT_LOG_QUEUE_NAME, {\n    connection: valkeyConnection as IORedis,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      // Long retention for audit logs - keep completed jobs for 1 year\n      removeOnComplete: {\n        age: 3600 * 24 * 365, // 1 year\n        count: 100000,\n      },\n      // Keep failed jobs for investigation\n      removeOnFail: {\n        age: 3600 * 24 * 90, // 90 days\n      },\n    },\n  });\n\n  console.log(`Queue \"${AUDIT_LOG_QUEUE_NAME}\" initialized.`);\n\n  _auditLogQueue.on(\"error\", (error) => {\n    console.error(`Queue ${AUDIT_LOG_QUEUE_NAME} error:`, error);\n  });\n\n  return _auditLogQueue;\n}\n\n/**\n * Get all queues (initializes all of them)\n * Use this only when you need access to all queues (e.g., admin dashboard)\n */\nexport function getAllQueues() {\n  return {\n    forecastQueue: getForecastQueue(),\n    notificationQueue: getNotificationQueue(),\n    emailQueue: getEmailQueue(),\n    syncQueue: getSyncQueue(),\n    testmoImportQueue: getTestmoImportQueue(),\n    elasticsearchReindexQueue: getElasticsearchReindexQueue(),\n    auditLogQueue: getAuditLogQueue(),\n  };\n}\n", "// Queue name constants - no initialization, just names\nexport const FORECAST_QUEUE_NAME = \"forecast-updates\";\nexport const NOTIFICATION_QUEUE_NAME = \"notifications\";\nexport const EMAIL_QUEUE_NAME = \"emails\";\nexport const SYNC_QUEUE_NAME = \"issue-sync\";\nexport const TESTMO_IMPORT_QUEUE_NAME = \"testmo-imports\";\nexport const ELASTICSEARCH_REINDEX_QUEUE_NAME = \"elasticsearch-reindex\";\nexport const AUDIT_LOG_QUEUE_NAME = \"audit-logs\";\n", "// lib/multiTenantPrisma.ts\n// Multi-tenant Prisma client factory for shared worker containers\n\nimport { PrismaClient } from \"@prisma/client\";\nimport * as fs from \"fs\";\n\n/**\n * Tenant configuration interface\n */\nexport interface TenantConfig {\n  tenantId: string;\n  databaseUrl: string;\n  elasticsearchNode?: string;\n  elasticsearchIndex?: string;\n  baseUrl?: string;\n}\n\n/**\n * Check if multi-tenant mode is enabled\n */\nexport function isMultiTenantMode(): boolean {\n  return process.env.MULTI_TENANT_MODE === \"true\";\n}\n\n/**\n * Get the current instance's tenant ID\n * In multi-tenant deployments, each web app instance belongs to a single tenant.\n * Set via INSTANCE_TENANT_ID environment variable.\n *\n * Note: This returns the tenant ID whenever INSTANCE_TENANT_ID is set,\n * regardless of whether MULTI_TENANT_MODE is enabled. This allows web app\n * instances to include their tenant ID in queued jobs, which the shared\n * worker (running with MULTI_TENANT_MODE=true) can then use to route\n * database operations to the correct tenant.\n *\n * Returns undefined if INSTANCE_TENANT_ID is not configured.\n */\nexport function getCurrentTenantId(): string | undefined {\n  return process.env.INSTANCE_TENANT_ID;\n}\n\n/**\n * Cache of Prisma clients per tenant to avoid creating new connections for each job\n * Stores both the client and the database URL used to create it (for credential change detection)\n */\ninterface CachedClient {\n  client: PrismaClient;\n  databaseUrl: string;\n}\nconst tenantClients: Map<string, CachedClient> = new Map();\n\n/**\n * Tenant configurations loaded from environment or config file\n */\nlet tenantConfigs: Map<string, TenantConfig> | null = null;\n\n/**\n * Path to the tenant config file (can be set via TENANT_CONFIG_FILE env var)\n */\nconst TENANT_CONFIG_FILE = process.env.TENANT_CONFIG_FILE || \"/config/tenants.json\";\n\n/**\n * Load tenant configurations from file\n */\nfunction loadTenantsFromFile(filePath: string): Map<string, TenantConfig> {\n  const configs = new Map<string, TenantConfig>();\n\n  try {\n    if (fs.existsSync(filePath)) {\n      const fileContent = fs.readFileSync(filePath, \"utf-8\");\n      const parsed = JSON.parse(fileContent) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(parsed)) {\n        configs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n          baseUrl: config.baseUrl,\n        });\n      }\n      console.log(`Loaded ${configs.size} tenant configurations from ${filePath}`);\n    }\n  } catch (error) {\n    console.error(`Failed to load tenant configs from ${filePath}:`, error);\n  }\n\n  return configs;\n}\n\n/**\n * Reload tenant configurations from file (for dynamic updates)\n * This allows adding new tenants without restarting workers\n */\nexport function reloadTenantConfigs(): Map<string, TenantConfig> {\n  // Clear cached configs\n  tenantConfigs = null;\n  // Reload\n  return loadTenantConfigs();\n}\n\n/**\n * Load tenant configurations from:\n * 1. Config file (TENANT_CONFIG_FILE env var or /config/tenants.json)\n * 2. TENANT_CONFIGS environment variable (JSON string)\n * 3. Individual environment variables: TENANT_<ID>_DATABASE_URL, etc.\n */\nexport function loadTenantConfigs(): Map<string, TenantConfig> {\n  if (tenantConfigs) {\n    return tenantConfigs;\n  }\n\n  tenantConfigs = new Map();\n\n  // Priority 1: Load from config file\n  const fileConfigs = loadTenantsFromFile(TENANT_CONFIG_FILE);\n  for (const [tenantId, config] of fileConfigs) {\n    tenantConfigs.set(tenantId, config);\n  }\n\n  // Priority 2: Load from TENANT_CONFIGS env var (can override file configs)\n  const configJson = process.env.TENANT_CONFIGS;\n  if (configJson) {\n    try {\n      const configs = JSON.parse(configJson) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(configs)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n          baseUrl: config.baseUrl,\n        });\n      }\n      console.log(`Loaded ${Object.keys(configs).length} tenant configurations from TENANT_CONFIGS env var`);\n    } catch (error) {\n      console.error(\"Failed to parse TENANT_CONFIGS:\", error);\n    }\n  }\n\n  // Priority 3: Individual tenant environment variables\n  // Format: TENANT_<TENANT_ID>_DATABASE_URL, TENANT_<TENANT_ID>_ELASTICSEARCH_NODE, TENANT_<TENANT_ID>_BASE_URL\n  for (const [key, value] of Object.entries(process.env)) {\n    const match = key.match(/^TENANT_([A-Z0-9_]+)_DATABASE_URL$/);\n    if (match && value) {\n      const tenantId = match[1].toLowerCase();\n      if (!tenantConfigs.has(tenantId)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: value,\n          elasticsearchNode: process.env[`TENANT_${match[1]}_ELASTICSEARCH_NODE`],\n          elasticsearchIndex: process.env[`TENANT_${match[1]}_ELASTICSEARCH_INDEX`],\n          baseUrl: process.env[`TENANT_${match[1]}_BASE_URL`],\n        });\n      }\n    }\n  }\n\n  if (tenantConfigs.size === 0) {\n    console.warn(\"No tenant configurations found. Multi-tenant mode will not work without configurations.\");\n  }\n\n  return tenantConfigs;\n}\n\n/**\n * Get tenant configuration by ID\n */\nexport function getTenantConfig(tenantId: string): TenantConfig | undefined {\n  const configs = loadTenantConfigs();\n  return configs.get(tenantId);\n}\n\n/**\n * Get all tenant IDs\n */\nexport function getAllTenantIds(): string[] {\n  const configs = loadTenantConfigs();\n  return Array.from(configs.keys());\n}\n\n/**\n * Create a Prisma client for a specific tenant\n */\nfunction createTenantPrismaClient(config: TenantConfig): PrismaClient {\n  const client = new PrismaClient({\n    datasources: {\n      db: {\n        url: config.databaseUrl,\n      },\n    },\n    errorFormat: \"pretty\",\n  });\n\n  return client;\n}\n\n/**\n * Get or create a Prisma client for a specific tenant\n * Caches clients to reuse connections\n * Supports dynamic tenant addition by reloading configs if tenant not found\n * Automatically invalidates cached clients when credentials change\n */\nexport function getTenantPrismaClient(tenantId: string): PrismaClient {\n  // Always reload config from file to get latest credentials\n  reloadTenantConfigs();\n  const config = getTenantConfig(tenantId);\n\n  if (!config) {\n    throw new Error(`No configuration found for tenant: ${tenantId}`);\n  }\n\n  // Check cache - but invalidate if credentials have changed\n  const cached = tenantClients.get(tenantId);\n  if (cached) {\n    if (cached.databaseUrl === config.databaseUrl) {\n      // Credentials unchanged, reuse cached client\n      return cached.client;\n    } else {\n      // Credentials changed - disconnect old client and create new one\n      console.log(`Credentials changed for tenant ${tenantId}, invalidating cached client...`);\n      cached.client.$disconnect().catch((err) => {\n        console.error(`Error disconnecting stale client for tenant ${tenantId}:`, err);\n      });\n      tenantClients.delete(tenantId);\n    }\n  }\n\n  // Create and cache new client\n  const client = createTenantPrismaClient(config);\n  tenantClients.set(tenantId, { client, databaseUrl: config.databaseUrl });\n  console.log(`Created Prisma client for tenant: ${tenantId}`);\n\n  return client;\n}\n\n/**\n * Get a Prisma client based on job data\n * In single-tenant mode, returns the default client\n * In multi-tenant mode, returns tenant-specific client\n */\nexport function getPrismaClientForJob(jobData: { tenantId?: string }): PrismaClient {\n  if (!isMultiTenantMode()) {\n    // Single-tenant mode: use lightweight Prisma client (no ES sync extensions)\n    // Import lazily to avoid circular dependencies\n    const { prisma } = require(\"./prismaBase\");\n    return prisma;\n  }\n\n  // Multi-tenant mode: require tenantId\n  if (!jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n\n  return getTenantPrismaClient(jobData.tenantId);\n}\n\n/**\n * Disconnect all tenant clients (for graceful shutdown)\n */\nexport async function disconnectAllTenantClients(): Promise<void> {\n  const disconnectPromises: Promise<void>[] = [];\n\n  for (const [tenantId, cached] of tenantClients) {\n    console.log(`Disconnecting Prisma client for tenant: ${tenantId}`);\n    disconnectPromises.push(cached.client.$disconnect());\n  }\n\n  await Promise.all(disconnectPromises);\n  tenantClients.clear();\n  console.log(\"All tenant Prisma clients disconnected\");\n}\n\n/**\n * Base interface for job data that supports multi-tenancy\n */\nexport interface MultiTenantJobData {\n  tenantId?: string; // Optional in single-tenant mode, required in multi-tenant mode\n}\n\n/**\n * Validate job data for multi-tenant mode\n */\nexport function validateMultiTenantJobData(jobData: MultiTenantJobData): void {\n  if (isMultiTenantMode() && !jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_bullmq", "IORedis", "import_client", "prisma", "prisma"]
}
