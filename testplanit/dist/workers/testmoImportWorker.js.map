{
  "version": 3,
  "sources": ["../../workers/testmoImportWorker.ts", "../../lib/multiTenantPrisma.ts", "../../lib/valkey.ts", "../../lib/queues.ts", "../../lib/queueNames.ts", "../../services/imports/testmo/TestmoExportAnalyzer.ts", "../../services/imports/testmo/TestmoStagingService.ts", "../../utils/randomPassword.ts", "../../services/imports/testmo/configuration.ts", "../../app/constants/backend.ts", "../../workers/testmoImport/helpers.ts", "../../workers/testmoImport/configurationImports.ts", "../../workers/testmoImport/automationImports.ts", "../../workers/testmoImport/tagImports.ts", "../../workers/testmoImport/linkImports.ts", "../../workers/testmoImport/templateImports.ts", "../../workers/testmoImport/issueImports.ts"],
  "sourcesContent": ["import { Worker, Job } from \"bullmq\";\nimport { S3Client, GetObjectCommand } from \"@aws-sdk/client-s3\";\nimport {\n  PrismaClient,\n  Prisma,\n  type TestmoImportJob,\n  Access,\n  ApplicationArea,\n  WorkflowScope,\n  WorkflowType,\n} from \"@prisma/client\";\nimport { getSchema } from \"@tiptap/core\";\nimport { DOMParser as PMDOMParser } from \"@tiptap/pm/model\";\nimport { Window as HappyDOMWindow } from \"happy-dom\";\nimport StarterKit from \"@tiptap/starter-kit\";\nimport { Readable } from \"node:stream\";\nimport { pathToFileURL } from \"node:url\";\nimport bcrypt from \"bcrypt\";\nimport {\n  isMultiTenantMode,\n  disconnectAllTenantClients,\n} from \"../lib/multiTenantPrisma\";\nimport valkeyConnection from \"../lib/valkey\";\nimport {\n  TESTMO_IMPORT_QUEUE_NAME,\n  getElasticsearchReindexQueue,\n} from \"../lib/queues\";\nimport type { ReindexJobData } from \"./elasticsearchReindexWorker\";\nimport { analyzeTestmoExport } from \"../services/imports/testmo/TestmoExportAnalyzer\";\nimport type {\n  TestmoDatasetSummary,\n  TestmoMappingConfiguration,\n} from \"../services/imports/testmo/types\";\nimport {\n  normalizeMappingConfiguration,\n  serializeMappingConfiguration,\n} from \"../services/imports/testmo/configuration\";\nimport { generateRandomPassword } from \"../utils/randomPassword\";\nimport { emptyEditorContent } from \"../app/constants/backend\";\nimport {\n  importWorkflows,\n  importGroups,\n  importTags,\n  importRoles,\n  importMilestoneTypes,\n  importConfigurations,\n  importUserGroups,\n} from \"./testmoImport/configurationImports\";\nimport {\n  importAutomationCases,\n  importAutomationRuns,\n  importAutomationRunTests,\n  importAutomationRunFields,\n  importAutomationRunLinks,\n  importAutomationRunTestFields,\n  importAutomationRunTags,\n} from \"./testmoImport/automationImports\";\nimport {\n  importRepositoryCaseTags,\n  importRunTags,\n  importSessionTags,\n} from \"./testmoImport/tagImports\";\nimport {\n  importProjectLinks,\n  importMilestoneLinks,\n  importRunLinks,\n} from \"./testmoImport/linkImports\";\nimport {\n  importTemplates,\n  importTemplateFields,\n} from \"./testmoImport/templateImports\";\nimport {\n  importIssueTargets,\n  importIssues,\n  importMilestoneIssues,\n  importRepositoryCaseIssues,\n  importRunIssues,\n  importRunResultIssues,\n  importSessionIssues,\n  importSessionResultIssues,\n  createProjectIntegrations,\n} from \"./testmoImport/issueImports\";\nimport {\n  toNumberValue,\n  toStringValue,\n  toBooleanValue,\n  toDateValue,\n  buildNumberIdMap,\n  buildStringIdMap,\n  buildTemplateFieldMaps,\n  resolveUserId,\n  toInputJsonValue,\n} from \"./testmoImport/helpers\";\n\n// TODO(testmo-import): Remaining datasets to implement:\n//\n// IMPLEMENTED (32 datasets):\n// - workflows, groups, roles, milestoneTypes, configurations, states, statuses\n// - templates, template_fields\n// - users, user_groups\n// - projects, milestones\n// - sessions, session_results, session_values\n// - repositories, repository_folders, repository_cases, repository_case_values, repository_case_steps\n// - runs, run_tests, run_results, run_result_steps\n// - automation_cases, automation_runs, automation_run_tests, automation_run_fields,\n// - automation_run_test_fields, automation_run_links, automation_run_tags\n// - project_links, milestone_links, run_links\n// - issue_targets, issues, repository_case_issues, run_issues, run_result_issues,\n//   session_issues, session_result_issues\n//\n// SCHEMA LIMITATIONS:\n// - milestone_issues: Milestones model doesn't have issues relation (skipped)\n//\n// AUTOMATION - Testmo automation run data:\n// - automation_sources, automation_run_artifacts\n// - automation_run_test_comments, automation_run_test_comment_issues\n// - automation_run_test_artifacts, automation_run_threads, automation_run_thread_fields\n// - automation_run_thread_artifacts\n//\n// COMMENTS (2 datasets) - Comments on test cases:\n// - repository_case_comments\n// - automation_run_test_comments (see automation above)\n//\n// TAGS\n// - milestone_automation_tags\n\n// TODO(multi-tenant): This worker currently uses a single global Prisma client.\n// For full multi-tenant support, the prisma client would need to be passed through\n// all import functions. This is a significant refactor due to the size and complexity\n// of this import worker. For now, Testmo imports are only supported in single-tenant mode.\nconst prisma = new PrismaClient();\n\nconst projectNameCache = new Map<number, string>();\nconst templateNameCache = new Map<number, string>();\nconst workflowNameCache = new Map<number, string>();\nconst configurationNameCache = new Map<number, string>();\nconst milestoneNameCache = new Map<number, string>();\nconst userNameCache = new Map<string, string>();\nconst folderNameCache = new Map<number, string>();\n\nconst getProjectName = async (\n  tx: Prisma.TransactionClient,\n  projectId: number\n): Promise<string> => {\n  if (projectNameCache.has(projectId)) {\n    return projectNameCache.get(projectId)!;\n  }\n\n  const project = await tx.projects.findUnique({\n    where: { id: projectId },\n    select: { name: true },\n  });\n\n  const name = project?.name ?? `Project ${projectId}`;\n  projectNameCache.set(projectId, name);\n  return name;\n};\n\nconst getTemplateName = async (\n  tx: Prisma.TransactionClient,\n  templateId: number\n): Promise<string> => {\n  if (templateNameCache.has(templateId)) {\n    return templateNameCache.get(templateId)!;\n  }\n\n  const template = await tx.templates.findUnique({\n    where: { id: templateId },\n    select: { templateName: true },\n  });\n\n  const name = template?.templateName ?? `Template ${templateId}`;\n  templateNameCache.set(templateId, name);\n  return name;\n};\n\nconst getWorkflowName = async (\n  tx: Prisma.TransactionClient,\n  workflowId: number\n): Promise<string> => {\n  if (workflowNameCache.has(workflowId)) {\n    return workflowNameCache.get(workflowId)!;\n  }\n\n  const workflow = await tx.workflows.findUnique({\n    where: { id: workflowId },\n    select: { name: true },\n  });\n\n  const name = workflow?.name ?? `Workflow ${workflowId}`;\n  workflowNameCache.set(workflowId, name);\n  return name;\n};\n\nconst getConfigurationName = async (\n  tx: Prisma.TransactionClient,\n  configurationId: number\n): Promise<string | null> => {\n  if (configurationNameCache.has(configurationId)) {\n    return configurationNameCache.get(configurationId)!;\n  }\n\n  const configuration = await tx.configurations.findUnique({\n    where: { id: configurationId },\n    select: { name: true },\n  });\n\n  const name = configuration?.name ?? null;\n  if (name !== null) {\n    configurationNameCache.set(configurationId, name);\n  }\n  return name;\n};\n\nconst getMilestoneName = async (\n  tx: Prisma.TransactionClient,\n  milestoneId: number\n): Promise<string | null> => {\n  if (milestoneNameCache.has(milestoneId)) {\n    return milestoneNameCache.get(milestoneId)!;\n  }\n\n  const milestone = await tx.milestones.findUnique({\n    where: { id: milestoneId },\n    select: { name: true },\n  });\n\n  const name = milestone?.name ?? null;\n  if (name !== null) {\n    milestoneNameCache.set(milestoneId, name);\n  }\n  return name;\n};\n\nconst getUserName = async (\n  tx: Prisma.TransactionClient,\n  userId: string | null | undefined\n): Promise<string> => {\n  if (!userId) {\n    return \"Automation Import\";\n  }\n\n  if (userNameCache.has(userId)) {\n    return userNameCache.get(userId)!;\n  }\n\n  const user = await tx.user.findUnique({\n    where: { id: userId },\n    select: { name: true },\n  });\n\n  const name = user?.name ?? userId;\n  userNameCache.set(userId, name);\n  return name;\n};\n\nconst getFolderName = async (\n  tx: Prisma.TransactionClient,\n  folderId: number\n): Promise<string> => {\n  if (folderNameCache.has(folderId)) {\n    return folderNameCache.get(folderId)!;\n  }\n\n  const folder = await tx.repositoryFolders.findUnique({\n    where: { id: folderId },\n    select: { name: true },\n  });\n\n  const name = folder?.name ?? \"\";\n  folderNameCache.set(folderId, name);\n  return name;\n};\n\nconst parseNumberEnv = (\n  value: string | undefined,\n  fallback: number\n): number => {\n  if (!value) {\n    return fallback;\n  }\n  const parsed = Number(value);\n  return Number.isFinite(parsed) ? parsed : fallback;\n};\n\nconst IMPORT_TRANSACTION_TIMEOUT_MS = parseNumberEnv(\n  process.env.TESTMO_IMPORT_TRANSACTION_TIMEOUT_MS,\n  15 * 60 * 1000\n);\n\nconst AUTOMATION_TRANSACTION_TIMEOUT_MS = parseNumberEnv(\n  process.env.TESTMO_AUTOMATION_TRANSACTION_TIMEOUT_MS,\n  45 * 60 * 1000\n);\n\nconst IMPORT_TRANSACTION_MAX_WAIT_MS = parseNumberEnv(\n  process.env.TESTMO_IMPORT_TRANSACTION_MAX_WAIT_MS,\n  30_000\n);\n\nconst bucketName = process.env.AWS_BUCKET_NAME;\n\nconst s3Client = new S3Client({\n  region: process.env.AWS_REGION || process.env.AWS_BUCKET_REGION,\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,\n  },\n  endpoint: process.env.AWS_PUBLIC_ENDPOINT_URL || process.env.AWS_ENDPOINT_URL,\n  forcePathStyle: Boolean(process.env.AWS_ENDPOINT_URL),\n  maxAttempts: 5, // Retry transient network errors\n});\n\nconst FINAL_STATUSES = new Set([\"COMPLETED\", \"FAILED\", \"CANCELED\"]);\n\nconst VALID_APPLICATION_AREAS = new Set<string>(Object.values(ApplicationArea));\nconst VALID_WORKFLOW_TYPES = new Set<string>(Object.values(WorkflowType));\nconst VALID_WORKFLOW_SCOPES = new Set<string>(Object.values(WorkflowScope));\nconst SYSTEM_NAME_REGEX = /^[A-Za-z][A-Za-z0-9_]*$/;\nconst DEFAULT_STATUS_COLOR_HEX = \"#B1B2B3\";\nconst MAX_INT_32 = 2_147_483_647;\nconst MIN_INT_32 = -2_147_483_648;\n\ninterface ActivitySummaryEntry {\n  type: \"summary\";\n  timestamp: string;\n  entity: string;\n  total: number;\n  created: number;\n  mapped: number;\n  details?: Record<string, unknown>;\n}\n\ninterface ActivityMessageEntry {\n  type: \"message\";\n  timestamp: string;\n  message: string;\n  details?: Record<string, unknown>;\n}\n\ntype ActivityLogEntry = ActivitySummaryEntry | ActivityMessageEntry;\n\ninterface ImportContext {\n  activityLog: ActivityLogEntry[];\n  entityProgress: Record<\n    string,\n    { total: number; created: number; mapped: number }\n  >;\n  processedCount: number;\n  startTime: number;\n  lastProgressUpdate: number;\n  jobId: string;\n  recentProgress: Array<{ timestamp: number; processedCount: number }>;\n}\n\nconst currentTimestamp = () => new Date().toISOString();\n\ntype EntitySummaryResult = Omit<ActivitySummaryEntry, \"type\" | \"timestamp\">;\n\nconst createInitialContext = (jobId: string): ImportContext => ({\n  activityLog: [],\n  entityProgress: {},\n  processedCount: 0,\n  startTime: Date.now(),\n  lastProgressUpdate: Date.now(),\n  jobId,\n  recentProgress: [{ timestamp: Date.now(), processedCount: 0 }],\n});\n\nconst logMessage = (\n  context: ImportContext,\n  message: string,\n  details?: Record<string, unknown>\n) => {\n  context.activityLog.push({\n    type: \"message\",\n    timestamp: currentTimestamp(),\n    message,\n    ...(details ? { details } : {}),\n  });\n};\n\nconst recordEntitySummary = (\n  context: ImportContext,\n  summary: EntitySummaryResult\n) => {\n  const entry: ActivitySummaryEntry = {\n    type: \"summary\",\n    timestamp: currentTimestamp(),\n    ...summary,\n  };\n  context.activityLog.push(entry);\n  const existing = context.entityProgress[summary.entity];\n  const processedTotal = summary.created + summary.mapped;\n  if (existing) {\n    const previousProcessed = existing.created + existing.mapped;\n    existing.total = summary.total;\n    existing.created = summary.created;\n    existing.mapped = summary.mapped;\n    const delta = processedTotal - previousProcessed;\n    if (delta > 0) {\n      context.processedCount += delta;\n    }\n  } else {\n    context.entityProgress[summary.entity] = {\n      total: summary.total,\n      created: summary.created,\n      mapped: summary.mapped,\n    };\n    context.processedCount += processedTotal;\n  }\n};\n\ntype PersistProgressFn = (\n  entity: string | null,\n  statusMessage?: string\n) => Promise<void>;\n\nconst PROGRESS_UPDATE_INTERVAL = 500;\n\nconst REPOSITORY_CASE_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_REPOSITORY_CASE_CHUNK_SIZE,\n  500\n);\n\nconst TEST_RUN_CASE_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_TEST_RUN_CASE_CHUNK_SIZE,\n  500\n);\n\nconst AUTOMATION_CASE_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_AUTOMATION_CASE_CHUNK_SIZE,\n  500\n);\n\nconst AUTOMATION_RUN_TEST_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_AUTOMATION_RUN_TEST_CHUNK_SIZE,\n  2000\n);\n\nconst AUTOMATION_RUN_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_AUTOMATION_RUN_CHUNK_SIZE,\n  500\n);\n\nconst AUTOMATION_RUN_FIELD_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_AUTOMATION_RUN_FIELD_CHUNK_SIZE,\n  500\n);\n\nconst AUTOMATION_RUN_LINK_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_AUTOMATION_RUN_LINK_CHUNK_SIZE,\n  500\n);\n\nconst AUTOMATION_RUN_TEST_FIELD_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_AUTOMATION_RUN_TEST_FIELD_CHUNK_SIZE,\n  500\n);\n\nconst AUTOMATION_RUN_TAG_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_AUTOMATION_RUN_TAG_CHUNK_SIZE,\n  500\n);\n\nconst TEST_RUN_RESULT_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_TEST_RUN_RESULT_CHUNK_SIZE,\n  2000\n);\n\nconst ISSUE_RELATIONSHIP_CHUNK_SIZE = parseNumberEnv(\n  process.env.TESTMO_ISSUE_RELATIONSHIP_CHUNK_SIZE,\n  1000\n);\n\nconst REPOSITORY_FOLDER_TRANSACTION_TIMEOUT_MS = parseNumberEnv(\n  process.env.TESTMO_REPOSITORY_FOLDER_TRANSACTION_TIMEOUT_MS,\n  2 * 60 * 1000\n);\n\nconst initializeEntityProgress = (\n  context: ImportContext,\n  entity: string,\n  total: number\n) => {\n  if (total <= 0) {\n    return;\n  }\n  const existing = context.entityProgress[entity];\n  if (existing) {\n    existing.total = total;\n  } else {\n    context.entityProgress[entity] = {\n      total,\n      created: 0,\n      mapped: 0,\n    };\n  }\n};\n\nconst incrementEntityProgress = (\n  context: ImportContext,\n  entity: string,\n  createdIncrement = 0,\n  mappedIncrement = 0\n) => {\n  const totalIncrement = createdIncrement + mappedIncrement;\n  if (totalIncrement === 0) {\n    return;\n  }\n  const entry =\n    context.entityProgress[entity] ??\n    (context.entityProgress[entity] = {\n      total: totalIncrement,\n      created: 0,\n      mapped: 0,\n    });\n  entry.created += createdIncrement;\n  entry.mapped += mappedIncrement;\n  context.processedCount += totalIncrement;\n};\n\nconst decrementEntityTotal = (context: ImportContext, entity: string) => {\n  const entry = context.entityProgress[entity];\n  if (entry && entry.total > 0) {\n    entry.total -= 1;\n  }\n};\n\nconst formatInProgressStatus = (\n  context: ImportContext,\n  entity: string\n): string | undefined => {\n  const entry = context.entityProgress[entity];\n  if (!entry) {\n    return undefined;\n  }\n  const processed = entry.created + entry.mapped;\n  return `${processed.toLocaleString()} / ${entry.total.toLocaleString()} processed`;\n};\n\nconst calculateProgressMetrics = (\n  context: ImportContext,\n  totalCount: number\n): { estimatedTimeRemaining: string | null; processingRate: string | null } => {\n  const now = Date.now();\n  const elapsedMs = now - context.startTime;\n  const elapsedSeconds = elapsedMs / 1000;\n\n  // Don't calculate estimates until we have at least 2 seconds of data and some progress\n  if (elapsedSeconds < 2 || context.processedCount === 0 || totalCount === 0) {\n    console.log(\n      `[calculateProgressMetrics] Skipping - elapsed: ${elapsedSeconds.toFixed(1)}s, processed: ${context.processedCount}, total: ${totalCount}`\n    );\n    return { estimatedTimeRemaining: null, processingRate: null };\n  }\n\n  const itemsPerSecond = getSmoothedProcessingRate(\n    context,\n    now,\n    elapsedSeconds\n  );\n\n  // Calculate remaining items\n  const remainingCount = totalCount - context.processedCount;\n\n  // Calculate estimated seconds remaining\n  const estimatedSecondsRemaining = remainingCount / itemsPerSecond;\n\n  // Format processing rate\n  const processingRate =\n    itemsPerSecond >= 1\n      ? `${itemsPerSecond.toFixed(1)} items/sec`\n      : `${(itemsPerSecond * 60).toFixed(1)} items/min`;\n\n  // Format estimated time remaining (in seconds)\n  const estimatedTimeRemaining = Math.ceil(\n    estimatedSecondsRemaining\n  ).toString();\n\n  console.log(\n    `[calculateProgressMetrics] Calculated - processed: ${context.processedCount}/${totalCount}, elapsed: ${elapsedSeconds.toFixed(1)}s, rate: ${processingRate}, ETA: ${estimatedTimeRemaining}s`\n  );\n\n  return { estimatedTimeRemaining, processingRate };\n};\n\nconst MAX_RECENT_PROGRESS_ENTRIES = 60;\nconst RECENT_PROGRESS_WINDOW_MS = 60_000;\nconst EMA_ALPHA = 0.3;\n\nconst getSmoothedProcessingRate = (\n  context: ImportContext,\n  now: number,\n  elapsedSeconds: number\n): number => {\n  const recent = context.recentProgress;\n  const lastEntry = recent[recent.length - 1];\n  if (\n    lastEntry.timestamp !== now ||\n    lastEntry.processedCount !== context.processedCount\n  ) {\n    recent.push({ timestamp: now, processedCount: context.processedCount });\n  }\n\n  while (\n    recent.length > MAX_RECENT_PROGRESS_ENTRIES ||\n    (recent.length > 1 && now - recent[1].timestamp > RECENT_PROGRESS_WINDOW_MS)\n  ) {\n    recent.shift();\n  }\n\n  if (recent.length < 2) {\n    return context.processedCount / elapsedSeconds;\n  }\n\n  let smoothedRate = null;\n\n  for (let i = 1; i < recent.length; i += 1) {\n    const prev = recent[i - 1];\n    const current = recent[i];\n    if (current.timestamp <= prev.timestamp) {\n      continue;\n    }\n    const deltaCount = current.processedCount - prev.processedCount;\n    if (deltaCount <= 0) {\n      continue;\n    }\n    const deltaSeconds = (current.timestamp - prev.timestamp) / 1000;\n    if (deltaSeconds <= 0) {\n      continue;\n    }\n    const instantaneousRate = deltaCount / deltaSeconds;\n    if (Number.isFinite(instantaneousRate) && instantaneousRate > 0) {\n      smoothedRate =\n        smoothedRate === null\n          ? instantaneousRate\n          : EMA_ALPHA * instantaneousRate + (1 - EMA_ALPHA) * smoothedRate;\n    }\n  }\n\n  if (smoothedRate === null || !Number.isFinite(smoothedRate)) {\n    smoothedRate = context.processedCount / elapsedSeconds;\n  }\n\n  const totalRate = context.processedCount / elapsedSeconds;\n  return Math.max(smoothedRate, totalRate * 0.2);\n};\n\nconst computeEntityTotals = (\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  datasetRowCounts: Map<string, number>\n): Map<string, number> => {\n  const totals = new Map<string, number>();\n  const countConfigEntries = (entries?: Record<number, unknown>) =>\n    Object.values(entries ?? {}).filter(\n      (entry) => entry !== undefined && entry !== null\n    ).length;\n\n  totals.set(\"workflows\", countConfigEntries(configuration.workflows));\n  totals.set(\"statuses\", countConfigEntries(configuration.statuses));\n  totals.set(\"groups\", countConfigEntries(configuration.groups));\n  totals.set(\"roles\", countConfigEntries(configuration.roles));\n  totals.set(\n    \"milestoneTypes\",\n    countConfigEntries(configuration.milestoneTypes)\n  );\n  totals.set(\n    \"configurations\",\n    countConfigEntries(configuration.configurations)\n  );\n  totals.set(\"templates\", countConfigEntries(configuration.templates));\n  totals.set(\n    \"templateFields\",\n    countConfigEntries(configuration.templateFields)\n  );\n  totals.set(\"tags\", countConfigEntries(configuration.tags));\n  totals.set(\"users\", countConfigEntries(configuration.users));\n\n  const datasetCount = (name: string) => datasetRowCounts.get(name) ?? 0;\n  totals.set(\"userGroups\", datasetCount(\"user_groups\"));\n  totals.set(\"projects\", datasetCount(\"projects\"));\n  totals.set(\"milestones\", datasetCount(\"milestones\"));\n  totals.set(\"sessions\", datasetCount(\"sessions\"));\n  totals.set(\"sessionResults\", datasetCount(\"session_results\"));\n  totals.set(\"repositories\", datasetCount(\"repositories\"));\n  totals.set(\"repositoryFolders\", datasetCount(\"repository_folders\"));\n  totals.set(\"repositoryCases\", datasetCount(\"repository_cases\"));\n  totals.set(\"repositoryCaseTags\", datasetCount(\"repository_case_tags\"));\n  totals.set(\"automationCases\", datasetCount(\"automation_cases\"));\n  totals.set(\"automationRuns\", datasetCount(\"automation_runs\"));\n  totals.set(\"automationRunTests\", datasetCount(\"automation_run_tests\"));\n  totals.set(\"automationRunFields\", datasetCount(\"automation_run_fields\"));\n  totals.set(\"automationRunLinks\", datasetCount(\"automation_run_links\"));\n  totals.set(\n    \"automationRunTestFields\",\n    datasetCount(\"automation_run_test_fields\")\n  );\n  totals.set(\"automationRunTags\", datasetCount(\"automation_run_tags\"));\n  totals.set(\"testRuns\", datasetCount(\"runs\"));\n  totals.set(\"testRunCases\", datasetCount(\"run_tests\"));\n  totals.set(\"testRunResults\", datasetCount(\"run_results\"));\n  totals.set(\"testRunStepResults\", datasetCount(\"run_result_steps\"));\n  totals.set(\"runTags\", datasetCount(\"run_tags\"));\n  totals.set(\"sessionTags\", datasetCount(\"session_tags\"));\n  totals.set(\"issueTargets\", datasetCount(\"issue_targets\"));\n  totals.set(\"issues\", datasetCount(\"issues\"));\n  totals.set(\"milestoneIssues\", datasetCount(\"milestone_issues\"));\n  totals.set(\"repositoryCaseIssues\", datasetCount(\"repository_case_issues\"));\n  totals.set(\"runIssues\", datasetCount(\"run_issues\"));\n  totals.set(\"runResultIssues\", datasetCount(\"run_result_issues\"));\n  totals.set(\"sessionIssues\", datasetCount(\"session_issues\"));\n  totals.set(\"sessionResultIssues\", datasetCount(\"session_result_issues\"));\n  // ProjectIntegrations count is derived from issues dataset\n  totals.set(\"projectIntegrations\", 0); // Will be computed during import\n\n  return totals;\n};\n\nconst releaseDatasetRows = (\n  datasetRows: Map<string, any[]>,\n  ...names: string[]\n) => {\n  for (const name of names) {\n    datasetRows.delete(name);\n  }\n};\n\nconst normalizeEstimate = (\n  value: number | null\n): {\n  value: number | null;\n  adjustment:\n    | \"nanoseconds\"\n    | \"microseconds\"\n    | \"milliseconds\"\n    | \"clamped\"\n    | null;\n} => {\n  if (value === null || !Number.isFinite(value)) {\n    return { value: null, adjustment: null };\n  }\n\n  const rounded = Math.round(value);\n  if (Math.abs(rounded) <= MAX_INT_32) {\n    return { value: rounded, adjustment: null };\n  }\n\n  const scaleCandidates: Array<{\n    factor: number;\n    adjustment: \"nanoseconds\" | \"microseconds\" | \"milliseconds\";\n  }> = [\n    { factor: 1_000_000, adjustment: \"microseconds\" },\n    { factor: 1_000_000_000, adjustment: \"nanoseconds\" },\n    { factor: 1_000, adjustment: \"milliseconds\" },\n  ];\n\n  for (const candidate of scaleCandidates) {\n    const scaled = Math.round(value / candidate.factor);\n    if (Math.abs(scaled) <= MAX_INT_32) {\n      return { value: scaled, adjustment: candidate.adjustment };\n    }\n  }\n\n  return {\n    value: value > 0 ? MAX_INT_32 : MIN_INT_32,\n    adjustment: \"clamped\",\n  };\n};\n\nconst generateSystemName = (value: string): string => {\n  const normalized = value\n    .toLowerCase()\n    .replace(/\\s+/g, \"_\")\n    .replace(/[^a-z0-9_]/g, \"\")\n    .replace(/^[^a-z]+/, \"\");\n  return normalized || \"status\";\n};\n\nconst normalizeColorHex = (value?: string | null): string | null => {\n  if (!value) {\n    return null;\n  }\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n  return trimmed.startsWith(\"#\")\n    ? trimmed.toUpperCase()\n    : `#${trimmed.toUpperCase()}`;\n};\n\nconst isCanonicalRepository = (\n  projectSourceId: number | null,\n  repoSourceId: number | null,\n  canonicalRepoIdByProject: Map<number, Set<number>>\n): boolean => {\n  if (repoSourceId === null) {\n    return true;\n  }\n\n  if (projectSourceId === null) {\n    return true;\n  }\n\n  const canonicalRepoIds = canonicalRepoIdByProject.get(projectSourceId);\n  if (!canonicalRepoIds || canonicalRepoIds.size === 0) {\n    return true;\n  }\n\n  return canonicalRepoIds.has(repoSourceId);\n};\n\nconst getPreferredRepositoryId = (\n  projectSourceId: number | null,\n  repoSourceId: number | null,\n  canonicalRepoIdByProject: Map<number, Set<number>>\n): number | null => {\n  if (projectSourceId === null) {\n    return null;\n  }\n\n  const canonicalRepoIds = canonicalRepoIdByProject.get(projectSourceId);\n  if (!canonicalRepoIds || canonicalRepoIds.size === 0) {\n    return repoSourceId;\n  }\n\n  const iterator = canonicalRepoIds.values().next();\n  const primaryRepoId = iterator.done ? null : (iterator.value ?? null);\n\n  if (primaryRepoId === null) {\n    return repoSourceId;\n  }\n\n  return primaryRepoId;\n};\n\nconst TIPTAP_EXTENSIONS = [\n  StarterKit.configure({\n    dropcursor: false,\n    gapcursor: false,\n    undoRedo: false,\n    trailingNode: false,\n    heading: {\n      levels: [1, 2, 3, 4],\n    },\n  }),\n];\n\n// Reusable Happy-DOM window to avoid creating new contexts for each conversion\n// This dramatically reduces memory usage during large imports\nlet sharedHappyDOMWindow: HappyDOMWindow | null = null;\nlet sharedDOMParser: any = null; // Happy-DOM's DOMParser type differs from browser DOMParser\nlet conversionsSinceCleanup = 0;\nconst CLEANUP_INTERVAL = 1000; // Clean up and recreate window every N conversions\n\nfunction getSharedHappyDOM() {\n  if (\n    !sharedHappyDOMWindow ||\n    !sharedDOMParser ||\n    conversionsSinceCleanup >= CLEANUP_INTERVAL\n  ) {\n    // Clean up old window if it exists\n    if (sharedHappyDOMWindow) {\n      try {\n        sharedHappyDOMWindow.close();\n      } catch (e) {\n        // Ignore cleanup errors\n      }\n    }\n\n    sharedHappyDOMWindow = new HappyDOMWindow();\n    sharedDOMParser = new sharedHappyDOMWindow.DOMParser();\n    conversionsSinceCleanup = 0;\n  }\n\n  conversionsSinceCleanup++;\n  return { window: sharedHappyDOMWindow!, parser: sharedDOMParser! };\n}\n\n// Custom generateJSON that reuses the same Happy-DOM window\nfunction generateJSONOptimized(\n  html: string,\n  extensions: any[],\n  options?: any\n): Record<string, unknown> {\n  const { parser } = getSharedHappyDOM();\n  const schema = getSchema(extensions);\n\n  const htmlString = `<!DOCTYPE html><html><body>${html}</body></html>`;\n  const doc = parser.parseFromString(htmlString, \"text/html\");\n\n  if (!doc) {\n    throw new Error(\"Failed to parse HTML string\");\n  }\n\n  return PMDOMParser.fromSchema(schema).parse(doc.body, options).toJSON();\n}\n\ninterface CaseFieldMetadata {\n  id: number;\n  systemName: string;\n  displayName: string;\n  type: string;\n  optionIds: Set<number>;\n  optionsByName: Map<string, number>;\n}\n\nconst isTipTapDocument = (value: unknown): boolean => {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  const doc = value as { type?: unknown; content?: unknown };\n  if (doc.type !== \"doc\") {\n    return false;\n  }\n  if (!(\"content\" in doc)) {\n    return true;\n  }\n  return Array.isArray(doc.content);\n};\n\nconst TIPTAP_CACHE_LIMIT = 100;\nconst tipTapConversionCache = new Map<string, Record<string, unknown>>();\n\nconst getCachedTipTapDocument = (\n  key: string\n): Record<string, unknown> | undefined => tipTapConversionCache.get(key);\n\nconst cacheTipTapDocument = (\n  key: string,\n  doc: Record<string, unknown>\n): void => {\n  if (tipTapConversionCache.has(key)) {\n    tipTapConversionCache.set(key, doc);\n    return;\n  }\n  if (tipTapConversionCache.size >= TIPTAP_CACHE_LIMIT) {\n    tipTapConversionCache.clear();\n  }\n  tipTapConversionCache.set(key, doc);\n};\n\nconst clearTipTapCache = () => tipTapConversionCache.clear();\n\nconst createParagraphDocument = (text: string): Record<string, unknown> => {\n  const trimmed = text.trim();\n  if (!trimmed) {\n    return emptyEditorContent as Record<string, unknown>;\n  }\n\n  const doc = {\n    type: \"doc\",\n    content: [\n      {\n        type: \"paragraph\",\n        content: [\n          {\n            type: \"text\",\n            text,\n          },\n        ],\n      },\n    ],\n  } as Record<string, unknown>;\n\n  return doc;\n};\n\nconst convertToTipTapDocument = (\n  value: unknown\n): Record<string, unknown> | null => {\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  if (isTipTapDocument(value)) {\n    return value as Record<string, unknown>;\n  }\n\n  if (typeof value === \"string\") {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return emptyEditorContent as Record<string, unknown>;\n    }\n\n    const cachedDoc = getCachedTipTapDocument(trimmed);\n    if (cachedDoc) {\n      return cachedDoc;\n    }\n\n    let candidate: Record<string, unknown> | undefined;\n\n    try {\n      const parsed = JSON.parse(trimmed);\n      if (isTipTapDocument(parsed)) {\n        candidate = parsed as Record<string, unknown>;\n      }\n    } catch {\n      // Not JSON\n    }\n\n    if (!candidate) {\n      try {\n        const generated = generateJSONOptimized(trimmed, TIPTAP_EXTENSIONS);\n        if (isTipTapDocument(generated)) {\n          candidate = generated as Record<string, unknown>;\n        }\n      } catch {\n        // Continue with fallback\n      }\n    }\n\n    if (!candidate) {\n      candidate = createParagraphDocument(trimmed);\n    }\n\n    cacheTipTapDocument(trimmed, candidate);\n    return candidate;\n  }\n\n  if (typeof value === \"object\") {\n    try {\n      const parsed = JSON.parse(JSON.stringify(value));\n      if (isTipTapDocument(parsed)) {\n        return parsed as Record<string, unknown>;\n      }\n    } catch {\n      // Ignore and fall back\n    }\n  }\n\n  return createParagraphDocument(String(value));\n};\n\nconst isTipTapDocumentEmpty = (doc: Record<string, unknown>): boolean => {\n  const content = Array.isArray(doc.content) ? doc.content : [];\n  if (content.length === 0) {\n    return true;\n  }\n\n  if (content.length === 1) {\n    const first = content[0] as { content?: unknown; text?: unknown };\n    const children = Array.isArray(first?.content) ? first?.content : [];\n\n    if (children.length === 0) {\n      const text = typeof first?.text === \"string\" ? first.text.trim() : \"\";\n      return text.length === 0;\n    }\n\n    if (children.length === 1) {\n      const child = children[0] as { text?: unknown };\n      if (typeof child?.text === \"string\" && child.text.trim().length === 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\nconst convertToTipTapJsonValue = (\n  value: unknown\n): Prisma.InputJsonValue | null => {\n  const doc = convertToTipTapDocument(value);\n  if (!doc || isTipTapDocumentEmpty(doc)) {\n    return null;\n  }\n  return doc as Prisma.InputJsonValue;\n};\n\nconst convertToTipTapJsonString = (value: unknown): string | null => {\n  const doc = convertToTipTapDocument(value);\n  if (!doc || isTipTapDocumentEmpty(doc)) {\n    return null;\n  }\n  return JSON.stringify(doc);\n};\n\nconst parseBooleanValue = (value: unknown): boolean => {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value !== 0;\n  }\n  if (typeof value === \"string\") {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return false;\n    }\n    return [\"1\", \"true\", \"yes\", \"y\", \"on\"].includes(normalized);\n  }\n  return Boolean(value);\n};\n\nconst parseIntegerValue = (value: unknown): number | null => {\n  if (value === null || value === undefined || value === \"\") {\n    return null;\n  }\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) {\n    return null;\n  }\n  return Math.trunc(parsed);\n};\n\nconst parseFloatValue = (value: unknown): number | null => {\n  if (value === null || value === undefined || value === \"\") {\n    return null;\n  }\n  const parsed = Number(value);\n  return Number.isFinite(parsed) ? parsed : null;\n};\n\nconst parseDateValueToISOString = (value: unknown): string | null => {\n  if (value instanceof Date) {\n    return Number.isNaN(value.getTime()) ? null : value.toISOString();\n  }\n\n  if (typeof value === \"number\") {\n    const date = new Date(value);\n    return Number.isNaN(date.getTime()) ? null : date.toISOString();\n  }\n\n  if (typeof value !== \"string\") {\n    return null;\n  }\n\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return null;\n  }\n\n  const candidates = [\n    trimmed,\n    trimmed.replace(/ /g, \"T\"),\n    `${trimmed.replace(/ /g, \"T\")}Z`,\n  ];\n\n  for (const candidate of candidates) {\n    const date = new Date(candidate);\n    if (!Number.isNaN(date.getTime())) {\n      return date.toISOString();\n    }\n  }\n\n  return null;\n};\n\nconst normalizeDropdownValue = (\n  value: unknown,\n  metadata: CaseFieldMetadata,\n  logWarning: (message: string, details: Record<string, unknown>) => void\n): number | null => {\n  if (value === null || value === undefined || value === \"\") {\n    return null;\n  }\n\n  if (typeof value === \"number\" && metadata.optionIds.has(value)) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n\n    const numeric = Number(trimmed);\n    if (Number.isFinite(numeric) && metadata.optionIds.has(numeric)) {\n      return numeric;\n    }\n\n    const optionIdByName = metadata.optionsByName.get(trimmed.toLowerCase());\n    if (optionIdByName !== undefined) {\n      return optionIdByName;\n    }\n\n    logWarning(\"Unrecognized dropdown option\", {\n      field: metadata.systemName,\n      displayName: metadata.displayName,\n      value,\n      availableOptions: Array.from(metadata.optionsByName.keys()),\n    });\n    return null;\n  }\n\n  if (typeof value === \"object\") {\n    const serialized = String(value);\n    return normalizeDropdownValue(serialized, metadata, logWarning);\n  }\n\n  return null;\n};\n\nconst convertToArray = (value: unknown): unknown[] => {\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return [];\n    }\n\n    try {\n      const parsed = JSON.parse(trimmed);\n      if (Array.isArray(parsed)) {\n        return parsed;\n      }\n    } catch {\n      // Not JSON, continue with splitting logic\n    }\n\n    return trimmed\n      .split(/[;,|]/g)\n      .map((entry) => entry.trim())\n      .filter(Boolean);\n  }\n\n  return [value];\n};\n\nconst normalizeMultiSelectValue = (\n  value: unknown,\n  metadata: CaseFieldMetadata,\n  logWarning: (message: string, details: Record<string, unknown>) => void\n): number[] | null => {\n  if (value === null || value === undefined || value === \"\") {\n    return null;\n  }\n\n  const entries = convertToArray(value);\n  const optionIds: number[] = [];\n\n  for (const entry of entries) {\n    if (entry === null || entry === undefined || entry === \"\") {\n      continue;\n    }\n\n    // Note: After resolving Testmo IDs to names in normalizeCaseFieldValue,\n    // entries should be strings (option names), not numbers\n    if (typeof entry === \"number\" && metadata.optionIds.has(entry)) {\n      // This case handles if we already have TestPlanIt option IDs\n      optionIds.push(entry);\n      continue;\n    }\n\n    if (typeof entry === \"string\") {\n      const trimmed = entry.trim();\n      if (!trimmed) {\n        continue;\n      }\n\n      // Try to parse as number first (in case it's a TestPlanIt option ID as string)\n      const numeric = Number(trimmed);\n      if (Number.isFinite(numeric) && metadata.optionIds.has(numeric)) {\n        optionIds.push(numeric);\n        continue;\n      }\n\n      // Look up by name (this is the main path after Testmo ID resolution)\n      const optionIdByName = metadata.optionsByName.get(trimmed.toLowerCase());\n      if (optionIdByName !== undefined) {\n        optionIds.push(optionIdByName);\n        continue;\n      }\n\n      logWarning(\"Unrecognized multi-select option\", {\n        field: metadata.systemName,\n        displayName: metadata.displayName,\n        value: trimmed,\n        availableOptions: Array.from(metadata.optionsByName.keys()),\n      });\n      continue;\n    }\n\n    logWarning(\"Unsupported multi-select option value\", {\n      field: metadata.systemName,\n      displayName: metadata.displayName,\n      value: entry,\n      entryType: typeof entry,\n    });\n  }\n\n  return optionIds.length > 0 ? Array.from(new Set(optionIds)) : null;\n};\n\nconst normalizeCaseFieldValue = (\n  value: unknown,\n  metadata: CaseFieldMetadata,\n  logWarning: (message: string, details: Record<string, unknown>) => void,\n  testmoFieldValueMap?: Map<number, { fieldId: number; name: string }>\n): unknown => {\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  const fieldType = metadata.type.toLowerCase();\n\n  if (fieldType.includes(\"text long\") || fieldType.includes(\"text (long)\")) {\n    // Convert to TipTap JSON and then stringify it to match how AddCase.tsx stores it\n    const jsonValue = convertToTipTapJsonValue(value);\n    if (jsonValue === null) {\n      return null;\n    }\n    // TODO: Refactor Long Text field storage throughout the application\n    // Currently, the app stores TipTap JSON as stringified JSON in JSONB columns,\n    // which is inefficient. We should store them as proper JSON objects instead.\n    // This affects AddCase.tsx, RenderField.tsx, and many other components.\n    // For now, we stringify to match existing behavior, but this should be fixed.\n    return JSON.stringify(jsonValue);\n  }\n\n  if (fieldType.includes(\"text string\") || fieldType === \"string\") {\n    return String(value);\n  }\n\n  if (fieldType === \"integer\") {\n    return parseIntegerValue(value);\n  }\n\n  if (fieldType === \"number\") {\n    return parseFloatValue(value);\n  }\n\n  if (fieldType === \"checkbox\") {\n    return parseBooleanValue(value);\n  }\n\n  if (fieldType === \"dropdown\") {\n    // If value is a number and we have a Testmo field value map, try to resolve it\n    // This includes Priority which uses field_value IDs just like other dropdowns\n    if (typeof value === \"number\" && testmoFieldValueMap) {\n      const testmoFieldValue = testmoFieldValueMap.get(value);\n      if (testmoFieldValue) {\n        // Use the name from the Testmo field value to lookup in TestPlanIt options\n        const result = normalizeDropdownValue(\n          testmoFieldValue.name,\n          metadata,\n          logWarning\n        );\n        return result;\n      }\n    }\n\n    const result = normalizeDropdownValue(value, metadata, logWarning);\n    return result;\n  }\n\n  const normalizedType = fieldType.replace(/\\s+/g, \"-\");\n  if (normalizedType === \"multi-select\") {\n    // For multi-select, we need to handle arrays of Testmo field value IDs\n    if (testmoFieldValueMap && testmoFieldValueMap.size > 0) {\n      const processedValue = Array.isArray(value) ? value : [value];\n\n      const resolvedValues = processedValue.map((v) => {\n        if (typeof v === \"number\") {\n          const testmoFieldValue = testmoFieldValueMap.get(v);\n          if (testmoFieldValue) {\n            return testmoFieldValue.name;\n          } else {\n            return v;\n          }\n        }\n        return v;\n      });\n\n      const result = normalizeMultiSelectValue(\n        resolvedValues,\n        metadata,\n        logWarning\n      );\n      return result;\n    }\n\n    const result = normalizeMultiSelectValue(value, metadata, logWarning);\n    return result;\n  }\n\n  if (fieldType === \"date\") {\n    return parseDateValueToISOString(value);\n  }\n\n  if (fieldType === \"link\") {\n    return String(value);\n  }\n\n  if (fieldType === \"steps\") {\n    // Steps are handled separately via repository_case_steps dataset\n    return undefined;\n  }\n\n  return value;\n};\n\nasync function importUsers(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  importJob: TestmoImportJob\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"users\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const validAccessValues = new Set<string>(Object.values(Access));\n\n  const resolveAccess = (value?: Access | null): Access => {\n    if (value && validAccessValues.has(value)) {\n      return value;\n    }\n    return Access.USER;\n  };\n\n  const ensureRoleExists = async (roleId: number): Promise<void> => {\n    const role = await tx.roles.findUnique({ where: { id: roleId } });\n    if (!role) {\n      throw new Error(`Role ${roleId} selected for a user does not exist.`);\n    }\n  };\n\n  const resolveRoleId = async (\n    configRoleId?: number | null\n  ): Promise<number> => {\n    if (configRoleId && Number.isFinite(configRoleId)) {\n      await ensureRoleExists(configRoleId);\n      return configRoleId;\n    }\n\n    const defaultRole = await tx.roles.findFirst({\n      where: { isDefault: true },\n    });\n    if (!defaultRole) {\n      throw new Error(\"No default role is configured. Unable to create users.\");\n    }\n    return defaultRole.id;\n  };\n\n  for (const [key, config] of Object.entries(configuration.users ?? {})) {\n    const userId = Number(key);\n    if (!Number.isFinite(userId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    if (config.action === \"map\") {\n      if (!config.mappedTo) {\n        throw new Error(\n          `User ${userId} is configured to map but no target user was provided.`\n        );\n      }\n\n      const existing = await tx.user.findUnique({\n        where: { id: config.mappedTo },\n      });\n      if (!existing) {\n        throw new Error(\n          `User ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      config.mappedTo = existing.id;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const email = (config.email ?? \"\").trim().toLowerCase();\n    if (!email) {\n      throw new Error(\n        `User ${userId} requires an email address before creation.`\n      );\n    }\n\n    const existingByEmail = await tx.user.findUnique({ where: { email } });\n    if (existingByEmail) {\n      config.action = \"map\";\n      config.mappedTo = existingByEmail.id;\n      config.email = existingByEmail.email;\n      config.name = existingByEmail.name;\n      config.access = existingByEmail.access;\n      config.roleId = existingByEmail.roleId;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (config.name ?? \"\").trim() || email;\n    const access = resolveAccess(config.access ?? null);\n    const roleId = await resolveRoleId(config.roleId ?? null);\n    const isActive = config.isActive ?? true;\n    const isApi = config.isApi ?? false;\n\n    const password = config.password ?? generateRandomPassword();\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    const created = await tx.user.create({\n      data: {\n        name,\n        email,\n        password: hashedPassword,\n        access,\n        roleId,\n        isActive,\n        isApi,\n        emailVerified: new Date(),\n        createdById: importJob.createdById,\n      },\n    });\n\n    config.action = \"map\";\n    config.mappedTo = created.id;\n    config.password = null;\n    config.name = created.name;\n    config.email = created.email;\n    config.access = created.access;\n    config.roleId = created.roleId;\n    config.isActive = created.isActive;\n    config.isApi = created.isApi;\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\ninterface ProjectsImportResult {\n  summary: EntitySummaryResult;\n  projectIdMap: Map<number, number>;\n  defaultTemplateIdByProject: Map<number, number | null>;\n}\n\ninterface RepositoriesImportResult {\n  summary: EntitySummaryResult;\n  repositoryIdMap: Map<number, number>;\n  canonicalRepoIdByProject: Map<number, Set<number>>;\n  masterRepositoryIds: Set<number>;\n}\n\ninterface RepositoryFoldersImportResult {\n  summary: EntitySummaryResult;\n  folderIdMap: Map<number, number>;\n  repositoryRootFolderMap: Map<number, number>;\n}\n\ninterface TestRunsImportResult {\n  summary: EntitySummaryResult;\n  testRunIdMap: Map<number, number>;\n}\n\ninterface TestRunCasesImportResult {\n  summary: EntitySummaryResult;\n  testRunCaseIdMap: Map<number, number>;\n}\n\ninterface RepositoryCasesImportResult {\n  summary: EntitySummaryResult;\n  caseIdMap: Map<number, number>;\n  caseFieldMap: Map<string, number>;\n  caseFieldMetadataById: Map<number, CaseFieldMetadata>;\n  caseMetaMap: Map<number, { projectId: number; name: string }>;\n}\n\ninterface MilestonesImportResult {\n  summary: EntitySummaryResult;\n  milestoneIdMap: Map<number, number>;\n}\n\nconst importProjects = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  importJob: TestmoImportJob,\n  userIdMap: Map<number, string>,\n  statusIdMap: Map<number, number>,\n  workflowIdMap: Map<number, number>,\n  milestoneTypeIdMap: Map<number, number>,\n  templateIdMap: Map<number, number>,\n  templateMap: Map<string, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<ProjectsImportResult> => {\n  const projectRows = datasetRows.get(\"projects\") ?? [];\n  const summary: EntitySummaryResult = {\n    entity: \"projects\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n  const projectIdMap = new Map<number, number>();\n  const defaultTemplateIdByProject = new Map<number, number | null>();\n\n  if (projectRows.length === 0) {\n    logMessage(context, \"No projects dataset found; skipping project import.\");\n    return { summary, projectIdMap, defaultTemplateIdByProject };\n  }\n\n  initializeEntityProgress(context, \"projects\", projectRows.length);\n  let processedSinceLastPersist = 0;\n\n  const templateIdsToAssign = new Set<number>(templateIdMap.values());\n  for (const templateId of templateMap.values()) {\n    templateIdsToAssign.add(templateId);\n  }\n\n  const defaultTemplateRecord = await tx.templates.findFirst({\n    where: {\n      isDefault: true,\n      isDeleted: false,\n    },\n    select: { id: true },\n  });\n  if (defaultTemplateRecord?.id) {\n    templateIdsToAssign.add(defaultTemplateRecord.id);\n  }\n\n  const workflowIdsToAssign = new Set<number>(workflowIdMap.values());\n  const defaultCaseWorkflow = await tx.workflows.findFirst({\n    where: {\n      isDefault: true,\n      isDeleted: false,\n      scope: WorkflowScope.CASES,\n    },\n    select: { id: true },\n  });\n  if (defaultCaseWorkflow?.id) {\n    workflowIdsToAssign.add(defaultCaseWorkflow.id);\n  }\n\n  const milestoneTypeIdsToAssign = new Set<number>(milestoneTypeIdMap.values());\n  const defaultMilestoneType = await tx.milestoneTypes.findFirst({\n    where: {\n      isDefault: true,\n      isDeleted: false,\n    },\n    select: { id: true },\n  });\n  if (defaultMilestoneType?.id) {\n    milestoneTypeIdsToAssign.add(defaultMilestoneType.id);\n  }\n\n  for (const row of projectRows) {\n    const record = row as Record<string, unknown>;\n    const sourceId = toNumberValue(record.id);\n    if (sourceId === null) {\n      continue;\n    }\n\n    const name = toStringValue(record.name) ?? `Imported Project ${sourceId}`;\n\n    const existing = await tx.projects.findUnique({ where: { name } });\n\n    let projectId: number;\n    if (existing) {\n      projectId = existing.id;\n      projectIdMap.set(sourceId, projectId);\n      summary.total += 1;\n      summary.mapped += 1;\n      incrementEntityProgress(context, \"projects\", 0, 1);\n      processedSinceLastPersist += 1;\n    } else {\n      const createdBy = resolveUserId(\n        userIdMap,\n        importJob.createdById,\n        record.created_by\n      );\n      const createdAt = toDateValue(record.created_at) ?? new Date();\n      const completedAt = toDateValue(record.completed_at);\n      const note = toStringValue(record.note);\n      const docs = toStringValue(record.docs);\n      const isCompleted = toBooleanValue(record.is_completed);\n\n      const project = await tx.projects.create({\n        data: {\n          name,\n          note: note ?? null,\n          docs: docs ?? null,\n          isCompleted,\n          createdBy,\n          createdAt,\n          completedAt: completedAt ?? undefined,\n        },\n      });\n\n      projectId = project.id;\n      projectIdMap.set(sourceId, project.id);\n      summary.total += 1;\n      summary.created += 1;\n      incrementEntityProgress(context, \"projects\", 1, 0);\n      processedSinceLastPersist += 1;\n    }\n\n    if (statusIdMap.size > 0) {\n      const statusAssignments = Array.from(statusIdMap.values()).map(\n        (statusId) => ({\n          projectId,\n          statusId,\n        })\n      );\n      await tx.projectStatusAssignment.createMany({\n        data: statusAssignments,\n        skipDuplicates: true,\n      });\n    }\n\n    if (workflowIdsToAssign.size > 0) {\n      const workflowAssignments = Array.from(workflowIdsToAssign).map(\n        (workflowId) => ({\n          projectId,\n          workflowId,\n        })\n      );\n      await tx.projectWorkflowAssignment.createMany({\n        data: workflowAssignments,\n        skipDuplicates: true,\n      });\n    }\n\n    if (milestoneTypeIdsToAssign.size > 0) {\n      const milestoneAssignments = Array.from(milestoneTypeIdsToAssign).map(\n        (milestoneTypeId) => ({\n          projectId,\n          milestoneTypeId,\n        })\n      );\n      await tx.milestoneTypesAssignment.createMany({\n        data: milestoneAssignments,\n        skipDuplicates: true,\n      });\n    }\n\n    if (templateIdsToAssign.size > 0) {\n      const templateAssignments = Array.from(templateIdsToAssign).map(\n        (templateId) => ({\n          templateId,\n          projectId,\n        })\n      );\n      await tx.templateProjectAssignment.createMany({\n        data: templateAssignments,\n        skipDuplicates: true,\n      });\n    }\n\n    let resolvedDefaultTemplateId: number | null = null;\n    if (defaultTemplateRecord?.id) {\n      resolvedDefaultTemplateId = defaultTemplateRecord.id;\n    } else {\n      const fallbackAssignment = await tx.templateProjectAssignment.findFirst({\n        where: { projectId },\n        select: { templateId: true },\n        orderBy: { templateId: \"asc\" },\n      });\n      resolvedDefaultTemplateId = fallbackAssignment?.templateId ?? null;\n    }\n\n    if (!resolvedDefaultTemplateId) {\n      const fallbackTemplate = await tx.templates.findFirst({\n        where: { isDeleted: false },\n        select: { id: true },\n        orderBy: { id: \"asc\" },\n      });\n      if (fallbackTemplate?.id) {\n        try {\n          await tx.templateProjectAssignment.create({\n            data: {\n              projectId,\n              templateId: fallbackTemplate.id,\n            },\n          });\n        } catch (error) {\n          // Ignore duplicate errors\n        }\n        resolvedDefaultTemplateId = fallbackTemplate.id;\n      }\n    }\n\n    defaultTemplateIdByProject.set(projectId, resolvedDefaultTemplateId);\n\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      const message = formatInProgressStatus(context, \"projects\");\n      await persistProgress(\"projects\", message);\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"projects\");\n    await persistProgress(\"projects\", message);\n  }\n\n  return { summary, projectIdMap, defaultTemplateIdByProject };\n};\n\nconst importMilestones = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  milestoneTypeIdMap: Map<number, number>,\n  userIdMap: Map<number, string>,\n  importJob: TestmoImportJob,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<MilestonesImportResult> => {\n  const milestoneRows = datasetRows.get(\"milestones\") ?? [];\n  const summary: EntitySummaryResult = {\n    entity: \"milestones\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const milestoneIdMap = new Map<number, number>();\n\n  if (milestoneRows.length === 0) {\n    logMessage(\n      context,\n      \"No milestones dataset found; skipping milestone import.\"\n    );\n    return { summary, milestoneIdMap };\n  }\n\n  initializeEntityProgress(context, \"milestones\", milestoneRows.length);\n  let processedSinceLastPersist = 0;\n\n  const defaultMilestoneType = await tx.milestoneTypes.findFirst({\n    where: { isDefault: true },\n    select: { id: true },\n  });\n  const fallbackMilestoneTypeId = defaultMilestoneType?.id ?? null;\n\n  type PendingRelation = {\n    milestoneId: number;\n    parentSourceId: number | null;\n    rootSourceId: number | null;\n  };\n\n  const pendingRelations: PendingRelation[] = [];\n\n  for (const row of milestoneRows) {\n    const record = row as Record<string, unknown>;\n    const sourceId = toNumberValue(record.id);\n    const projectSourceId = toNumberValue(record.project_id);\n    const typeSourceId = toNumberValue(record.type_id);\n\n    if (sourceId === null || projectSourceId === null) {\n      continue;\n    }\n\n    const projectId = projectIdMap.get(projectSourceId);\n    if (!projectId) {\n      logMessage(context, \"Skipping milestone due to missing project mapping\", {\n        sourceId,\n        projectSourceId,\n      });\n      decrementEntityTotal(context, \"milestones\");\n      continue;\n    }\n\n    const resolvedMilestoneTypeId =\n      typeSourceId !== null\n        ? (milestoneTypeIdMap.get(typeSourceId) ?? fallbackMilestoneTypeId)\n        : fallbackMilestoneTypeId;\n\n    if (!resolvedMilestoneTypeId) {\n      logMessage(\n        context,\n        \"Skipping milestone due to missing milestone type mapping\",\n        {\n          sourceId,\n          typeSourceId,\n        }\n      );\n      decrementEntityTotal(context, \"milestones\");\n      continue;\n    }\n\n    const name = toStringValue(record.name) ?? `Imported Milestone ${sourceId}`;\n    const note = convertToTipTapJsonString(record.note);\n    const docs = convertToTipTapJsonString(record.docs);\n    const isStarted = toBooleanValue(record.is_started);\n    const isCompleted = toBooleanValue(record.is_completed);\n    const startedAt = toDateValue(record.started_at);\n    const completedAt = toDateValue(record.completed_at);\n    const createdAt = toDateValue(record.created_at) ?? new Date();\n    const createdBy = resolveUserId(\n      userIdMap,\n      importJob.createdById,\n      record.created_by\n    );\n\n    const existingMilestone = await tx.milestones.findFirst({\n      where: {\n        projectId,\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (existingMilestone) {\n      milestoneIdMap.set(sourceId, existingMilestone.id);\n      summary.total += 1;\n      summary.mapped += 1;\n      incrementEntityProgress(context, \"milestones\", 0, 1);\n      processedSinceLastPersist += 1;\n      if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n        const message = formatInProgressStatus(context, \"milestones\");\n        await persistProgress(\"milestones\", message);\n        processedSinceLastPersist = 0;\n      }\n      continue;\n    }\n\n    const milestone = await tx.milestones.create({\n      data: {\n        projectId,\n        milestoneTypesId: resolvedMilestoneTypeId,\n        name,\n        note: note ?? undefined,\n        docs: docs ?? undefined,\n        isStarted,\n        isCompleted,\n        startedAt: startedAt ?? undefined,\n        completedAt: completedAt ?? undefined,\n        createdAt,\n        createdBy,\n      },\n    });\n\n    milestoneIdMap.set(sourceId, milestone.id);\n    pendingRelations.push({\n      milestoneId: milestone.id,\n      parentSourceId: toNumberValue(record.parent_id),\n      rootSourceId: toNumberValue(record.root_id),\n    });\n\n    summary.total += 1;\n    summary.created += 1;\n\n    incrementEntityProgress(context, \"milestones\", 1, 0);\n    processedSinceLastPersist += 1;\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      const message = formatInProgressStatus(context, \"milestones\");\n      await persistProgress(\"milestones\", message);\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  for (const relation of pendingRelations) {\n    const parentId =\n      relation.parentSourceId !== null\n        ? (milestoneIdMap.get(relation.parentSourceId) ?? null)\n        : null;\n    const rootId =\n      relation.rootSourceId !== null\n        ? (milestoneIdMap.get(relation.rootSourceId) ?? null)\n        : null;\n\n    if (parentId !== null || rootId !== null) {\n      await tx.milestones.update({\n        where: { id: relation.milestoneId },\n        data: {\n          parentId: parentId ?? undefined,\n          rootId: rootId ?? undefined,\n        },\n      });\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"milestones\");\n    await persistProgress(\"milestones\", message);\n  }\n\n  return { summary, milestoneIdMap };\n};\n\ninterface SessionsImportResult {\n  summary: EntitySummaryResult;\n  sessionIdMap: Map<number, number>;\n}\n\nconst importSessions = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  milestoneIdMap: Map<number, number>,\n  configurationIdMap: Map<number, number>,\n  workflowIdMap: Map<number, number>,\n  userIdMap: Map<number, string>,\n  templateIdMap: Map<number, number>,\n  importJob: TestmoImportJob,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<SessionsImportResult> => {\n  const sessionRows = datasetRows.get(\"sessions\") ?? [];\n  const summary: EntitySummaryResult = {\n    entity: \"sessions\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const sessionIdMap = new Map<number, number>();\n\n  if (sessionRows.length === 0) {\n    logMessage(context, \"No sessions dataset found; skipping session import.\");\n    return { summary, sessionIdMap };\n  }\n\n  initializeEntityProgress(context, \"sessions\", sessionRows.length);\n  let processedSinceLastPersist = 0;\n\n  // Get the default template for Sessions - try to find Exploratory or any enabled template\n  const defaultTemplate = await tx.templates.findFirst({\n    where: {\n      OR: [\n        { templateName: \"Exploratory\" },\n        { isDefault: true },\n        { isEnabled: true },\n      ],\n      isDeleted: false,\n    },\n    select: { id: true },\n  });\n\n  // Get a default workflow state for sessions\n  const defaultWorkflowState = await tx.workflows.findFirst({\n    where: {\n      scope: WorkflowScope.SESSIONS,\n      isDeleted: false,\n    },\n    select: { id: true },\n  });\n\n  for (const row of sessionRows) {\n    const record = row as Record<string, unknown>;\n    const sourceId = toNumberValue(record.id);\n    const projectSourceId = toNumberValue(record.project_id);\n    const templateSourceId = toNumberValue(record.template_id);\n    const stateSourceId = toNumberValue(record.state_id);\n\n    if (sourceId === null || projectSourceId === null) {\n      continue;\n    }\n\n    const projectId = projectIdMap.get(projectSourceId);\n    if (!projectId) {\n      logMessage(context, \"Skipping session due to missing project mapping\", {\n        sourceId,\n        projectSourceId,\n      });\n      decrementEntityTotal(context, \"sessions\");\n      continue;\n    }\n\n    // Resolve template ID - use mapped template or default exploratory template\n    let resolvedTemplateId = defaultTemplate?.id;\n    if (templateSourceId !== null && templateIdMap.has(templateSourceId)) {\n      resolvedTemplateId = templateIdMap.get(templateSourceId);\n    }\n\n    if (!resolvedTemplateId) {\n      logMessage(context, \"Skipping session due to missing template\", {\n        sourceId,\n        templateSourceId,\n      });\n      decrementEntityTotal(context, \"sessions\");\n      continue;\n    }\n\n    // Resolve workflow state\n    let resolvedStateId = defaultWorkflowState?.id;\n    if (stateSourceId !== null && workflowIdMap.has(stateSourceId)) {\n      resolvedStateId = workflowIdMap.get(stateSourceId);\n    }\n\n    if (!resolvedStateId) {\n      logMessage(context, \"Skipping session due to missing workflow state\", {\n        sourceId,\n        stateSourceId,\n      });\n      decrementEntityTotal(context, \"sessions\");\n      continue;\n    }\n\n    const name = toStringValue(record.name) ?? `Imported Session ${sourceId}`;\n    const note = convertToTipTapJsonString(record.note);\n    const mission = convertToTipTapJsonString(record.custom_mission);\n\n    // Convert microseconds to seconds for estimate, forecast, and elapsed\n    const estimateRaw = toNumberValue(record.estimate);\n    const estimate =\n      estimateRaw !== null ? Math.floor(estimateRaw / 1000000) : null;\n    const forecastRaw = toNumberValue(record.forecast);\n    const forecast =\n      forecastRaw !== null ? Math.floor(forecastRaw / 1000000) : null;\n    const elapsedRaw = toNumberValue(record.elapsed);\n    const elapsed =\n      elapsedRaw !== null ? Math.floor(elapsedRaw / 1000000) : null;\n\n    const isCompleted = toBooleanValue(record.is_closed);\n    const completedAt = isCompleted ? toDateValue(record.closed_at) : null;\n    const createdAt = toDateValue(record.created_at) ?? new Date();\n    const createdBy = resolveUserId(\n      userIdMap,\n      importJob.createdById,\n      record.created_by\n    );\n\n    // Resolve milestone if present\n    const milestoneSourceId = toNumberValue(record.milestone_id);\n    let milestoneId = null;\n    if (milestoneSourceId !== null) {\n      milestoneId = milestoneIdMap.get(milestoneSourceId) ?? null;\n    }\n\n    // Resolve configuration if present\n    const configSourceId = toNumberValue(record.config_id);\n    let configId = null;\n    if (configSourceId !== null) {\n      configId = configurationIdMap.get(configSourceId) ?? null;\n    }\n\n    // Resolve assignee if present\n    const assigneeSourceId = toNumberValue(record.assignee_id);\n    let assignedToId = null;\n    if (assigneeSourceId !== null) {\n      assignedToId = userIdMap.get(assigneeSourceId) ?? null;\n    }\n\n    // Check if a similar session already exists\n    const existingSession = await tx.sessions.findFirst({\n      where: {\n        projectId,\n        name,\n        isDeleted: false,\n      },\n      select: { id: true },\n    });\n\n    let sessionId: number;\n    if (existingSession) {\n      sessionId = existingSession.id;\n      summary.mapped += 1;\n      incrementEntityProgress(context, \"sessions\", 0, 1);\n    } else {\n      const session = await tx.sessions.create({\n        data: {\n          projectId,\n          templateId: resolvedTemplateId,\n          name,\n          note: note ?? undefined,\n          mission: mission ?? undefined,\n          configId,\n          milestoneId,\n          stateId: resolvedStateId,\n          assignedToId,\n          estimate,\n          forecastManual: forecast,\n          elapsed,\n          isCompleted,\n          completedAt,\n          createdAt,\n          createdById: createdBy,\n        },\n      });\n      sessionId = session.id;\n      summary.created += 1;\n      incrementEntityProgress(context, \"sessions\", 1, 0);\n\n      const projectName = await getProjectName(tx, projectId);\n      const templateName = await getTemplateName(tx, resolvedTemplateId);\n      const workflowName = await getWorkflowName(tx, resolvedStateId);\n      const configurationName = configId\n        ? await getConfigurationName(tx, configId)\n        : null;\n      const milestoneNameResolved = milestoneId\n        ? await getMilestoneName(tx, milestoneId)\n        : null;\n      const assignedToNameResolved = assignedToId\n        ? await getUserName(tx, assignedToId)\n        : null;\n      const createdByName = await getUserName(tx, createdBy);\n\n      await tx.sessionVersions.create({\n        data: {\n          session: { connect: { id: session.id } },\n          name,\n          staticProjectId: projectId,\n          staticProjectName: projectName,\n          project: { connect: { id: projectId } },\n          templateId: resolvedTemplateId,\n          templateName,\n          configId: configId ?? null,\n          configurationName,\n          milestoneId: milestoneId ?? null,\n          milestoneName: milestoneNameResolved,\n          stateId: resolvedStateId,\n          stateName: workflowName,\n          assignedToId: assignedToId ?? null,\n          assignedToName: assignedToNameResolved,\n          createdById: createdBy,\n          createdByName,\n          estimate,\n          forecastManual: forecast,\n          forecastAutomated: null,\n          elapsed,\n          note: note ?? JSON.stringify(emptyEditorContent),\n          mission: mission ?? JSON.stringify(emptyEditorContent),\n          isCompleted,\n          completedAt,\n          version: session.currentVersion ?? 1,\n          tags: JSON.stringify([]),\n          attachments: JSON.stringify([]),\n          issues: JSON.stringify([]),\n        },\n      });\n    }\n\n    sessionIdMap.set(sourceId, sessionId);\n    processedSinceLastPersist += 1;\n\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      const message = formatInProgressStatus(context, \"sessions\");\n      await persistProgress(\"sessions\", message);\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"sessions\");\n    await persistProgress(\"sessions\", message);\n  }\n\n  return { summary, sessionIdMap };\n};\n\ninterface SessionResultsImportResult {\n  summary: EntitySummaryResult;\n  sessionResultIdMap: Map<number, number>;\n}\n\nconst importSessionResults = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  sessionIdMap: Map<number, number>,\n  statusIdMap: Map<number, number>,\n  userIdMap: Map<number, string>,\n  importJob: TestmoImportJob,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<SessionResultsImportResult> => {\n  const sessionResultRows = datasetRows.get(\"session_results\") ?? [];\n  const summary: EntitySummaryResult = {\n    entity: \"sessionResults\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n  const sessionResultIdMap = new Map<number, number>();\n\n  if (sessionResultRows.length === 0) {\n    logMessage(context, \"No session results found; skipping.\");\n    return { summary, sessionResultIdMap };\n  }\n\n  // Get the default \"untested\" status to use when source status is null\n  const untestedStatus = await tx.status.findFirst({\n    where: { systemName: \"untested\" },\n    select: { id: true },\n  });\n\n  if (!untestedStatus) {\n    throw new Error(\"Default 'untested' status not found in workspace\");\n  }\n\n  const defaultStatusId = untestedStatus.id;\n\n  initializeEntityProgress(context, \"sessionResults\", sessionResultRows.length);\n  let processedSinceLastPersist = 0;\n\n  for (const row of sessionResultRows) {\n    const record = row as Record<string, unknown>;\n    const sourceResultId = toNumberValue(record.id);\n    const sourceSessionId = toNumberValue(record.session_id);\n    const sourceStatusId = toNumberValue(record.status_id);\n\n    if (sourceResultId === null || sourceSessionId === null) {\n      decrementEntityTotal(context, \"sessionResults\");\n      continue;\n    }\n\n    const sessionId = sessionIdMap.get(sourceSessionId);\n    if (!sessionId) {\n      logMessage(context, \"Skipping session result - session not found\", {\n        sourceSessionId,\n      });\n      decrementEntityTotal(context, \"sessionResults\");\n      continue;\n    }\n\n    // Resolve status - use default \"untested\" status if source status is null or not found\n    let statusId: number;\n    if (sourceStatusId !== null) {\n      statusId = statusIdMap.get(sourceStatusId) ?? defaultStatusId;\n    } else {\n      statusId = defaultStatusId;\n    }\n\n    const comment = convertToTipTapJsonString(record.comment);\n    const elapsedRaw = toNumberValue(record.elapsed);\n    const elapsed =\n      elapsedRaw !== null ? Math.floor(elapsedRaw / 1000000) : null;\n    const createdAt = toDateValue(record.created_at) ?? new Date();\n    const createdById = resolveUserId(\n      userIdMap,\n      importJob.createdById,\n      record.created_by\n    );\n\n    const sessionResult = await tx.sessionResults.create({\n      data: {\n        sessionId,\n        statusId,\n        resultData: comment ?? undefined,\n        elapsed,\n        createdAt,\n        createdById,\n      },\n    });\n\n    sessionResultIdMap.set(sourceResultId, sessionResult.id);\n    summary.created += 1;\n    incrementEntityProgress(context, \"sessionResults\", 1, 0);\n    processedSinceLastPersist += 1;\n\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      const message = formatInProgressStatus(context, \"sessionResults\");\n      await persistProgress(\"sessionResults\", message);\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"sessionResults\");\n    await persistProgress(\"sessionResults\", message);\n  }\n\n  return { summary, sessionResultIdMap };\n};\n\ninterface SessionValuesImportResult {\n  summary: EntitySummaryResult;\n}\n\nconst importSessionValues = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  sessionIdMap: Map<number, number>,\n  testmoFieldValueMap: Map<number, { fieldId: number; name: string }>,\n  configuration: TestmoMappingConfiguration,\n  caseFieldMap: Map<string, number>,\n  caseFieldMetadataById: Map<number, CaseFieldMetadata>,\n  importJob: TestmoImportJob,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<SessionValuesImportResult> => {\n  const sessionValueRows = datasetRows.get(\"session_values\") ?? [];\n  const summary: EntitySummaryResult = {\n    entity: \"sessionValues\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  if (sessionValueRows.length === 0) {\n    logMessage(context, \"No session values found; skipping.\");\n    return { summary };\n  }\n\n  // Build a map of multi-select values by session_id and field_id\n  const multiSelectValuesBySessionAndField = new Map<string, number[]>();\n\n  for (const row of sessionValueRows) {\n    const record = row as Record<string, unknown>;\n    const sessionId = toNumberValue(record.session_id);\n    const fieldId = toNumberValue(record.field_id);\n    const valueId = toNumberValue(record.value_id);\n\n    if (sessionId !== null && fieldId !== null && valueId !== null) {\n      const key = `${sessionId}:${fieldId}`;\n      const values = multiSelectValuesBySessionAndField.get(key) ?? [];\n      values.push(valueId);\n      multiSelectValuesBySessionAndField.set(key, values);\n    }\n  }\n\n  // Build mapping from Testmo field IDs to system names from configuration\n  const testmoFieldIdBySystemName = new Map<string, number>();\n  for (const [key, fieldConfig] of Object.entries(\n    configuration.templateFields ?? {}\n  )) {\n    const testmoFieldId = Number(key);\n    if (fieldConfig && fieldConfig.systemName) {\n      testmoFieldIdBySystemName.set(fieldConfig.systemName, testmoFieldId);\n    }\n  }\n\n  // Process unique session+field combinations\n  const processedCombinations = new Set<string>();\n\n  initializeEntityProgress(\n    context,\n    \"sessionValues\",\n    multiSelectValuesBySessionAndField.size\n  );\n  let processedSinceLastPersist = 0;\n\n  for (const [key, valueIds] of multiSelectValuesBySessionAndField.entries()) {\n    if (processedCombinations.has(key)) {\n      continue;\n    }\n    processedCombinations.add(key);\n\n    const [sessionSourceIdStr, fieldSourceIdStr] = key.split(\":\");\n    const sessionSourceId = Number(sessionSourceIdStr);\n    const fieldSourceId = Number(fieldSourceIdStr);\n\n    const sessionId = sessionIdMap.get(sessionSourceId);\n    if (!sessionId) {\n      decrementEntityTotal(context, \"sessionValues\");\n      continue;\n    }\n\n    // Find which case field this Testmo field maps to\n    let testPlanItFieldId: number | undefined;\n    let fieldSystemName: string | undefined;\n\n    for (const [\n      systemName,\n      testmoFieldId,\n    ] of testmoFieldIdBySystemName.entries()) {\n      if (testmoFieldId === fieldSourceId) {\n        fieldSystemName = systemName;\n        testPlanItFieldId = caseFieldMap.get(systemName);\n        break;\n      }\n    }\n\n    if (!testPlanItFieldId || !fieldSystemName) {\n      decrementEntityTotal(context, \"sessionValues\");\n      continue;\n    }\n\n    // Resolve value names from value IDs\n    const resolvedValueNames: string[] = [];\n    for (const valueId of valueIds) {\n      const valueMeta = testmoFieldValueMap.get(valueId);\n      if (valueMeta) {\n        resolvedValueNames.push(valueMeta.name);\n      }\n    }\n\n    if (resolvedValueNames.length === 0) {\n      decrementEntityTotal(context, \"sessionValues\");\n      continue;\n    }\n\n    // Create the session field value record\n    await tx.sessionFieldValues.create({\n      data: {\n        sessionId,\n        fieldId: testPlanItFieldId,\n        value: resolvedValueNames,\n      },\n    });\n\n    summary.created += 1;\n    incrementEntityProgress(context, \"sessionValues\", 1, 0);\n    processedSinceLastPersist += 1;\n\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      const message = formatInProgressStatus(context, \"sessionValues\");\n      await persistProgress(\"sessionValues\", message);\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"sessionValues\");\n    await persistProgress(\"sessionValues\", message);\n  }\n\n  return { summary };\n};\n\nconst importRepositories = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<RepositoriesImportResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"repositories\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const repositoryIdMap = new Map<number, number>();\n  const canonicalRepoIdByProject = new Map<number, Set<number>>();\n  const primaryRepositoryIdByProject = new Map<number, number>();\n  const masterRepositoryIds = new Set<number>();\n\n  const repositoryRows = datasetRows.get(\"repositories\") ?? [];\n  let folderRows = datasetRows.get(\"repository_folders\") ?? [];\n  let caseRows = datasetRows.get(\"repository_cases\") ?? [];\n\n  const repositoriesByProject = new Map<number, Array<Record<string, unknown>>>();\n  for (const row of repositoryRows) {\n    const record = row as Record<string, unknown>;\n    const repoId = toNumberValue(record.id);\n    const projectSourceId = toNumberValue(record.project_id);\n    if (repoId === null || projectSourceId === null) {\n      continue;\n    }\n    const collection =\n      repositoriesByProject.get(projectSourceId) ?? [];\n    collection.push(record);\n    repositoriesByProject.set(projectSourceId, collection);\n  }\n\n  const canonicalRepositoryRows: Array<Record<string, unknown>> = [];\n  if (repositoriesByProject.size > 0) {\n    for (const [projectSourceId, rows] of repositoriesByProject) {\n      const explicitMasters = rows.filter((record) => {\n        const value = toNumberValue(record.is_master);\n        return value === 1;\n      });\n\n      const nonSnapshotRows = rows.filter((record) => {\n        const snapshotFlag = toNumberValue(record.is_snapshot);\n        return snapshotFlag !== 1;\n      });\n\n      const selectedRows =\n        explicitMasters.length > 0\n          ? explicitMasters\n          : nonSnapshotRows.length > 0\n          ? nonSnapshotRows\n          : rows.slice(0, 1);\n\n      const repoSet = new Set<number>();\n      for (const record of selectedRows) {\n        const repoId = toNumberValue(record.id);\n        if (repoId === null || repoSet.has(repoId)) {\n          continue;\n        }\n        repoSet.add(repoId);\n        masterRepositoryIds.add(repoId);\n        canonicalRepositoryRows.push(record);\n      }\n\n      if (repoSet.size === 0) {\n        continue;\n      }\n\n      canonicalRepoIdByProject.set(projectSourceId, repoSet);\n    }\n\n    if (canonicalRepositoryRows.length > 0) {\n      datasetRows.set(\"repositories\", canonicalRepositoryRows);\n    }\n  }\n\n  if (masterRepositoryIds.size > 0) {\n    const filteredFolders = folderRows.filter((row) => {\n      const record = row as Record<string, unknown>;\n      const repoId = toNumberValue(record.repo_id);\n      return repoId !== null ? masterRepositoryIds.has(repoId) : true;\n    });\n    datasetRows.set(\"repository_folders\", filteredFolders);\n    folderRows = filteredFolders;\n\n    const filteredCases = caseRows.filter((row) => {\n      const record = row as Record<string, unknown>;\n      const repoId = toNumberValue(record.repo_id);\n      return repoId !== null ? masterRepositoryIds.has(repoId) : true;\n    });\n    datasetRows.set(\"repository_cases\", filteredCases);\n    caseRows = filteredCases;\n\n    const caseValueRows = datasetRows.get(\"repository_case_values\");\n    if (Array.isArray(caseValueRows) && caseValueRows.length > 0) {\n      const filteredCaseValues = caseValueRows.filter((row) => {\n        const record = row as Record<string, unknown>;\n        const repoId = toNumberValue(record.repo_id);\n        return repoId !== null ? masterRepositoryIds.has(repoId) : true;\n      });\n      datasetRows.set(\"repository_case_values\", filteredCaseValues);\n    }\n\n    const caseStepRows = datasetRows.get(\"repository_case_steps\");\n    if (Array.isArray(caseStepRows) && caseStepRows.length > 0) {\n      const filteredCaseSteps = caseStepRows.filter((row) => {\n        const record = row as Record<string, unknown>;\n        const repoId = toNumberValue(record.repo_id);\n        return repoId !== null ? masterRepositoryIds.has(repoId) : true;\n      });\n      datasetRows.set(\"repository_case_steps\", filteredCaseSteps);\n    }\n  }\n\n  const baseRepositoryRows =\n    canonicalRepositoryRows.length > 0 ? canonicalRepositoryRows : repositoryRows;\n\n  if (\n    baseRepositoryRows.length === 0 &&\n    folderRows.length === 0 &&\n    caseRows.length === 0\n  ) {\n    logMessage(\n      context,\n      \"No repository data available; skipping repository import.\"\n    );\n    return {\n      summary,\n      repositoryIdMap,\n      canonicalRepoIdByProject,\n      masterRepositoryIds,\n    };\n  }\n\n  const repoProjectLookup = new Map<number, number>();\n\n  const registerRepoCandidate = (\n    repoId: number | null,\n    projectId: number | null\n  ) => {\n    if (repoId === null || projectId === null) {\n      return;\n    }\n    if (\n      masterRepositoryIds.size > 0 &&\n      !isCanonicalRepository(projectId, repoId, canonicalRepoIdByProject)\n    ) {\n      return;\n    }\n    repoProjectLookup.set(repoId, projectId);\n  };\n\n  for (const row of baseRepositoryRows) {\n    const record = row as Record<string, unknown>;\n    registerRepoCandidate(\n      toNumberValue(record.id),\n      toNumberValue(record.project_id)\n    );\n  }\n\n  const hydrateRepoProject = (rows: any[], repoKey: string) => {\n    for (const row of rows) {\n      const record = row as Record<string, unknown>;\n      registerRepoCandidate(\n        toNumberValue(record[repoKey]),\n        toNumberValue(record.project_id)\n      );\n    }\n  };\n\n  hydrateRepoProject(folderRows, \"repo_id\");\n  hydrateRepoProject(caseRows, \"repo_id\");\n\n  if (repoProjectLookup.size === 0) {\n    logMessage(\n      context,\n      \"No repository data available; skipping repository import.\"\n    );\n    return {\n      summary,\n      repositoryIdMap,\n      canonicalRepoIdByProject,\n      masterRepositoryIds,\n    };\n  }\n\n  initializeEntityProgress(context, \"repositories\", repoProjectLookup.size);\n  let processedSinceLastPersist = 0;\n\n  for (const [repoId, projectSourceId] of repoProjectLookup) {\n    const projectId = projectIdMap.get(projectSourceId);\n    if (!projectId) {\n      logMessage(\n        context,\n        \"Skipping repository due to missing project mapping\",\n        {\n          repoId,\n          projectSourceId,\n        }\n      );\n      decrementEntityTotal(context, \"repositories\");\n      continue;\n    }\n\n    summary.total += 1;\n\n    const repoSet =\n      canonicalRepoIdByProject.get(projectSourceId) ?? new Set<number>();\n    if (!canonicalRepoIdByProject.has(projectSourceId)) {\n      canonicalRepoIdByProject.set(projectSourceId, repoSet);\n    }\n\n    const existingPrimaryRepositoryId =\n      primaryRepositoryIdByProject.get(projectSourceId);\n    if (existingPrimaryRepositoryId !== undefined) {\n      repositoryIdMap.set(repoId, existingPrimaryRepositoryId);\n      repoSet.add(repoId);\n      summary.mapped += 1;\n      incrementEntityProgress(context, \"repositories\", 0, 1);\n      processedSinceLastPersist += 1;\n      if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n        const message = formatInProgressStatus(context, \"repositories\");\n        await persistProgress(\"repositories\", message);\n        processedSinceLastPersist = 0;\n      }\n      continue;\n    }\n\n    const existingRepository = await tx.repositories.findFirst({\n      where: { projectId, isDeleted: false },\n      orderBy: { id: \"asc\" },\n    });\n\n    let repositoryId: number;\n\n    if (existingRepository && repositoryRows.length === 0) {\n      repositoryId = existingRepository.id;\n      summary.mapped += 1;\n      incrementEntityProgress(context, \"repositories\", 0, 1);\n    } else {\n      const repository = await tx.repositories.create({\n        data: {\n          projectId,\n        },\n      });\n      repositoryId = repository.id;\n      summary.created += 1;\n      incrementEntityProgress(context, \"repositories\", 1, 0);\n    }\n\n    repositoryIdMap.set(repoId, repositoryId);\n    repoSet.add(repoId);\n    primaryRepositoryIdByProject.set(projectSourceId, repositoryId);\n\n    processedSinceLastPersist += 1;\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      const message = formatInProgressStatus(context, \"repositories\");\n      await persistProgress(\"repositories\", message);\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"repositories\");\n    await persistProgress(\"repositories\", message);\n  }\n\n  repoProjectLookup.clear();\n\n  return {\n    summary,\n    repositoryIdMap,\n    canonicalRepoIdByProject,\n    masterRepositoryIds,\n  };\n};\n\nconst importRepositoryFolders = async (\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  repositoryIdMap: Map<number, number>,\n  canonicalRepoIdByProject: Map<number, Set<number>>,\n  importJob: TestmoImportJob,\n  userIdMap: Map<number, string>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<RepositoryFoldersImportResult> => {\n  const folderRows = datasetRows.get(\"repository_folders\") ?? [];\n  const summary: EntitySummaryResult = {\n    entity: \"repositoryFolders\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const folderIdMap = new Map<number, number>();\n  const repositoryRootFolderMap = new Map<number, number>();\n\n  if (folderRows.length === 0) {\n    logMessage(\n      context,\n      \"No repository folders dataset found; skipping folder import.\"\n    );\n    return { summary, folderIdMap, repositoryRootFolderMap };\n  }\n\n  const canonicalFolderRecords = new Map<number, Record<string, unknown>>();\n\n  for (const row of folderRows) {\n    const record = row as Record<string, unknown>;\n    const folderId = toNumberValue(record.id);\n    const projectSourceId = toNumberValue(record.project_id);\n    const repoSourceId = toNumberValue(record.repo_id);\n\n    if (\n      !isCanonicalRepository(\n        projectSourceId,\n        repoSourceId,\n        canonicalRepoIdByProject\n      )\n    ) {\n      continue;\n    }\n\n    if (folderId !== null) {\n      canonicalFolderRecords.set(folderId, record);\n    }\n  }\n\n  if (canonicalFolderRecords.size === 0) {\n    logMessage(\n      context,\n      \"No canonical repository folders found; skipping folder import.\"\n    );\n    return { summary, folderIdMap, repositoryRootFolderMap };\n  }\n\n  initializeEntityProgress(\n    context,\n    \"repositoryFolders\",\n    canonicalFolderRecords.size\n  );\n  let processedSinceLastPersist = 0;\n\n  const processedFolders = new Set<number>();\n  const processingFolders = new Set<number>();\n  const fallbackCreator = importJob.createdById;\n  const folderSignatureMap = new Map<string, number>();\n\n  const ensureRepositoryFor = async (\n    repoSourceId: number,\n    projectId: number\n  ): Promise<number> => {\n    let repositoryId = repositoryIdMap.get(repoSourceId);\n    if (!repositoryId) {\n      const repository = await prisma.repositories.create({\n        data: { projectId },\n      });\n      repositoryId = repository.id;\n      repositoryIdMap.set(repoSourceId, repositoryId);\n    }\n    return repositoryId;\n  };\n\n  const importFolder = async (\n    folderSourceId: number\n  ): Promise<number | null> => {\n    if (folderIdMap.has(folderSourceId)) {\n      return folderIdMap.get(folderSourceId) ?? null;\n    }\n\n    const record = canonicalFolderRecords.get(folderSourceId);\n    if (!record) {\n      return null;\n    }\n\n    if (processingFolders.has(folderSourceId)) {\n      logMessage(\n        context,\n        \"Detected folder parent cycle; attaching to repository root\",\n        {\n          folderSourceId,\n        }\n      );\n      return null;\n    }\n\n    processingFolders.add(folderSourceId);\n\n    try {\n      if (!processedFolders.has(folderSourceId)) {\n        summary.total += 1;\n        processedFolders.add(folderSourceId);\n      }\n\n      const projectSourceId = toNumberValue(record.project_id);\n      const repoSourceId = toNumberValue(record.repo_id);\n      const parentSourceId = toNumberValue(record.parent_id);\n\n      if (projectSourceId === null || repoSourceId === null) {\n        decrementEntityTotal(context, \"repositoryFolders\");\n        return null;\n      }\n\n      const projectId = projectIdMap.get(projectSourceId);\n      if (!projectId) {\n        logMessage(context, \"Skipping folder due to missing project mapping\", {\n          folderSourceId,\n          projectSourceId,\n        });\n        decrementEntityTotal(context, \"repositoryFolders\");\n        return null;\n      }\n\n      const targetRepoId = getPreferredRepositoryId(\n        projectSourceId,\n        repoSourceId,\n        canonicalRepoIdByProject\n      );\n\n      if (targetRepoId === null) {\n        logMessage(\n          context,\n          \"Skipping folder due to missing canonical repository\",\n          {\n            folderSourceId,\n            projectSourceId,\n            repoSourceId,\n          }\n        );\n        decrementEntityTotal(context, \"repositoryFolders\");\n        return null;\n      }\n\n      const repositoryId = await ensureRepositoryFor(targetRepoId, projectId);\n\n      if (!repositoryIdMap.has(targetRepoId)) {\n        repositoryIdMap.set(targetRepoId, repositoryId);\n      }\n      if (repoSourceId !== null) {\n        repositoryIdMap.set(repoSourceId, repositoryId);\n      }\n\n      let parentId: number | null = null;\n      if (parentSourceId !== null) {\n        const mappedParent = folderIdMap.get(parentSourceId);\n        if (mappedParent !== undefined) {\n          parentId = mappedParent ?? null;\n        } else {\n          const createdParent = await importFolder(parentSourceId);\n          parentId = createdParent ?? null;\n        }\n      }\n\n      if (parentSourceId !== null && parentId === null) {\n        logMessage(\n          context,\n          \"Folder parent missing; attaching to repository root\",\n          {\n            folderSourceId,\n            parentSourceId,\n          }\n        );\n        parentId = repositoryRootFolderMap.get(repositoryId) ?? null;\n      }\n\n      const name = toStringValue(record.name) ?? `Folder ${folderSourceId}`;\n\n      // Check if we've already created or mapped a folder with this signature during this import\n      const signature = `${repositoryId}:${parentId}:${name}`;\n      const existingFolderId = folderSignatureMap.get(signature);\n\n      if (existingFolderId !== undefined) {\n        folderIdMap.set(folderSourceId, existingFolderId);\n        summary.mapped += 1;\n        incrementEntityProgress(context, \"repositoryFolders\", 0, 1);\n        return existingFolderId;\n      }\n\n      const docsValue = convertToTipTapJsonString(record.docs);\n      const order = toNumberValue(record.display_order) ?? 0;\n      const creatorId = resolveUserId(\n        userIdMap,\n        fallbackCreator,\n        record.created_by\n      );\n      const createdAt = toDateValue(record.created_at) ?? new Date();\n\n      const transactionResult = await prisma.$transaction<{\n        folderId: number;\n        created: boolean;\n      }>(\n        async (tx) => {\n          const existing = await tx.repositoryFolders.findFirst({\n            where: {\n              projectId,\n              repositoryId,\n              parentId,\n              name,\n              isDeleted: false,\n            },\n          });\n\n          if (existing) {\n            return { folderId: existing.id, created: false };\n          }\n\n          const folder = await tx.repositoryFolders.create({\n            data: {\n              projectId,\n              repositoryId,\n              parentId,\n              name,\n              order,\n              creatorId,\n              createdAt,\n              ...(docsValue !== null ? { docs: docsValue } : {}),\n            },\n          });\n\n          return { folderId: folder.id, created: true };\n        },\n        {\n          timeout: REPOSITORY_FOLDER_TRANSACTION_TIMEOUT_MS,\n          maxWait: IMPORT_TRANSACTION_MAX_WAIT_MS,\n        }\n      );\n\n      const folderId = transactionResult.folderId;\n\n      if (transactionResult.created) {\n        summary.created += 1;\n        incrementEntityProgress(context, \"repositoryFolders\", 1, 0);\n      } else {\n        summary.mapped += 1;\n        incrementEntityProgress(context, \"repositoryFolders\", 0, 1);\n      }\n\n      processedSinceLastPersist += 1;\n      if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n        const message = formatInProgressStatus(context, \"repositoryFolders\");\n        await persistProgress(\"repositoryFolders\", message);\n        processedSinceLastPersist = 0;\n      }\n\n      folderIdMap.set(folderSourceId, folderId);\n      folderSignatureMap.set(signature, folderId);\n\n      if (parentId === null && !repositoryRootFolderMap.has(repositoryId)) {\n        repositoryRootFolderMap.set(repositoryId, folderId);\n      }\n\n      return folderId;\n    } finally {\n      processingFolders.delete(folderSourceId);\n    }\n  };\n\n  for (const folderSourceId of canonicalFolderRecords.keys()) {\n    await importFolder(folderSourceId);\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"repositoryFolders\");\n    await persistProgress(\"repositoryFolders\", message);\n  }\n\n  canonicalFolderRecords.clear();\n  processedFolders.clear();\n  processingFolders.clear();\n\n  return { summary, folderIdMap, repositoryRootFolderMap };\n};\nconst importRepositoryCases = async (\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  repositoryIdMap: Map<number, number>,\n  canonicalRepoIdByProject: Map<number, Set<number>>,\n  folderIdMap: Map<number, number>,\n  repositoryRootFolderMap: Map<number, number>,\n  templateIdMap: Map<number, number>,\n  templateNameMap: Map<string, number>,\n  workflowIdMap: Map<number, number>,\n  userIdMap: Map<number, string>,\n  caseFieldMap: Map<string, number>,\n  testmoFieldValueMap: Map<number, { fieldId: number; name: string }>,\n  configuration: TestmoMappingConfiguration,\n  importJob: TestmoImportJob,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<RepositoryCasesImportResult> => {\n  const caseRows = datasetRows.get(\"repository_cases\") ?? [];\n  const caseValuesRows = datasetRows.get(\"repository_case_values\") ?? [];\n\n  // Build a map of multi-select values by case_id and field_id\n  const multiSelectValuesByCaseAndField = new Map<string, number[]>();\n\n  for (const row of caseValuesRows) {\n    const record = row as Record<string, unknown>;\n    const caseId = toNumberValue(record.case_id);\n    const fieldId = toNumberValue(record.field_id);\n    const valueId = toNumberValue(record.value_id);\n    const projectSourceId = toNumberValue(record.project_id);\n    const repoSourceId = toNumberValue(record.repo_id);\n\n    if (\n      !isCanonicalRepository(\n        projectSourceId,\n        repoSourceId,\n        canonicalRepoIdByProject\n      )\n    ) {\n      continue;\n    }\n\n    if (caseId !== null && fieldId !== null && valueId !== null) {\n      const key = `${caseId}:${fieldId}`;\n      const values = multiSelectValuesByCaseAndField.get(key) ?? [];\n      values.push(valueId);\n      multiSelectValuesByCaseAndField.set(key, values);\n    }\n  }\n\n  const summary: EntitySummaryResult = {\n    entity: \"repositoryCases\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n    details: {\n      estimateAdjusted: 0,\n      estimateClamped: 0,\n    },\n  };\n\n  const caseIdMap = new Map<number, number>();\n  const caseMetaMap = new Map<number, { projectId: number; name: string }>();\n  const summaryDetails = summary.details as Record<string, number>;\n\n  // Debug tracking for dropdown/multi-select fields\n  const dropdownStats = new Map<\n    string,\n    {\n      totalAttempts: number;\n      nullResults: number;\n      successResults: number;\n      sampleValues: Set<any>;\n      sampleNulls: Array<any>;\n    }\n  >();\n\n  const templateRows = datasetRows.get(\"templates\") ?? [];\n  const templateNameBySourceId = new Map<number, string>();\n  for (const row of templateRows) {\n    const record = row as Record<string, unknown>;\n    const sourceId = toNumberValue(record.id);\n    const name = toStringValue(record.name);\n    if (sourceId !== null && name) {\n      templateNameBySourceId.set(sourceId, name);\n    }\n  }\n\n  const canonicalCaseRows: Record<string, unknown>[] = [];\n  const canonicalCaseIds = new Set<number>();\n\n  for (let index = 0; index < caseRows.length; index += 1) {\n    const record = caseRows[index] as Record<string, unknown>;\n    const projectSourceId = toNumberValue(record.project_id);\n    const repoSourceId = toNumberValue(record.repo_id);\n    const caseSourceId = toNumberValue(record.id);\n\n    if (\n      !isCanonicalRepository(\n        projectSourceId,\n        repoSourceId,\n        canonicalRepoIdByProject\n      )\n    ) {\n      continue;\n    }\n\n    if (caseSourceId !== null) {\n      canonicalCaseRows.push(record);\n      canonicalCaseIds.add(caseSourceId);\n    }\n  }\n  caseRows.length = 0;\n\n  const repositoryCaseStepRows = datasetRows.get(\"repository_case_steps\") ?? [];\n  datasetRows.delete(\"repository_case_steps\");\n  const stepsByCaseId = new Map<number, Array<Record<string, unknown>>>();\n  for (const row of repositoryCaseStepRows) {\n    const record = row as Record<string, unknown>;\n    const caseId = toNumberValue(record.case_id);\n    if (caseId === null || !canonicalCaseIds.has(caseId)) {\n      continue;\n    }\n\n    const projectSourceId = toNumberValue(record.project_id);\n    const repoSourceId = toNumberValue(record.repo_id);\n    if (\n      !isCanonicalRepository(\n        projectSourceId,\n        repoSourceId,\n        canonicalRepoIdByProject\n      )\n    ) {\n      continue;\n    }\n\n    const collection = stepsByCaseId.get(caseId);\n    if (collection) {\n      collection.push(record);\n    } else {\n      stepsByCaseId.set(caseId, [record]);\n    }\n  }\n\n  const resolvedTemplateIdsByName = new Map<string, number>(templateNameMap);\n  const templateAssignmentsByProject = new Map<number, Set<number>>();\n\n  const canonicalCaseCount = canonicalCaseRows.length;\n\n  if (canonicalCaseCount === 0) {\n    logMessage(\n      context,\n      \"No repository cases dataset found; skipping case import.\"\n    );\n    return {\n      summary,\n      caseIdMap,\n      caseFieldMap: new Map(),\n      caseFieldMetadataById: new Map(),\n      caseMetaMap,\n    };\n  }\n\n  initializeEntityProgress(context, \"repositoryCases\", canonicalCaseCount);\n  let processedSinceLastPersist = 0;\n\n  const defaultTemplate = await prisma.templates.findFirst({\n    where: { isDefault: true },\n    select: { id: true },\n  });\n\n  const defaultCaseWorkflow = await prisma.workflows.findFirst({\n    where: { scope: WorkflowScope.CASES, isDefault: true },\n    select: { id: true },\n  });\n\n  const fallbackCreator = importJob.createdById;\n\n  const caseFieldMetadataById = new Map<number, CaseFieldMetadata>();\n  if (caseFieldMap.size > 0) {\n    const uniqueCaseFieldIds = Array.from(\n      new Set(Array.from(caseFieldMap.values()))\n    );\n\n    const caseFieldRecords = await prisma.caseFields.findMany({\n      where: {\n        id: {\n          in: uniqueCaseFieldIds,\n        },\n      },\n      include: {\n        type: {\n          select: {\n            type: true,\n          },\n        },\n        fieldOptions: {\n          include: {\n            fieldOption: {\n              select: {\n                id: true,\n                name: true,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    for (const field of caseFieldRecords) {\n      const optionsByName = new Map<string, number>();\n      const optionIds = new Set<number>();\n\n      for (const assignment of field.fieldOptions ?? []) {\n        const option = assignment.fieldOption;\n        if (!option) {\n          continue;\n        }\n        optionIds.add(option.id);\n        optionsByName.set(option.name.trim().toLowerCase(), option.id);\n      }\n\n      caseFieldMetadataById.set(field.id, {\n        id: field.id,\n        systemName: field.systemName,\n        displayName: field.displayName,\n        type: field.type.type,\n        optionIds,\n        optionsByName,\n      });\n    }\n  }\n\n  const recordFieldWarning = (\n    message: string,\n    details: Record<string, unknown>\n  ) => {\n    logMessage(context, message, details);\n  };\n  const chunkSize = Math.max(1, REPOSITORY_CASE_CHUNK_SIZE);\n  logMessage(context, `Processing repository cases in batches of ${chunkSize}`);\n\n  const processChunk = async (\n    records: Record<string, unknown>[]\n  ): Promise<void> => {\n    if (records.length === 0) {\n      return;\n    }\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const record of records) {\n          const caseSourceId = toNumberValue(record.id);\n          const projectSourceId = toNumberValue(record.project_id);\n          const repoSourceId = toNumberValue(record.repo_id);\n          const folderSourceId = toNumberValue(record.folder_id);\n          const caseName =\n            toStringValue(record.name) ?? `Imported Case ${caseSourceId ?? 0}`;\n\n          if (\n            caseSourceId === null ||\n            projectSourceId === null ||\n            repoSourceId === null\n          ) {\n            decrementEntityTotal(context, \"repositoryCases\");\n            continue;\n          }\n\n          const projectId = projectIdMap.get(projectSourceId);\n          if (!projectId) {\n            logMessage(\n              context,\n              \"Skipping case due to missing project mapping\",\n              {\n                caseSourceId,\n                projectSourceId,\n              }\n            );\n            decrementEntityTotal(context, \"repositoryCases\");\n            if (caseSourceId !== null) {\n              canonicalCaseIds.delete(caseSourceId);\n              stepsByCaseId.delete(caseSourceId);\n            }\n            continue;\n          }\n\n          const targetRepoId = getPreferredRepositoryId(\n            projectSourceId,\n            repoSourceId,\n            canonicalRepoIdByProject\n          );\n          if (caseSourceId !== null) {\n            caseMetaMap.set(caseSourceId, { projectId, name: caseName });\n          }\n\n          if (targetRepoId === null) {\n            const existingFallback = await tx.repositoryCases.findFirst({\n              where: {\n                projectId,\n                name: caseName,\n                isDeleted: false,\n              },\n              select: { id: true },\n            });\n\n            if (existingFallback) {\n              caseIdMap.set(caseSourceId, existingFallback.id);\n              summary.total += 1;\n              summary.mapped += 1;\n            }\n\n            logMessage(\n              context,\n              \"Skipping case due to missing canonical repository\",\n              {\n                caseSourceId,\n                projectSourceId,\n                repoSourceId,\n              }\n            );\n            decrementEntityTotal(context, \"repositoryCases\");\n            canonicalCaseIds.delete(caseSourceId);\n            stepsByCaseId.delete(caseSourceId);\n            continue;\n          }\n\n          let repositoryId = repositoryIdMap.get(targetRepoId);\n          if (repositoryId === undefined) {\n            const repository = await tx.repositories.create({\n              data: { projectId },\n            });\n            repositoryId = repository.id;\n            repositoryIdMap.set(targetRepoId, repositoryId);\n          }\n\n          const resolvedRepositoryId = repositoryId;\n\n          if (repoSourceId !== null) {\n            repositoryIdMap.set(repoSourceId, resolvedRepositoryId);\n          }\n\n          let folderId =\n            folderSourceId !== null\n              ? (folderIdMap.get(folderSourceId) ?? null)\n              : null;\n          if (folderId == null) {\n            const rootFolderId =\n              repositoryRootFolderMap.get(resolvedRepositoryId);\n            if (rootFolderId) {\n              folderId = rootFolderId;\n            } else {\n              const fallbackFolder = await tx.repositoryFolders.create({\n                data: {\n                  projectId,\n                  repositoryId: resolvedRepositoryId,\n                  name: \"Imported\",\n                  creatorId: fallbackCreator,\n                },\n              });\n              folderId = fallbackFolder.id;\n              repositoryRootFolderMap.set(\n                resolvedRepositoryId,\n                fallbackFolder.id\n              );\n            }\n          }\n\n          if (folderId == null) {\n            logMessage(context, \"Skipping case due to missing folder mapping\", {\n              caseSourceId,\n              folderSourceId,\n            });\n            decrementEntityTotal(context, \"repositoryCases\");\n            canonicalCaseIds.delete(caseSourceId);\n            stepsByCaseId.delete(caseSourceId);\n            continue;\n          }\n\n          const resolvedFolderId = folderId;\n\n          const existing = await tx.repositoryCases.findFirst({\n            where: {\n              projectId,\n              name: caseName,\n              isDeleted: false,\n            },\n          });\n\n          if (existing) {\n            caseIdMap.set(caseSourceId, existing.id);\n            summary.total += 1;\n            summary.mapped += 1;\n            incrementEntityProgress(context, \"repositoryCases\", 0, 1);\n            processedSinceLastPersist += 1;\n            if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n              const message = formatInProgressStatus(\n                context,\n                \"repositoryCases\"\n              );\n              await persistProgress(\"repositoryCases\", message);\n              processedSinceLastPersist = 0;\n            }\n            canonicalCaseIds.delete(caseSourceId);\n            stepsByCaseId.delete(caseSourceId);\n            continue;\n          }\n\n          const templateSourceId = toNumberValue(record.template_id);\n          const stateSourceId = toNumberValue(record.state_id);\n\n          let templateId: number | null = null;\n          if (templateSourceId !== null) {\n            const mappedTemplateId = templateIdMap.get(templateSourceId);\n            if (mappedTemplateId !== undefined) {\n              templateId = mappedTemplateId;\n            } else {\n              const templateName = templateNameBySourceId.get(templateSourceId);\n              if (templateName) {\n                templateId =\n                  resolvedTemplateIdsByName.get(templateName) ?? null;\n                if (!templateId) {\n                  const existingTemplate = await tx.templates.findFirst({\n                    where: { templateName, isDeleted: false },\n                  });\n\n                  if (existingTemplate) {\n                    templateId = existingTemplate.id;\n                  } else {\n                    const createdTemplate = await tx.templates.create({\n                      data: {\n                        templateName,\n                        isEnabled: true,\n                        isDefault: false,\n                      },\n                    });\n                    templateId = createdTemplate.id;\n                  }\n\n                  resolvedTemplateIdsByName.set(templateName, templateId);\n                  templateNameMap.set(templateName, templateId);\n                }\n\n                if (templateId !== null) {\n                  templateIdMap.set(templateSourceId, templateId);\n                }\n              }\n            }\n          }\n\n          templateId = templateId ?? defaultTemplate?.id ?? null;\n          const workflowId =\n            (stateSourceId !== null\n              ? workflowIdMap.get(stateSourceId)\n              : null) ??\n            defaultCaseWorkflow?.id ??\n            null;\n\n          if (templateId == null || workflowId == null) {\n            logMessage(\n              context,\n              \"Skipping case due to missing template or workflow mapping\",\n              {\n                caseSourceId,\n                templateSourceId,\n                stateSourceId,\n              }\n            );\n            decrementEntityTotal(context, \"repositoryCases\");\n            canonicalCaseIds.delete(caseSourceId);\n            stepsByCaseId.delete(caseSourceId);\n            continue;\n          }\n\n          const resolvedTemplateId = templateId;\n          const resolvedWorkflowId = workflowId;\n\n          const creatorId = resolveUserId(\n            userIdMap,\n            fallbackCreator,\n            record.created_by\n          );\n          const createdAt = toDateValue(record.created_at) ?? new Date();\n          const order = toNumberValue(record.display_order) ?? 0;\n          const className = toStringValue(record.key);\n          const estimateValue = toNumberValue(record.estimate);\n          const { value: normalizedEstimate, adjustment: estimateAdjustment } =\n            normalizeEstimate(estimateValue);\n          if (\n            estimateAdjustment === \"nanoseconds\" ||\n            estimateAdjustment === \"microseconds\" ||\n            estimateAdjustment === \"milliseconds\"\n          ) {\n            summaryDetails.estimateAdjusted += 1;\n          } else if (estimateAdjustment === \"clamped\") {\n            summaryDetails.estimateClamped += 1;\n          }\n\n          const repositoryCase = await tx.repositoryCases.create({\n            data: {\n              projectId,\n              repositoryId: resolvedRepositoryId,\n              folderId: resolvedFolderId,\n              templateId: resolvedTemplateId,\n              name: caseName,\n              className: className ?? undefined,\n              stateId: resolvedWorkflowId,\n              estimate: normalizedEstimate ?? undefined,\n              order,\n              createdAt,\n              creatorId,\n              automated: toBooleanValue(record.automated ?? false),\n              currentVersion: 1,\n            },\n          });\n\n          caseIdMap.set(caseSourceId, repositoryCase.id);\n          const projectTemplateAssignments =\n            templateAssignmentsByProject.get(projectId) ?? new Set<number>();\n          projectTemplateAssignments.add(resolvedTemplateId);\n          templateAssignmentsByProject.set(\n            projectId,\n            projectTemplateAssignments\n          );\n          summary.total += 1;\n          summary.created += 1;\n\n          incrementEntityProgress(context, \"repositoryCases\", 1, 0);\n          processedSinceLastPersist += 1;\n          if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n            const message = formatInProgressStatus(context, \"repositoryCases\");\n            await persistProgress(\"repositoryCases\", message);\n            processedSinceLastPersist = 0;\n          }\n\n          for (const [key, rawValue] of Object.entries(record)) {\n            if (!key.startsWith(\"custom_\")) {\n              continue;\n            }\n\n            const fieldName = key.replace(/^custom_/, \"\");\n            const fieldId = caseFieldMap.get(fieldName);\n            if (!fieldId) {\n              continue;\n            }\n\n            const fieldMetadata = caseFieldMetadataById.get(fieldId);\n            if (!fieldMetadata) {\n              recordFieldWarning(\"Missing case field metadata\", {\n                field: fieldName,\n                fieldId,\n                caseSourceId,\n              });\n              continue;\n            }\n\n            if (\n              rawValue === null ||\n              rawValue === undefined ||\n              (typeof rawValue === \"string\" && rawValue.trim().length === 0)\n            ) {\n              continue;\n            }\n\n            const processedValue = normalizeCaseFieldValue(\n              rawValue,\n              fieldMetadata,\n              (message, details) =>\n                recordFieldWarning(message, {\n                  caseSourceId,\n                  field: fieldMetadata.systemName,\n                  displayName: fieldMetadata.displayName,\n                  ...details,\n                }),\n              testmoFieldValueMap\n            );\n\n            // Collect stats for multi-select fields only\n            if (fieldMetadata.type.toLowerCase().includes(\"multi-select\")) {\n              console.log(`  Processed value:`, processedValue);\n              console.log(`  Processed value type: ${typeof processedValue}`);\n              console.log(`  Is Array: ${Array.isArray(processedValue)}`);\n              console.log(\n                `  Will save to DB:`,\n                processedValue !== null && processedValue !== undefined\n              );\n\n              const stats = dropdownStats.get(fieldMetadata.systemName) || {\n                totalAttempts: 0,\n                nullResults: 0,\n                successResults: 0,\n                sampleValues: new Set(),\n                sampleNulls: [],\n              };\n\n              stats.totalAttempts++;\n\n              if (processedValue === null || processedValue === undefined) {\n                stats.nullResults++;\n                if (stats.sampleNulls.length < 3) {\n                  stats.sampleNulls.push(rawValue);\n                }\n              } else {\n                stats.successResults++;\n                if (stats.sampleValues.size < 3) {\n                  stats.sampleValues.add(JSON.stringify(processedValue));\n                }\n              }\n\n              dropdownStats.set(fieldMetadata.systemName, stats);\n            }\n\n            if (processedValue === undefined || processedValue === null) {\n              continue;\n            }\n\n            if (\n              isTipTapDocument(processedValue) &&\n              isTipTapDocumentEmpty(processedValue as Record<string, unknown>)\n            ) {\n              continue;\n            }\n\n            if (typeof processedValue === \"string\" && !processedValue.trim()) {\n              continue;\n            }\n\n            if (Array.isArray(processedValue) && processedValue.length === 0) {\n              continue;\n            }\n\n            await tx.caseFieldValues.create({\n              data: {\n                testCaseId: repositoryCase.id,\n                fieldId,\n                value: toInputJsonValue(processedValue),\n              },\n            });\n          }\n\n          // Process multi-select values from repository_case_values dataset\n          // These are stored separately from the custom_ fields in repository_cases\n\n          // Build mapping from system names to Testmo field IDs from configuration\n          const testmoFieldIdBySystemName = new Map<string, number>();\n          for (const [key, fieldConfig] of Object.entries(\n            configuration.templateFields ?? {}\n          )) {\n            const testmoFieldId = Number(key);\n            if (fieldConfig && fieldConfig.systemName) {\n              testmoFieldIdBySystemName.set(\n                fieldConfig.systemName,\n                testmoFieldId\n              );\n            }\n          }\n\n          for (const [systemName, fieldId] of caseFieldMap.entries()) {\n            const fieldMetadata = caseFieldMetadataById.get(fieldId);\n            if (\n              !fieldMetadata ||\n              !fieldMetadata.type.toLowerCase().includes(\"multi-select\")\n            ) {\n              continue;\n            }\n\n            // Get the Testmo field ID for this system name\n            const testmoFieldId = testmoFieldIdBySystemName.get(systemName);\n            if (!testmoFieldId) {\n              // No Testmo field mapping for this multi-select field\n              continue;\n            }\n\n            // Look up values for this case and field using Testmo IDs\n            const lookupKey = `${caseSourceId}:${testmoFieldId}`;\n            const valueIds = multiSelectValuesByCaseAndField.get(lookupKey);\n\n            if (!valueIds || valueIds.length === 0) {\n              continue;\n            }\n\n            // Process the multi-select values\n            const processedValue = normalizeCaseFieldValue(\n              valueIds,\n              fieldMetadata,\n              (message, details) =>\n                recordFieldWarning(message, {\n                  caseSourceId,\n                  field: fieldMetadata.systemName,\n                  displayName: fieldMetadata.displayName,\n                  source: \"repository_case_values\",\n                  ...details,\n                }),\n              testmoFieldValueMap\n            );\n\n            if (processedValue === undefined || processedValue === null) {\n              continue;\n            }\n\n            if (Array.isArray(processedValue) && processedValue.length === 0) {\n              continue;\n            }\n\n            // Check if we already created a value for this field from custom_ fields\n            const existingValue = await tx.caseFieldValues.findFirst({\n              where: {\n                testCaseId: repositoryCase.id,\n                fieldId,\n              },\n            });\n\n            if (existingValue) {\n              await tx.caseFieldValues.update({\n                where: {\n                  id: existingValue.id,\n                },\n                data: {\n                  value: toInputJsonValue(processedValue),\n                },\n              });\n            } else {\n              await tx.caseFieldValues.create({\n                data: {\n                  testCaseId: repositoryCase.id,\n                  fieldId,\n                  value: toInputJsonValue(processedValue),\n                },\n              });\n            }\n          }\n\n          const caseSteps = stepsByCaseId.get(caseSourceId) ?? [];\n          const stepsForVersion: Array<{\n            step: unknown;\n            expectedResult: unknown;\n          }> = [];\n          if (caseSteps.length > 0) {\n            let generatedOrder = 0;\n            const stepEntries: Array<Prisma.StepsCreateManyInput> = [];\n\n            for (const stepRecord of caseSteps) {\n              const stepAction = toStringValue(stepRecord.text1);\n              const stepData = toStringValue(stepRecord.text2);\n              const expectedResult = toStringValue(stepRecord.text3);\n              const expectedResultData = toStringValue(stepRecord.text4);\n\n              if (\n                !stepAction &&\n                !stepData &&\n                !expectedResult &&\n                !expectedResultData\n              ) {\n                continue;\n              }\n\n              let orderValue = toNumberValue(stepRecord.display_order);\n              if (orderValue === null) {\n                generatedOrder += 1;\n                orderValue = generatedOrder;\n              } else {\n                generatedOrder = orderValue;\n              }\n\n              const stepEntry: Prisma.StepsCreateManyInput = {\n                testCaseId: repositoryCase.id,\n                order: orderValue,\n              };\n\n              // Combine step action (text1) with step data (text2)\n              if (stepAction || stepData) {\n                let combinedStepText = stepAction || \"\";\n                if (stepData) {\n                  // Append data wrapped in <data> tag\n                  combinedStepText +=\n                    (combinedStepText ? \"\\n\" : \"\") + `<data>${stepData}</data>`;\n                }\n\n                const stepPayload = convertToTipTapJsonValue(combinedStepText);\n                if (stepPayload !== undefined && stepPayload !== null) {\n                  stepEntry.step = JSON.stringify(stepPayload);\n                }\n              }\n\n              // Combine expected result (text3) with expected result data (text4)\n              if (expectedResult || expectedResultData) {\n                let combinedExpectedText = expectedResult || \"\";\n                if (expectedResultData) {\n                  // Append data wrapped in <data> tag\n                  combinedExpectedText +=\n                    (combinedExpectedText ? \"\\n\" : \"\") +\n                    `<data>${expectedResultData}</data>`;\n                }\n\n                const expectedPayload =\n                  convertToTipTapJsonValue(combinedExpectedText);\n                if (expectedPayload !== undefined && expectedPayload !== null) {\n                  stepEntry.expectedResult = JSON.stringify(expectedPayload);\n                }\n              }\n\n              const parseJson = (value?: string) => {\n                if (!value) {\n                  return emptyEditorContent;\n                }\n                try {\n                  return JSON.parse(value);\n                } catch (error) {\n                  console.warn(\"Failed to parse repository case step\", {\n                    caseSourceId,\n                    error,\n                  });\n                  return emptyEditorContent;\n                }\n              };\n\n              stepsForVersion.push({\n                step: parseJson(stepEntry.step as string | undefined),\n                expectedResult: parseJson(\n                  stepEntry.expectedResult as string | undefined\n                ),\n              });\n\n              stepEntries.push(stepEntry);\n            }\n\n            if (stepEntries.length > 0) {\n              await tx.steps.createMany({ data: stepEntries });\n            }\n          }\n\n          const projectName = await getProjectName(tx, projectId);\n          const templateName = await getTemplateName(tx, resolvedTemplateId);\n          const workflowName = await getWorkflowName(tx, resolvedWorkflowId);\n          const folderName = await getFolderName(tx, resolvedFolderId);\n          const creatorName = await getUserName(tx, creatorId);\n          const versionCaseName =\n            toStringValue(record.name) ?? repositoryCase.name;\n\n          const caseVersion = await tx.repositoryCaseVersions.create({\n            data: {\n              repositoryCase: { connect: { id: repositoryCase.id } },\n              project: { connect: { id: projectId } },\n              staticProjectId: projectId,\n              staticProjectName: projectName,\n              repositoryId: resolvedRepositoryId,\n              folderId: resolvedFolderId,\n              folderName,\n              templateId: resolvedTemplateId,\n              templateName,\n              name: versionCaseName,\n              stateId: resolvedWorkflowId,\n              stateName: workflowName,\n              estimate: repositoryCase.estimate ?? null,\n              forecastManual: repositoryCase.forecastManual ?? null,\n              forecastAutomated: repositoryCase.forecastAutomated ?? null,\n              order,\n              createdAt: repositoryCase.createdAt ?? new Date(),\n              creatorId,\n              creatorName,\n              automated: repositoryCase.automated,\n              isArchived: repositoryCase.isArchived,\n              isDeleted: repositoryCase.isDeleted,\n              version: repositoryCase.currentVersion,\n              steps:\n                stepsForVersion.length > 0\n                  ? (stepsForVersion as Prisma.InputJsonValue)\n                  : Prisma.JsonNull,\n              tags: [],\n              issues: [],\n              links: [],\n              attachments: [],\n            },\n          });\n\n          const caseFieldValuesForVersion = await tx.caseFieldValues.findMany({\n            where: { testCaseId: repositoryCase.id },\n            include: {\n              field: {\n                select: {\n                  displayName: true,\n                  systemName: true,\n                },\n              },\n            },\n          });\n\n          if (caseFieldValuesForVersion.length > 0) {\n            await tx.caseFieldVersionValues.createMany({\n              data: caseFieldValuesForVersion.map((fieldValue) => ({\n                versionId: caseVersion.id,\n                field:\n                  fieldValue.field.displayName || fieldValue.field.systemName,\n                value: fieldValue.value ?? Prisma.JsonNull,\n              })),\n            });\n          }\n\n          canonicalCaseIds.delete(caseSourceId);\n          stepsByCaseId.delete(caseSourceId);\n        }\n      },\n      {\n        timeout: IMPORT_TRANSACTION_TIMEOUT_MS,\n        maxWait: IMPORT_TRANSACTION_MAX_WAIT_MS,\n      }\n    );\n\n    clearTipTapCache();\n  };\n\n  const totalChunks = Math.ceil(canonicalCaseRows.length / chunkSize);\n  let currentChunk = 0;\n\n  while (canonicalCaseRows.length > 0) {\n    const chunkRecords = canonicalCaseRows.splice(\n      Math.max(canonicalCaseRows.length - chunkSize, 0)\n    );\n    currentChunk++;\n    logMessage(\n      context,\n      `Processing repository cases chunk ${currentChunk}/${totalChunks}`,\n      {\n        chunkSize: chunkRecords.length,\n        remainingCases: canonicalCaseRows.length,\n        processedCount: context.processedCount,\n      }\n    );\n    await processChunk(chunkRecords);\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"repositoryCases\");\n    await persistProgress(\"repositoryCases\", message);\n  }\n\n  // Log dropdown/multi-select field processing summary\n  if (dropdownStats.size > 0) {\n    console.log(\"\\n========== DROPDOWN/MULTI-SELECT FIELD SUMMARY ==========\");\n    for (const [fieldName, stats] of dropdownStats) {\n      console.log(`\\nField: ${fieldName}`);\n      console.log(`  Total attempts: ${stats.totalAttempts}`);\n      console.log(`  Successful: ${stats.successResults}`);\n      console.log(`  Failed (null): ${stats.nullResults}`);\n      if (stats.sampleValues.size > 0) {\n        console.log(\n          `  Sample success values: ${Array.from(stats.sampleValues).join(\", \")}`\n        );\n      }\n      if (stats.sampleNulls.length > 0) {\n        console.log(\n          `  Sample failed raw values: ${stats.sampleNulls.join(\", \")}`\n        );\n      }\n    }\n    console.log(\"==========================================================\\n\");\n  }\n\n  logMessage(context, `Repository cases import completed`, {\n    totalProcessed: summary.total,\n    created: summary.created,\n    mapped: summary.mapped,\n    finalProcessedCount: context.processedCount,\n    dropdownFieldSummary: Array.from(dropdownStats.entries()).map(\n      ([field, stats]) => ({\n        field,\n        attempts: stats.totalAttempts,\n        success: stats.successResults,\n        failed: stats.nullResults,\n      })\n    ),\n  });\n\n  if (templateAssignmentsByProject.size > 0) {\n    const assignmentRows: Array<{ projectId: number; templateId: number }> = [];\n    for (const [projectId, templateIds] of templateAssignmentsByProject) {\n      for (const templateId of templateIds) {\n        assignmentRows.push({ projectId, templateId });\n      }\n    }\n\n    if (assignmentRows.length > 0) {\n      await prisma.templateProjectAssignment.createMany({\n        data: assignmentRows,\n        skipDuplicates: true,\n      });\n    }\n  }\n\n  if ((summaryDetails.estimateAdjusted ?? 0) > 0) {\n    logMessage(\n      context,\n      \"Converted repository case estimates from smaller units\",\n      {\n        adjustments: summaryDetails.estimateAdjusted,\n      }\n    );\n  }\n\n  if ((summaryDetails.estimateClamped ?? 0) > 0) {\n    logMessage(\n      context,\n      \"Clamped oversized repository case estimates to int32 range\",\n      {\n        clamped: summaryDetails.estimateClamped,\n      }\n    );\n  }\n\n  caseRows.length = 0;\n  repositoryCaseStepRows.length = 0;\n  canonicalCaseRows.length = 0;\n  canonicalCaseIds.clear();\n  stepsByCaseId.clear();\n  clearTipTapCache();\n\n  return {\n    summary,\n    caseIdMap,\n    caseFieldMap,\n    caseFieldMetadataById,\n    caseMetaMap,\n  };\n};\n\nconst importTestRuns = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  _canonicalRepoIdByProject: Map<number, Set<number>>,\n  configurationIdMap: Map<number, number>,\n  milestoneIdMap: Map<number, number>,\n  workflowIdMap: Map<number, number>,\n  userIdMap: Map<number, string>,\n  importJob: TestmoImportJob,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<TestRunsImportResult> => {\n  const runRows = datasetRows.get(\"runs\") ?? [];\n  const summary: EntitySummaryResult = {\n    entity: \"testRuns\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n    details: {\n      forecastAdjusted: 0,\n      forecastClamped: 0,\n      elapsedAdjusted: 0,\n      elapsedClamped: 0,\n    },\n  };\n\n  const summaryDetails = summary.details as Record<string, number>;\n  const testRunIdMap = new Map<number, number>();\n\n  if (runRows.length === 0) {\n    logMessage(context, \"No runs dataset found; skipping test run import.\");\n    return { summary, testRunIdMap };\n  }\n\n  initializeEntityProgress(context, \"testRuns\", runRows.length);\n  let processedSinceLastPersist = 0;\n\n  for (const row of runRows) {\n    const record = row as Record<string, unknown>;\n    const sourceId = toNumberValue(record.id);\n    const projectSourceId = toNumberValue(record.project_id);\n\n    if (sourceId === null || projectSourceId === null) {\n      decrementEntityTotal(context, \"testRuns\");\n      continue;\n    }\n\n    const projectId = projectIdMap.get(projectSourceId);\n    if (!projectId) {\n      logMessage(context, \"Skipping test run due to missing project mapping\", {\n        sourceId,\n        projectSourceId,\n      });\n      decrementEntityTotal(context, \"testRuns\");\n      continue;\n    }\n\n    const workflowSourceId = toNumberValue(record.state_id);\n    const stateId =\n      workflowSourceId !== null\n        ? (workflowIdMap.get(workflowSourceId) ?? null)\n        : null;\n\n    if (!stateId) {\n      logMessage(context, \"Skipping test run due to missing workflow mapping\", {\n        sourceId,\n        workflowSourceId,\n      });\n      decrementEntityTotal(context, \"testRuns\");\n      continue;\n    }\n\n    const configurationSourceId = toNumberValue(record.config_id);\n    const configurationId =\n      configurationSourceId !== null\n        ? (configurationIdMap.get(configurationSourceId) ?? null)\n        : null;\n\n    const milestoneSourceId = toNumberValue(record.milestone_id);\n    const milestoneId =\n      milestoneSourceId !== null\n        ? (milestoneIdMap.get(milestoneSourceId) ?? null)\n        : null;\n\n    const name = toStringValue(record.name) ?? `Imported Run ${sourceId}`;\n    const note = convertToTipTapJsonString(record.note);\n    const docs = convertToTipTapJsonString(record.docs);\n    const createdAt = toDateValue(record.created_at) ?? new Date();\n    const completedAt = toDateValue(record.closed_at);\n    const isCompleted = toBooleanValue(record.is_closed);\n\n    const createdById = resolveUserId(\n      userIdMap,\n      importJob.createdById,\n      record.created_by\n    );\n\n    const forecastValue = toNumberValue(record.forecast);\n    const elapsedValue = toNumberValue(record.elapsed);\n\n    const { value: normalizedForecast, adjustment: forecastAdjustment } =\n      normalizeEstimate(forecastValue);\n    const { value: normalizedElapsed, adjustment: elapsedAdjustment } =\n      normalizeEstimate(elapsedValue);\n\n    if (\n      forecastAdjustment === \"microseconds\" ||\n      forecastAdjustment === \"nanoseconds\"\n    ) {\n      summaryDetails.forecastAdjusted += 1;\n    } else if (forecastAdjustment === \"milliseconds\") {\n      summaryDetails.forecastAdjusted += 1;\n    } else if (forecastAdjustment === \"clamped\") {\n      summaryDetails.forecastClamped += 1;\n    }\n\n    if (\n      elapsedAdjustment === \"microseconds\" ||\n      elapsedAdjustment === \"nanoseconds\"\n    ) {\n      summaryDetails.elapsedAdjusted += 1;\n    } else if (elapsedAdjustment === \"milliseconds\") {\n      summaryDetails.elapsedAdjusted += 1;\n    } else if (elapsedAdjustment === \"clamped\") {\n      summaryDetails.elapsedClamped += 1;\n    }\n\n    const createdRun = await tx.testRuns.create({\n      data: {\n        projectId,\n        name,\n        note: note ?? undefined,\n        docs: docs ?? undefined,\n        configId: configurationId ?? undefined,\n        milestoneId: milestoneId ?? undefined,\n        stateId,\n        forecastManual: normalizedForecast ?? undefined,\n        elapsed: normalizedElapsed ?? undefined,\n        isCompleted,\n        createdAt,\n        createdById,\n        completedAt: completedAt ?? undefined,\n      },\n    });\n\n    testRunIdMap.set(sourceId, createdRun.id);\n    summary.total += 1;\n    summary.created += 1;\n\n    incrementEntityProgress(context, \"testRuns\", 1, 0);\n    processedSinceLastPersist += 1;\n\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      const message = formatInProgressStatus(context, \"testRuns\");\n      await persistProgress(\"testRuns\", message);\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"testRuns\");\n    await persistProgress(\"testRuns\", message);\n  }\n\n  if ((summaryDetails.forecastAdjusted ?? 0) > 0) {\n    logMessage(context, \"Adjusted test run forecasts to int32 range\", {\n      adjustments: summaryDetails.forecastAdjusted,\n    });\n  }\n\n  if ((summaryDetails.forecastClamped ?? 0) > 0) {\n    logMessage(context, \"Clamped oversized test run forecasts to int32 range\", {\n      clamped: summaryDetails.forecastClamped,\n    });\n  }\n\n  if ((summaryDetails.elapsedAdjusted ?? 0) > 0) {\n    logMessage(context, \"Adjusted test run elapsed durations to int32 range\", {\n      adjustments: summaryDetails.elapsedAdjusted,\n    });\n  }\n\n  if ((summaryDetails.elapsedClamped ?? 0) > 0) {\n    logMessage(context, \"Clamped oversized test run elapsed durations\", {\n      clamped: summaryDetails.elapsedClamped,\n    });\n  }\n\n  return { summary, testRunIdMap };\n};\n\nconst importTestRunCases = async (\n  datasetRows: Map<string, any[]>,\n  testRunIdMap: Map<number, number>,\n  caseIdMap: Map<number, number>,\n  caseMetaMap: Map<number, { projectId: number; name: string }>,\n  userIdMap: Map<number, string>,\n  statusIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<TestRunCasesImportResult> => {\n  const runTestRows = datasetRows.get(\"run_tests\") ?? [];\n  const entityName = \"testRunCases\";\n  const summary: EntitySummaryResult = {\n    entity: \"testRunCases\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n    details: {\n      skippedUnselected: 0,\n      importedUnselectedWithResults: 0,\n    },\n  };\n\n  const summaryDetails = summary.details as Record<string, number>;\n  const testRunCaseIdMap = new Map<number, number>();\n\n  if (runTestRows.length === 0) {\n    logMessage(\n      context,\n      \"No run_tests dataset found; skipping test run case import.\"\n    );\n    return { summary, testRunCaseIdMap };\n  }\n\n  initializeEntityProgress(context, entityName, runTestRows.length);\n  const progressEntry = context.entityProgress[entityName]!;\n  progressEntry.total = runTestRows.length;\n\n  let processedRows = 0;\n  let lastReportedCount = 0;\n  let lastReportAt = context.lastProgressUpdate;\n  const minProgressDelta = Math.max(\n    1,\n    Math.floor(Math.max(runTestRows.length, 1) / 50)\n  );\n  const minProgressIntervalMs = 2000;\n\n  const reportProgress = async (force = false) => {\n    if (runTestRows.length === 0) {\n      return;\n    }\n    const now = Date.now();\n    const deltaCount = processedRows - lastReportedCount;\n    if (\n      !force &&\n      deltaCount < minProgressDelta &&\n      now - lastReportAt < minProgressIntervalMs\n    ) {\n      return;\n    }\n\n    progressEntry.mapped = Math.min(processedRows, progressEntry.total);\n    const processed = progressEntry.mapped;\n    const totalForStatus = progressEntry.total;\n\n    lastReportedCount = processedRows;\n    lastReportAt = now;\n\n    const statusMessage = `Processing test run case imports (${processed.toLocaleString()} / ${totalForStatus.toLocaleString()} cases processed)`;\n    await persistProgress(entityName, statusMessage);\n  };\n\n  const completedStatusRecords = await prisma.status.findMany({\n    select: { id: true, isCompleted: true },\n  });\n  const completedStatusIds = new Set<number>();\n  for (const record of completedStatusRecords) {\n    if (record.isCompleted) {\n      completedStatusIds.add(record.id);\n    }\n  }\n\n  const orderCounters = new Map<number, number>();\n  const processedPairs = new Map<string, number>();\n  const runTestIdsWithResults = new Set<number>();\n\n  const runResultRows = datasetRows.get(\"run_results\") ?? [];\n  if (runResultRows.length > 0) {\n    for (const row of runResultRows) {\n      const resultRecord = row as Record<string, unknown>;\n      const runTestSourceId = toNumberValue(resultRecord.test_id);\n      if (runTestSourceId !== null) {\n        runTestIdsWithResults.add(runTestSourceId);\n      }\n    }\n  }\n\n  await reportProgress(true);\n\n  const batchSize = Math.max(1, Math.floor(TEST_RUN_CASE_CHUNK_SIZE / 2));\n\n  for (let start = 0; start < runTestRows.length; start += batchSize) {\n    const batch = runTestRows.slice(start, start + batchSize);\n\n    const mappedRecords: Array<{\n      record: Record<string, unknown>;\n      data: Prisma.TestRunCasesCreateManyInput;\n      runTestSourceId: number;\n    }> = [];\n    let duplicateMappingsInBatch = 0;\n\n    for (const row of batch) {\n      const record = row as Record<string, unknown>;\n      processedRows += 1;\n      const runTestSourceId = toNumberValue(record.id);\n      const runSourceId = toNumberValue(record.run_id);\n      const caseSourceId = toNumberValue(record.case_id);\n      const caseName =\n        toStringValue(record.name) ?? `Imported Case ${caseSourceId ?? 0}`;\n\n      if (\n        runTestSourceId === null ||\n        runSourceId === null ||\n        caseSourceId === null\n      ) {\n        decrementEntityTotal(context, \"testRunCases\");\n        continue;\n      }\n\n      const isSelected = toBooleanValue(record.is_selected);\n      const hasLinkedResults = runTestIdsWithResults.has(runTestSourceId);\n      if (!isSelected && !hasLinkedResults) {\n        summaryDetails.skippedUnselected += 1;\n        decrementEntityTotal(context, \"testRunCases\");\n        continue;\n      }\n\n      if (!isSelected && hasLinkedResults) {\n        summaryDetails.importedUnselectedWithResults += 1;\n      }\n\n      const testRunId = testRunIdMap.get(runSourceId);\n      if (!testRunId) {\n        logMessage(\n          context,\n          \"Skipping test run case due to missing run mapping\",\n          {\n            runTestSourceId,\n            runSourceId,\n          }\n        );\n        decrementEntityTotal(context, \"testRunCases\");\n        continue;\n      }\n\n      let repositoryCaseId = caseIdMap.get(caseSourceId);\n\n      if (!repositoryCaseId && caseSourceId !== null) {\n        const meta = caseMetaMap.get(caseSourceId);\n        if (meta) {\n          const fallbackCase = await prisma.repositoryCases.findFirst({\n            where: {\n              projectId: meta.projectId,\n              name: meta.name,\n              isDeleted: false,\n            },\n            select: { id: true },\n          });\n\n          if (fallbackCase) {\n            repositoryCaseId = fallbackCase.id;\n            caseIdMap.set(caseSourceId, fallbackCase.id);\n          }\n        }\n      }\n\n      if (!repositoryCaseId) {\n        logMessage(\n          context,\n          \"Skipping test run case due to missing repository case\",\n          {\n            runTestSourceId,\n            caseSourceId,\n          }\n        );\n        decrementEntityTotal(context, \"testRunCases\");\n        continue;\n      }\n\n      const pairKey = `${testRunId}:${repositoryCaseId}`;\n      const existingTestRunCaseId = processedPairs.get(pairKey);\n      if (existingTestRunCaseId !== undefined) {\n        testRunCaseIdMap.set(runTestSourceId, existingTestRunCaseId);\n        summary.total += 1;\n        summary.mapped += 1;\n        duplicateMappingsInBatch += 1;\n        continue;\n      }\n\n      const statusSourceId = toNumberValue(record.status_id);\n      const statusId =\n        statusSourceId !== null\n          ? (statusIdMap.get(statusSourceId) ?? null)\n          : null;\n      const assignedSourceId = toNumberValue(record.assignee_id);\n      const assignedToId =\n        assignedSourceId !== null\n          ? (userIdMap.get(assignedSourceId) ?? null)\n          : null;\n\n      const elapsedValue = toNumberValue(record.elapsed);\n      const { value: normalizedElapsed } = normalizeEstimate(elapsedValue);\n\n      const currentOrder = orderCounters.get(testRunId) ?? 0;\n      orderCounters.set(testRunId, currentOrder + 1);\n\n      const isCompleted =\n        Boolean(statusId) && completedStatusIds.has(statusId as number);\n\n      mappedRecords.push({\n        record,\n        runTestSourceId,\n        data: {\n          testRunId,\n          repositoryCaseId,\n          order: currentOrder,\n          statusId: statusId ?? undefined,\n          assignedToId: assignedToId ?? undefined,\n          elapsed: normalizedElapsed ?? undefined,\n          isCompleted,\n        },\n      });\n    }\n\n    if (mappedRecords.length > 0) {\n      // Execute database operations in a transaction per batch\n      const { createResult, persistedPairs } = await prisma.$transaction(\n        async (tx) => {\n          const createResult = await tx.testRunCases.createMany({\n            data: mappedRecords.map((item) => item.data),\n            skipDuplicates: true,\n          });\n\n          const persistedPairs = await tx.testRunCases.findMany({\n            where: {\n              OR: mappedRecords.map((item) => ({\n                testRunId: item.data.testRunId,\n                repositoryCaseId: item.data.repositoryCaseId,\n              })),\n            },\n            select: {\n              testRunId: true,\n              repositoryCaseId: true,\n              id: true,\n            },\n          });\n\n          return { createResult, persistedPairs };\n        },\n        {\n          timeout: IMPORT_TRANSACTION_TIMEOUT_MS,\n          maxWait: IMPORT_TRANSACTION_MAX_WAIT_MS,\n        }\n      );\n\n      summary.total += mappedRecords.length;\n      summary.created += createResult.count;\n      progressEntry.created += createResult.count;\n\n      const sourceIdsByKey = new Map<string, number[]>();\n      for (const item of mappedRecords) {\n        const key = `${item.data.testRunId}:${item.data.repositoryCaseId}`;\n        const sourceIds = sourceIdsByKey.get(key);\n        if (sourceIds) {\n          sourceIds.push(item.runTestSourceId);\n        } else {\n          sourceIdsByKey.set(key, [item.runTestSourceId]);\n        }\n      }\n\n      for (const persisted of persistedPairs) {\n        const key = `${persisted.testRunId}:${persisted.repositoryCaseId}`;\n        processedPairs.set(key, persisted.id);\n        const sourceIds = sourceIdsByKey.get(key) ?? [];\n        if (sourceIds.length === 0) {\n          continue;\n        }\n        for (const sourceId of sourceIds) {\n          testRunCaseIdMap.set(sourceId, persisted.id);\n        }\n      }\n\n      const createdCount = createResult.count;\n      const mappedCount =\n        mappedRecords.length > createdCount\n          ? mappedRecords.length - createdCount\n          : 0;\n      incrementEntityProgress(\n        context,\n        \"testRunCases\",\n        createdCount,\n        mappedCount\n      );\n    }\n\n    if (duplicateMappingsInBatch > 0) {\n      incrementEntityProgress(\n        context,\n        \"testRunCases\",\n        0,\n        duplicateMappingsInBatch\n      );\n    }\n\n    await reportProgress();\n  }\n\n  await reportProgress(true);\n\n  return { summary, testRunCaseIdMap };\n};\n\nconst importTestRunResults = async (\n  datasetRows: Map<string, any[]>,\n  testRunIdMap: Map<number, number>,\n  testRunCaseIdMap: Map<number, number>,\n  statusIdMap: Map<number, number>,\n  userIdMap: Map<number, string>,\n  resultFieldMap: Map<string, number>,\n  importJob: TestmoImportJob,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<{\n  summary: EntitySummaryResult;\n  testRunResultIdMap: Map<number, number>;\n}> => {\n  const resultRows = datasetRows.get(\"run_results\") ?? [];\n  datasetRows.delete(\"run_results\");\n  const summary: EntitySummaryResult = {\n    entity: \"testRunResults\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n    details: {\n      elapsedAdjusted: 0,\n      elapsedClamped: 0,\n      missingStatus: 0,\n    },\n  };\n\n  const summaryDetails = summary.details as Record<string, number>;\n  const testRunResultIdMap = new Map<number, number>();\n  const testRunCaseVersionCache = new Map<number, number>();\n\n  if (resultRows.length === 0) {\n    logMessage(\n      context,\n      \"No run_results dataset found; skipping test run result import.\"\n    );\n    return { summary, testRunResultIdMap };\n  }\n\n  // Get the default \"untested\" status to use when source status is null\n  const untestedStatus = await prisma.status.findFirst({\n    where: { systemName: \"untested\" },\n    select: { id: true },\n  });\n\n  if (!untestedStatus) {\n    throw new Error(\"Default 'untested' status not found in workspace\");\n  }\n\n  const defaultStatusId = untestedStatus.id;\n\n  initializeEntityProgress(context, \"testRunResults\", resultRows.length);\n  let processedSinceLastPersist = 0;\n  const chunkSize = Math.max(1, TEST_RUN_RESULT_CHUNK_SIZE);\n  logMessage(context, `Processing test run results in batches of ${chunkSize}`);\n\n  const processChunk = async (\n    records: Array<Record<string, unknown>>\n  ): Promise<void> => {\n    if (records.length === 0) {\n      return;\n    }\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const record of records) {\n          const resultSourceId = toNumberValue(record.id);\n          const runSourceId = toNumberValue(record.run_id);\n          const runTestSourceId = toNumberValue(record.test_id);\n\n          if (\n            resultSourceId === null ||\n            runSourceId === null ||\n            runTestSourceId === null\n          ) {\n            decrementEntityTotal(context, \"testRunResults\");\n            continue;\n          }\n\n          if (toBooleanValue(record.is_deleted)) {\n            decrementEntityTotal(context, \"testRunResults\");\n            continue;\n          }\n\n          const testRunId = testRunIdMap.get(runSourceId);\n          if (!testRunId) {\n            logMessage(\n              context,\n              \"Skipping test run result due to missing run mapping\",\n              {\n                resultSourceId,\n                runSourceId,\n              }\n            );\n            decrementEntityTotal(context, \"testRunResults\");\n            continue;\n          }\n\n          const testRunCaseId = testRunCaseIdMap.get(runTestSourceId);\n          if (!testRunCaseId) {\n            logMessage(\n              context,\n              \"Skipping test run result due to missing run case mapping\",\n              {\n                resultSourceId,\n                runTestSourceId,\n              }\n            );\n            decrementEntityTotal(context, \"testRunResults\");\n            continue;\n          }\n\n          const statusSourceId = toNumberValue(record.status_id);\n          const statusId =\n            statusSourceId !== null\n              ? (statusIdMap.get(statusSourceId) ?? defaultStatusId)\n              : defaultStatusId;\n\n          const executedById = resolveUserId(\n            userIdMap,\n            importJob.createdById,\n            record.created_by\n          );\n          const executedAt = toDateValue(record.created_at) ?? new Date();\n\n          const elapsedValue = toNumberValue(record.elapsed);\n          const { value: normalizedElapsed, adjustment: elapsedAdjustment } =\n            normalizeEstimate(elapsedValue);\n\n          if (\n            elapsedAdjustment === \"microseconds\" ||\n            elapsedAdjustment === \"nanoseconds\"\n          ) {\n            summaryDetails.elapsedAdjusted += 1;\n          } else if (elapsedAdjustment === \"milliseconds\") {\n            summaryDetails.elapsedAdjusted += 1;\n          } else if (elapsedAdjustment === \"clamped\") {\n            summaryDetails.elapsedClamped += 1;\n          }\n\n          const comment = toStringValue(record.comment);\n\n          let testRunCaseVersion = testRunCaseVersionCache.get(testRunCaseId);\n          if (testRunCaseVersion === undefined) {\n            const runCase = await tx.testRunCases.findUnique({\n              where: { id: testRunCaseId },\n              select: {\n                repositoryCase: {\n                  select: { currentVersion: true },\n                },\n              },\n            });\n            testRunCaseVersion = runCase?.repositoryCase?.currentVersion ?? 1;\n            testRunCaseVersionCache.set(testRunCaseId, testRunCaseVersion);\n          }\n\n          const createdResult = await tx.testRunResults.create({\n            data: {\n              testRunId,\n              testRunCaseId,\n              testRunCaseVersion,\n              statusId,\n              executedById,\n              executedAt,\n              elapsed: normalizedElapsed ?? undefined,\n              notes: comment ? toInputJsonValue(comment) : undefined,\n            },\n          });\n\n          // Store the mapping from Testmo result ID to our result ID\n          testRunResultIdMap.set(resultSourceId, createdResult.id);\n\n          for (const [key, rawValue] of Object.entries(record)) {\n            if (!key.startsWith(\"custom_\")) {\n              continue;\n            }\n            const fieldName = key.replace(/^custom_/, \"\");\n            const fieldId = resultFieldMap.get(fieldName);\n            if (!fieldId) {\n              continue;\n            }\n            if (\n              rawValue === null ||\n              rawValue === undefined ||\n              (typeof rawValue === \"string\" && rawValue.trim().length === 0)\n            ) {\n              continue;\n            }\n\n            await tx.resultFieldValues.create({\n              data: {\n                testRunResultsId: createdResult.id,\n                fieldId,\n                value: toInputJsonValue(rawValue),\n              },\n            });\n          }\n\n          summary.total += 1;\n          summary.created += 1;\n\n          incrementEntityProgress(context, \"testRunResults\", 1, 0);\n          processedSinceLastPersist += 1;\n\n          if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n            const message = formatInProgressStatus(context, \"testRunResults\");\n            await persistProgress(\"testRunResults\", message);\n            processedSinceLastPersist = 0;\n          }\n        }\n      },\n      {\n        timeout: IMPORT_TRANSACTION_TIMEOUT_MS,\n        maxWait: IMPORT_TRANSACTION_MAX_WAIT_MS,\n      }\n    );\n\n    clearTipTapCache();\n  };\n\n  while (resultRows.length > 0) {\n    const chunkRecords = resultRows.splice(\n      Math.max(resultRows.length - chunkSize, 0)\n    ) as Array<Record<string, unknown>>;\n    await processChunk(chunkRecords);\n  }\n\n  if (processedSinceLastPersist > 0) {\n    const message = formatInProgressStatus(context, \"testRunResults\");\n    await persistProgress(\"testRunResults\", message);\n  }\n\n  if ((summaryDetails.elapsedAdjusted ?? 0) > 0) {\n    logMessage(context, \"Adjusted test run result elapsed durations\", {\n      adjustments: summaryDetails.elapsedAdjusted,\n    });\n  }\n\n  if ((summaryDetails.elapsedClamped ?? 0) > 0) {\n    logMessage(context, \"Clamped oversized test run result elapsed durations\", {\n      clamped: summaryDetails.elapsedClamped,\n    });\n  }\n\n  if ((summaryDetails.missingStatus ?? 0) > 0) {\n    logMessage(\n      context,\n      \"Skipped test run results due to missing status mapping\",\n      {\n        skipped: summaryDetails.missingStatus,\n      }\n    );\n  }\n\n  resultRows.length = 0;\n  clearTipTapCache();\n  return { summary, testRunResultIdMap };\n};\n\nconst importTestRunStepResults = async (\n  datasetRows: Map<string, any[]>,\n  testRunResultIdMap: Map<number, number>,\n  testRunCaseIdMap: Map<number, number>,\n  statusIdMap: Map<number, number>,\n  _caseIdMap: Map<number, number>,\n  importJob: TestmoImportJob,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<EntitySummaryResult> => {\n  const entityName = \"testRunStepResults\";\n  const stepResultRows = datasetRows.get(\"run_result_steps\") ?? [];\n  const summary: EntitySummaryResult = {\n    entity: entityName,\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const plannedTotal =\n    context.entityProgress[entityName]?.total ?? stepResultRows.length;\n  const shouldStream =\n    stepResultRows.length === 0 && plannedTotal > 0 && !!context.jobId;\n\n  if (!shouldStream && stepResultRows.length === 0) {\n    logMessage(\n      context,\n      \"No run_result_steps dataset found; skipping step result import.\"\n    );\n    return summary;\n  }\n\n  const fetchBatchSize = 500;\n\n  const rehydrateRow = (\n    data: unknown,\n    text1?: string | null,\n    text2?: string | null,\n    text3?: string | null,\n    text4?: string | null\n  ): Record<string, unknown> => {\n    const cloned =\n      typeof data === \"object\" && data !== null\n        ? (JSON.parse(JSON.stringify(data)) as Record<string, unknown>)\n        : {};\n    const record =\n      cloned && typeof cloned === \"object\"\n        ? (cloned as Record<string, unknown>)\n        : ({} as Record<string, unknown>);\n\n    const textEntries: Array<[string, string | null | undefined]> = [\n      [\"text1\", text1],\n      [\"text2\", text2],\n      [\"text3\", text3],\n      [\"text4\", text4],\n    ];\n\n    for (const [key, value] of textEntries) {\n      if (value !== null && value !== undefined && record[key] === undefined) {\n        record[key] = value;\n      }\n    }\n\n    return record;\n  };\n\n  const createChunkIterator = () => {\n    if (!shouldStream) {\n      return (async function* () {\n        for (\n          let offset = 0;\n          offset < stepResultRows.length;\n          offset += fetchBatchSize\n        ) {\n          const chunk = stepResultRows\n            .slice(offset, offset + fetchBatchSize)\n            .map((row) =>\n              typeof row === \"object\" && row !== null\n                ? (JSON.parse(JSON.stringify(row)) as Record<string, unknown>)\n                : ({} as Record<string, unknown>)\n            );\n          yield chunk;\n        }\n      })();\n    }\n\n    if (!context.jobId) {\n      throw new Error(\n        \"importTestRunStepResults requires context.jobId for streaming\"\n      );\n    }\n\n    return (async function* () {\n      let nextRowIndex = 0;\n      while (true) {\n        const stagedRows = await prisma.testmoImportStaging.findMany({\n          where: {\n            jobId: context.jobId!,\n            datasetName: \"run_result_steps\",\n            rowIndex: {\n              gte: nextRowIndex,\n              lt: nextRowIndex + fetchBatchSize,\n            },\n          },\n          orderBy: {\n            rowIndex: \"asc\",\n          },\n          select: {\n            rowIndex: true,\n            rowData: true,\n            text1: true,\n            text2: true,\n            text3: true,\n            text4: true,\n          },\n        });\n\n        if (stagedRows.length === 0) {\n          break;\n        }\n\n        nextRowIndex = stagedRows[stagedRows.length - 1].rowIndex + 1;\n\n        yield stagedRows.map((row) =>\n          rehydrateRow(row.rowData, row.text1, row.text2, row.text3, row.text4)\n        );\n      }\n    })();\n  };\n\n  const repositoryCaseIdByTestRunCaseId = new Map<number, number>();\n  const missingRepositoryCaseIds = new Set<number>();\n\n  const ensureRepositoryCasesLoaded = async (\n    ids: Iterable<number>\n  ): Promise<void> => {\n    const uniqueIds = Array.from(\n      new Set(\n        Array.from(ids).filter(\n          (id) =>\n            !repositoryCaseIdByTestRunCaseId.has(id) &&\n            !missingRepositoryCaseIds.has(id)\n        )\n      )\n    );\n\n    if (uniqueIds.length === 0) {\n      return;\n    }\n\n    const cases = await prisma.testRunCases.findMany({\n      where: { id: { in: uniqueIds } },\n      select: { id: true, repositoryCaseId: true },\n    });\n\n    const foundIds = new Set<number>();\n    for (const testRunCase of cases) {\n      repositoryCaseIdByTestRunCaseId.set(\n        testRunCase.id,\n        testRunCase.repositoryCaseId\n      );\n      foundIds.add(testRunCase.id);\n    }\n\n    for (const id of uniqueIds) {\n      if (!foundIds.has(id)) {\n        missingRepositoryCaseIds.add(id);\n      }\n    }\n  };\n\n  const untestedStatus = await prisma.status.findFirst({\n    where: { systemName: \"untested\" },\n    select: { id: true },\n  });\n\n  if (!untestedStatus) {\n    throw new Error(\"Default 'untested' status not found\");\n  }\n\n  const defaultStatusId = untestedStatus.id;\n\n  initializeEntityProgress(context, entityName, plannedTotal);\n\n  const chunkIterator = createChunkIterator();\n  let processedCount = 0;\n\n  for await (const chunk of chunkIterator) {\n    const stepEntries: Array<{\n      resultId: number;\n      testRunCaseId: number;\n      displayOrder: number;\n      record: Record<string, unknown>;\n    }> = [];\n    const caseIdsForChunk = new Set<number>();\n\n    for (const row of chunk) {\n      const record = row as Record<string, unknown>;\n      const resultSourceId = toNumberValue(record.result_id);\n      const testRunCaseSourceId = toNumberValue(record.test_id);\n      const displayOrder = toNumberValue(record.display_order);\n\n      if (\n        resultSourceId === null ||\n        testRunCaseSourceId === null ||\n        displayOrder === null\n      ) {\n        decrementEntityTotal(context, entityName);\n        continue;\n      }\n\n      const resultId = testRunResultIdMap.get(resultSourceId);\n      const testRunCaseId = testRunCaseIdMap.get(testRunCaseSourceId);\n\n      if (!resultId || !testRunCaseId) {\n        decrementEntityTotal(context, entityName);\n        continue;\n      }\n\n      caseIdsForChunk.add(testRunCaseId);\n      stepEntries.push({\n        resultId,\n        testRunCaseId,\n        displayOrder,\n        record,\n      });\n    }\n\n    if (stepEntries.length === 0) {\n      continue;\n    }\n\n    await ensureRepositoryCasesLoaded(caseIdsForChunk);\n\n    for (const stepEntry of stepEntries) {\n      const { resultId, testRunCaseId, displayOrder, record } = stepEntry;\n\n      const repositoryCaseId =\n        repositoryCaseIdByTestRunCaseId.get(testRunCaseId);\n\n      if (!repositoryCaseId) {\n        decrementEntityTotal(context, entityName);\n        continue;\n      }\n\n      const stepAction = toStringValue(record.text1);\n      const stepData = toStringValue(record.text2);\n      const expectedResult = toStringValue(record.text3);\n      const expectedResultData = toStringValue(record.text4);\n\n      let stepContent: string | null = null;\n      if (stepAction || stepData) {\n        stepContent = stepAction || \"\";\n        if (stepData) {\n          stepContent += (stepContent ? \"\\n\" : \"\") + `<data>${stepData}</data>`;\n        }\n      }\n\n      let expectedResultContent: string | null = null;\n      if (expectedResult || expectedResultData) {\n        expectedResultContent = expectedResult || \"\";\n        if (expectedResultData) {\n          expectedResultContent +=\n            (expectedResultContent ? \"\\n\" : \"\") +\n            `<data>${expectedResultData}</data>`;\n        }\n      }\n\n      const stepPayload = stepContent\n        ? convertToTipTapJsonValue(stepContent)\n        : null;\n      const expectedPayload = expectedResultContent\n        ? convertToTipTapJsonValue(expectedResultContent)\n        : null;\n\n      const createdStep = await prisma.steps.create({\n        data: {\n          testCaseId: repositoryCaseId,\n          order: displayOrder,\n          step: stepPayload ? JSON.stringify(stepPayload) : undefined,\n          expectedResult: expectedPayload\n            ? JSON.stringify(expectedPayload)\n            : undefined,\n        },\n      });\n\n      const statusSourceId = toNumberValue(record.status_id);\n      const statusId =\n        statusSourceId !== null\n          ? (statusIdMap.get(statusSourceId) ?? defaultStatusId)\n          : defaultStatusId;\n\n      const comment = toStringValue(record.comment);\n      const elapsed = toNumberValue(record.elapsed);\n\n      try {\n        await prisma.testRunStepResults.create({\n          data: {\n            testRunResultId: resultId,\n            stepId: createdStep.id,\n            statusId,\n            notes: comment ? toInputJsonValue(comment) : undefined,\n            elapsed: elapsed ?? undefined,\n          },\n        });\n\n        summary.total += 1;\n        summary.created += 1;\n      } catch (error) {\n        logMessage(context, \"Skipping duplicate step result\", {\n          resultId,\n          stepId: createdStep.id,\n          error: String(error),\n        });\n        decrementEntityTotal(context, entityName);\n      }\n\n      processedCount += 1;\n      incrementEntityProgress(context, entityName, 1, 0);\n\n      if (processedCount % PROGRESS_UPDATE_INTERVAL === 0) {\n        const message = formatInProgressStatus(context, entityName);\n        await persistProgress(entityName, message);\n      }\n    }\n  }\n\n  return summary;\n};\n\nasync function importStatuses(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"statuses\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const scopeRecords = await tx.statusScope.findMany({ select: { id: true } });\n  const availableScopeIds = scopeRecords.map((record) => record.id);\n\n  if (availableScopeIds.length === 0) {\n    throw new Error(\n      \"No status scopes are configured in the workspace. Unable to import statuses.\"\n    );\n  }\n\n  const colorCacheById = new Map<number, boolean>();\n  const colorCacheByHex = new Map<string, number>();\n\n  const resolveColorId = async (\n    desiredId?: number | null,\n    desiredHex?: string | null\n  ): Promise<number> => {\n    if (desiredId !== null && desiredId !== undefined) {\n      if (!colorCacheById.has(desiredId)) {\n        const exists = await tx.color.findUnique({ where: { id: desiredId } });\n        if (!exists) {\n          throw new Error(\n            `Color ${desiredId} configured for a status does not exist.`\n          );\n        }\n        colorCacheById.set(desiredId, true);\n      }\n      return desiredId;\n    }\n\n    const normalizedHex =\n      normalizeColorHex(desiredHex) ?? DEFAULT_STATUS_COLOR_HEX;\n\n    if (colorCacheByHex.has(normalizedHex)) {\n      return colorCacheByHex.get(normalizedHex)!;\n    }\n\n    const color = await tx.color.findFirst({ where: { value: normalizedHex } });\n\n    if (color) {\n      colorCacheByHex.set(normalizedHex, color.id);\n      return color.id;\n    }\n\n    if (normalizedHex !== DEFAULT_STATUS_COLOR_HEX) {\n      return resolveColorId(undefined, DEFAULT_STATUS_COLOR_HEX);\n    }\n\n    throw new Error(\n      \"Unable to resolve a color to apply to an imported status.\"\n    );\n  };\n\n  for (const [key, config] of Object.entries(configuration.statuses ?? {})) {\n    const statusId = Number(key);\n    if (!Number.isFinite(statusId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Status ${statusId} is configured to map but no target status was provided.`\n        );\n      }\n\n      const existing = await tx.status.findUnique({\n        where: { id: config.mappedTo },\n      });\n\n      if (!existing) {\n        throw new Error(\n          `Status ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      config.mappedTo = existing.id;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (config.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(\n        `Status ${statusId} requires a display name before it can be created.`\n      );\n    }\n\n    let systemName = (config.systemName ?? \"\").trim();\n    if (!SYSTEM_NAME_REGEX.test(systemName)) {\n      systemName = generateSystemName(name);\n    }\n\n    if (!SYSTEM_NAME_REGEX.test(systemName)) {\n      throw new Error(\n        `Status \"${name}\" requires a valid system name (letters, numbers, underscore, starting with a letter).`\n      );\n    }\n\n    const existingByName = await tx.status.findFirst({\n      where: {\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (existingByName) {\n      config.action = \"map\";\n      config.mappedTo = existingByName.id;\n      config.name = existingByName.name;\n      config.systemName = existingByName.systemName;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const existingStatus = await tx.status.findFirst({\n      where: {\n        systemName,\n        isDeleted: false,\n      },\n    });\n\n    if (existingStatus) {\n      config.action = \"map\";\n      config.mappedTo = existingStatus.id;\n      config.systemName = existingStatus.systemName;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const colorId = await resolveColorId(\n      config.colorId ?? null,\n      config.colorHex ?? null\n    );\n\n    let scopeIds = Array.isArray(config.scopeIds)\n      ? config.scopeIds.filter((value): value is number =>\n          Number.isFinite(value as number)\n        )\n      : [];\n\n    scopeIds = Array.from(new Set(scopeIds));\n\n    if (scopeIds.length === 0) {\n      scopeIds = availableScopeIds;\n    }\n\n    const aliases = (config.aliases ?? \"\").trim();\n\n    let created;\n    try {\n      created = await tx.status.create({\n        data: {\n          name,\n          systemName,\n          aliases: aliases || null,\n          colorId,\n          isEnabled: config.isEnabled ?? true,\n          isSuccess: config.isSuccess ?? false,\n          isFailure: config.isFailure ?? false,\n          isCompleted: config.isCompleted ?? false,\n        },\n      });\n    } catch (error) {\n      if (\n        error instanceof Prisma.PrismaClientKnownRequestError &&\n        error.code === \"P2002\"\n      ) {\n        const duplicate = await tx.status.findFirst({\n          where: {\n            OR: [{ name }, { systemName }],\n            isDeleted: false,\n          },\n        });\n\n        if (duplicate) {\n          config.action = \"map\";\n          config.mappedTo = duplicate.id;\n          config.name = duplicate.name;\n          config.systemName = duplicate.systemName;\n          summary.mapped += 1;\n          continue;\n        }\n      }\n\n      throw error;\n    }\n\n    if (scopeIds.length > 0) {\n      await tx.statusScopeAssignment.createMany({\n        data: scopeIds.map((scopeId) => ({\n          statusId: created.id,\n          scopeId,\n        })),\n        skipDuplicates: true,\n      });\n    }\n\n    config.action = \"map\";\n    config.mappedTo = created.id;\n    config.systemName = systemName;\n    config.colorId = colorId;\n    config.scopeIds = scopeIds;\n    config.aliases = aliases || null;\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\nasync function processImportMode(importJob: TestmoImportJob, jobId: string) {\n  if (FINAL_STATUSES.has(importJob.status)) {\n    return { status: importJob.status };\n  }\n\n  if (!importJob.configuration) {\n    throw new Error(\n      `Testmo import job ${jobId} cannot start background import without configuration`\n    );\n  }\n\n  const normalizedConfiguration = normalizeMappingConfiguration(\n    importJob.configuration\n  );\n\n  const datasetRecords = await prisma.testmoImportDataset.findMany({\n    where: { jobId },\n    select: {\n      name: true,\n      rowCount: true,\n    },\n  });\n\n  // Helper to load a dataset from staging on-demand\n  const loadDatasetFromStaging = async (\n    datasetName: string\n  ): Promise<any[]> => {\n    const mapStagedRow = (row: {\n      rowData: unknown;\n      fieldName?: string | null;\n      fieldValue?: string | null;\n      text1?: string | null;\n      text2?: string | null;\n      text3?: string | null;\n      text4?: string | null;\n    }) => {\n      const data =\n        typeof row.rowData === \"object\" && row.rowData !== null\n          ? JSON.parse(JSON.stringify(row.rowData))\n          : row.rowData;\n\n      if (data && typeof data === \"object\") {\n        const record = data as Record<string, unknown>;\n        if (\n          row.fieldValue !== null &&\n          row.fieldValue !== undefined &&\n          record.value === undefined\n        ) {\n          record.value = row.fieldValue;\n        }\n        if (\n          row.fieldName &&\n          (record.name === undefined || record.name === null)\n        ) {\n          record.name = row.fieldName;\n        }\n        const textKeys: Array<\n          [\"text1\" | \"text2\" | \"text3\" | \"text4\", string | null | undefined]\n        > = [\n          [\"text1\", row.text1],\n          [\"text2\", row.text2],\n          [\"text3\", row.text3],\n          [\"text4\", row.text4],\n        ];\n        for (const [key, value] of textKeys) {\n          if (\n            value !== null &&\n            value !== undefined &&\n            record[key] === undefined\n          ) {\n            record[key] = value;\n          }\n        }\n      }\n\n      return data;\n    };\n\n    try {\n      const stagedRows = await prisma.testmoImportStaging.findMany({\n        where: {\n          jobId,\n          datasetName,\n        },\n        orderBy: {\n          rowIndex: \"asc\",\n        },\n        select: {\n          rowData: true,\n          fieldName: true,\n          fieldValue: true,\n          text1: true,\n          text2: true,\n          text3: true,\n          text4: true,\n        },\n      });\n\n      return stagedRows.map(mapStagedRow);\n    } catch (error) {\n      // If we get a serialization error, try loading in smaller batches\n      logMessage(\n        context,\n        `Error loading ${datasetName} in single batch, trying batched approach: ${error}`\n      );\n\n      // Get total count\n      const totalCount = await prisma.testmoImportStaging.count({\n        where: {\n          jobId,\n          datasetName,\n        },\n      });\n\n      // Use smaller batch size for large text datasets (like automation_run_test_fields with ~990K records)\n      const batchSize = datasetName === \"automation_run_test_fields\" ? 50 : 100;\n      const allRows: any[] = [];\n\n      for (let offset = 0; offset < totalCount; offset += batchSize) {\n        try {\n          const stagedRows = await prisma.testmoImportStaging.findMany({\n            where: {\n              jobId,\n              datasetName,\n            },\n            orderBy: {\n              rowIndex: \"asc\",\n            },\n            skip: offset,\n            take: batchSize,\n            select: {\n              rowData: true,\n              fieldName: true,\n              fieldValue: true,\n              text1: true,\n              text2: true,\n              text3: true,\n              text4: true,\n            },\n          });\n\n          const rows = stagedRows.map(mapStagedRow);\n\n          allRows.push(...rows);\n          logMessage(\n            context,\n            `Loaded batch ${offset}-${offset + batchSize} of ${datasetName} (${allRows.length}/${totalCount})`\n          );\n        } catch (batchError) {\n          logMessage(\n            context,\n            `Error loading batch ${offset}-${offset + batchSize} of ${datasetName}, skipping: ${batchError}`\n          );\n          // Continue with next batch instead of failing entire import\n        }\n      }\n\n      return allRows;\n    }\n  };\n\n  // Small datasets that can be loaded into memory upfront (configuration data)\n  const SMALL_DATASETS = new Set([\n    \"users\",\n    \"roles\",\n    \"groups\",\n    \"user_groups\",\n    \"states\",\n    \"statuses\",\n    \"templates\",\n    \"template_fields\",\n    \"fields\",\n    \"field_values\",\n    \"configs\",\n    \"tags\",\n    \"milestone_types\",\n  ]);\n\n  // Load datasets into memory\n  const datasetRowsByName = new Map<string, any[]>();\n  const datasetRowCountByName = new Map<string, number>();\n\n  for (const record of datasetRecords) {\n    datasetRowCountByName.set(record.name, record.rowCount);\n\n    // Only load small datasets into memory upfront\n    if (SMALL_DATASETS.has(record.name)) {\n      const rows = await loadDatasetFromStaging(record.name);\n      datasetRowsByName.set(record.name, rows);\n    } else {\n      // For large datasets, set empty array as placeholder (will load on-demand)\n      datasetRowsByName.set(record.name, []);\n    }\n  }\n\n  const context = createInitialContext(jobId);\n  logMessage(context, \"Background import started.\", { jobId });\n\n  let currentEntity: string | null = null;\n\n  const entityTotals = computeEntityTotals(\n    normalizedConfiguration,\n    datasetRowsByName,\n    datasetRowCountByName\n  );\n  let plannedTotalCount = 0;\n  for (const [entity, total] of entityTotals) {\n    if (total > 0) {\n      initializeEntityProgress(context, entity, total);\n      plannedTotalCount += total;\n    }\n  }\n\n  const formatEntityLabel = (entity: string): string =>\n    entity\n      .replace(/([a-z0-9])([A-Z])/g, \"$1 $2\")\n      .replace(/^./, (char) => char.toUpperCase());\n\n  const formatSummaryStatus = (summary: EntitySummaryResult): string => {\n    const label = formatEntityLabel(summary.entity);\n    return `${label}: ${summary.total} processed \u2014 ${summary.created} created \u00B7 ${summary.mapped} mapped`;\n  };\n\n  const persistProgress = async (\n    entity: string | null,\n    statusMessage?: string\n  ): Promise<void> => {\n    currentEntity = entity;\n    try {\n      const now = Date.now();\n      const timeSinceLastUpdate = now - context.lastProgressUpdate;\n\n      // Calculate progress metrics\n      const metrics = calculateProgressMetrics(context, plannedTotalCount);\n\n      const data: Prisma.TestmoImportJobUpdateInput = {\n        currentEntity: entity,\n        processedCount: context.processedCount,\n        totalCount: plannedTotalCount,\n        activityLog: toInputJsonValue(context.activityLog),\n        entityProgress: toInputJsonValue(context.entityProgress),\n        estimatedTimeRemaining: metrics.estimatedTimeRemaining,\n        processingRate: metrics.processingRate,\n      };\n      if (statusMessage) {\n        data.statusMessage = statusMessage;\n      }\n      await prisma.testmoImportJob.update({\n        where: { id: jobId },\n        data,\n      });\n\n      context.lastProgressUpdate = now;\n    } catch (progressError) {\n      console.error(\n        `Failed to update Testmo import progress for job ${jobId}`,\n        progressError\n      );\n    }\n  };\n\n  const importStart = new Date();\n\n  await prisma.testmoImportJob.update({\n    where: { id: jobId },\n    data: {\n      status: \"RUNNING\",\n      phase: \"IMPORTING\",\n      statusMessage: \"Background import started\",\n      lastImportStartedAt: importStart,\n      processedCount: 0,\n      errorCount: 0,\n      skippedCount: 0,\n      totalCount: plannedTotalCount,\n      currentEntity: null,\n      estimatedTimeRemaining: null,\n      processingRate: null,\n      activityLog: toInputJsonValue(context.activityLog),\n      entityProgress: toInputJsonValue(context.entityProgress),\n    },\n  });\n\n  try {\n    const withTransaction = async <T>(\n      operation: (tx: Prisma.TransactionClient) => Promise<T>,\n      options?: { timeoutMs?: number }\n    ): Promise<T> => {\n      return prisma.$transaction(operation, {\n        timeout: options?.timeoutMs ?? IMPORT_TRANSACTION_TIMEOUT_MS,\n        maxWait: IMPORT_TRANSACTION_MAX_WAIT_MS,\n      });\n    };\n\n    logMessage(context, \"Processing workflow mappings\");\n    await persistProgress(\"workflows\", \"Processing workflow mappings\");\n    const workflowSummary = await withTransaction((tx) =>\n      importWorkflows(tx, normalizedConfiguration)\n    );\n    recordEntitySummary(context, workflowSummary);\n    await persistProgress(\"workflows\", formatSummaryStatus(workflowSummary));\n\n    logMessage(context, \"Processing status mappings\");\n    await persistProgress(\"statuses\", \"Processing status mappings\");\n    const statusSummary = await withTransaction((tx) =>\n      importStatuses(tx, normalizedConfiguration)\n    );\n    recordEntitySummary(context, statusSummary);\n    await persistProgress(\"statuses\", formatSummaryStatus(statusSummary));\n\n    logMessage(context, \"Processing group mappings\");\n    await persistProgress(\"groups\", \"Processing group mappings\");\n    const groupSummary = await withTransaction((tx) =>\n      importGroups(tx, normalizedConfiguration)\n    );\n    recordEntitySummary(context, groupSummary);\n    await persistProgress(\"groups\", formatSummaryStatus(groupSummary));\n\n    logMessage(context, \"Processing tag mappings\");\n    await persistProgress(\"tags\", \"Processing tag mappings\");\n    const tagSummary = await withTransaction((tx) =>\n      importTags(tx, normalizedConfiguration)\n    );\n    recordEntitySummary(context, tagSummary);\n    await persistProgress(\"tags\", formatSummaryStatus(tagSummary));\n\n    logMessage(context, \"Processing role mappings\");\n    await persistProgress(\"roles\", \"Processing role mappings\");\n    const roleSummary = await withTransaction((tx) =>\n      importRoles(tx, normalizedConfiguration)\n    );\n    recordEntitySummary(context, roleSummary);\n    await persistProgress(\"roles\", formatSummaryStatus(roleSummary));\n\n    logMessage(context, \"Processing milestone type mappings\");\n    await persistProgress(\n      \"milestoneTypes\",\n      \"Processing milestone type mappings\"\n    );\n    const milestoneSummary = await withTransaction((tx) =>\n      importMilestoneTypes(tx, normalizedConfiguration)\n    );\n    recordEntitySummary(context, milestoneSummary);\n    await persistProgress(\n      \"milestoneTypes\",\n      formatSummaryStatus(milestoneSummary)\n    );\n\n    logMessage(context, \"Processing configuration mappings\");\n    await persistProgress(\n      \"configurations\",\n      \"Processing configuration mappings\"\n    );\n    const configurationSummary = await withTransaction((tx) =>\n      importConfigurations(tx, normalizedConfiguration)\n    );\n    recordEntitySummary(context, configurationSummary);\n    await persistProgress(\n      \"configurations\",\n      formatSummaryStatus(configurationSummary)\n    );\n\n    logMessage(context, \"Processing template mappings\");\n    await persistProgress(\"templates\", \"Processing template mappings\");\n    const { summary: templateSummary, templateMap } = await withTransaction(\n      (tx) => importTemplates(tx, normalizedConfiguration)\n    );\n    recordEntitySummary(context, templateSummary);\n    await persistProgress(\"templates\", formatSummaryStatus(templateSummary));\n\n    // Initialize field maps - will be populated from template fields configuration\n    let caseFieldMap = new Map<string, number>();\n    let resultFieldMap = new Map<string, number>();\n\n    // Build initial maps from configuration (includes only mapped fields at this point)\n    const initialFieldMaps = buildTemplateFieldMaps(\n      normalizedConfiguration.templateFields ?? {}\n    );\n    caseFieldMap = initialFieldMaps.caseFields;\n    resultFieldMap = initialFieldMaps.resultFields;\n\n    logMessage(context, \"Processing template field mappings\");\n    await persistProgress(\n      \"templateFields\",\n      \"Processing template field mappings\"\n    );\n    const templateFieldSummary = await withTransaction((tx) =>\n      importTemplateFields(\n        tx,\n        normalizedConfiguration,\n        templateMap,\n        datasetRowsByName\n      )\n    );\n    recordEntitySummary(context, templateFieldSummary);\n    await persistProgress(\n      \"templateFields\",\n      formatSummaryStatus(templateFieldSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"template_fields\");\n\n    // Rebuild caseFieldMap and resultFieldMap after template fields are created\n    // This ensures newly created fields (action='create') are included\n    const updatedFieldMaps = buildTemplateFieldMaps(\n      normalizedConfiguration.templateFields ?? {}\n    );\n    caseFieldMap = updatedFieldMaps.caseFields;\n    resultFieldMap = updatedFieldMaps.resultFields;\n\n    logMessage(context, \"Processing user mappings\");\n    await persistProgress(\"users\", \"Processing user mappings\");\n    const userSummary = await withTransaction((tx) =>\n      importUsers(tx, normalizedConfiguration, importJob)\n    );\n    recordEntitySummary(context, userSummary);\n    await persistProgress(\"users\", formatSummaryStatus(userSummary));\n\n    logMessage(context, \"Processing user group assignments\");\n    await persistProgress(\"userGroups\", \"Processing user group assignments\");\n    const userGroupsSummary = await withTransaction((tx) =>\n      importUserGroups(tx, normalizedConfiguration, datasetRowsByName)\n    );\n    recordEntitySummary(context, userGroupsSummary);\n    await persistProgress(\"userGroups\", formatSummaryStatus(userGroupsSummary));\n\n    const workflowIdMap = buildNumberIdMap(\n      normalizedConfiguration.workflows ?? {}\n    );\n    const statusIdMap = buildNumberIdMap(\n      normalizedConfiguration.statuses ?? {}\n    );\n    const configurationIdMap = buildNumberIdMap(\n      normalizedConfiguration.configurations ?? {}\n    );\n    const milestoneTypeIdMap = buildNumberIdMap(\n      normalizedConfiguration.milestoneTypes ?? {}\n    );\n    const templateIdMap = buildNumberIdMap(\n      normalizedConfiguration.templates ?? {}\n    );\n    const userIdMap = buildStringIdMap(normalizedConfiguration.users ?? {});\n\n    logMessage(context, \"Processing project imports\");\n    await persistProgress(\"projects\", \"Processing project imports\");\n\n    // Load projects dataset on-demand\n    if (datasetRowsByName.get(\"projects\")?.length === 0) {\n      datasetRowsByName.set(\n        \"projects\",\n        await loadDatasetFromStaging(\"projects\")\n      );\n    }\n\n    const projectImport = await withTransaction((tx) =>\n      importProjects(\n        tx,\n        datasetRowsByName,\n        importJob,\n        userIdMap,\n        statusIdMap,\n        workflowIdMap,\n        milestoneTypeIdMap,\n        templateIdMap,\n        templateMap,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, projectImport.summary);\n    await persistProgress(\n      \"projects\",\n      formatSummaryStatus(projectImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"projects\");\n\n    // Import project_links\n    logMessage(context, \"Processing project links\");\n    await persistProgress(\"projectLinks\", \"Processing project links\");\n\n    if (datasetRowsByName.get(\"project_links\")?.length === 0) {\n      datasetRowsByName.set(\n        \"project_links\",\n        await loadDatasetFromStaging(\"project_links\")\n      );\n    }\n\n    const projectLinksImport = await withTransaction((tx) =>\n      importProjectLinks(\n        tx,\n        normalizedConfiguration,\n        datasetRowsByName,\n        projectImport.projectIdMap,\n        context\n      )\n    );\n    recordEntitySummary(context, projectLinksImport);\n    await persistProgress(\n      \"projectLinks\",\n      formatSummaryStatus(projectLinksImport)\n    );\n    releaseDatasetRows(datasetRowsByName, \"project_links\");\n\n    logMessage(context, \"Processing milestone imports\");\n    await persistProgress(\"milestones\", \"Processing milestone imports\");\n\n    // Load milestones dataset on-demand\n    if (datasetRowsByName.get(\"milestones\")?.length === 0) {\n      datasetRowsByName.set(\n        \"milestones\",\n        await loadDatasetFromStaging(\"milestones\")\n      );\n    }\n\n    const milestoneImport = await withTransaction((tx) =>\n      importMilestones(\n        tx,\n        datasetRowsByName,\n        projectImport.projectIdMap,\n        milestoneTypeIdMap,\n        userIdMap,\n        importJob,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, milestoneImport.summary);\n    await persistProgress(\n      \"milestones\",\n      formatSummaryStatus(milestoneImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"milestones\");\n\n    // Import milestone_links\n    logMessage(context, \"Processing milestone links\");\n    await persistProgress(\"milestoneLinks\", \"Processing milestone links\");\n\n    if (datasetRowsByName.get(\"milestone_links\")?.length === 0) {\n      datasetRowsByName.set(\n        \"milestone_links\",\n        await loadDatasetFromStaging(\"milestone_links\")\n      );\n    }\n\n    const milestoneLinksImport = await withTransaction((tx) =>\n      importMilestoneLinks(\n        tx,\n        normalizedConfiguration,\n        datasetRowsByName,\n        milestoneImport.milestoneIdMap,\n        context\n      )\n    );\n    recordEntitySummary(context, milestoneLinksImport);\n    await persistProgress(\n      \"milestoneLinks\",\n      formatSummaryStatus(milestoneLinksImport)\n    );\n    releaseDatasetRows(datasetRowsByName, \"milestone_links\");\n\n    // NOTE: milestone_automation_tags cannot be imported because Milestones model\n    // does not have a tags relation in the schema. This would need to be added first.\n\n    logMessage(context, \"Processing session imports\");\n    await persistProgress(\"sessions\", \"Processing session imports\");\n\n    // Load sessions dataset on-demand\n    if (datasetRowsByName.get(\"sessions\")?.length === 0) {\n      datasetRowsByName.set(\n        \"sessions\",\n        await loadDatasetFromStaging(\"sessions\")\n      );\n    }\n\n    const sessionImport = await withTransaction((tx) =>\n      importSessions(\n        tx,\n        datasetRowsByName,\n        projectImport.projectIdMap,\n        milestoneImport.milestoneIdMap,\n        configurationIdMap,\n        workflowIdMap,\n        userIdMap,\n        templateIdMap,\n        importJob,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, sessionImport.summary);\n    await persistProgress(\n      \"sessions\",\n      formatSummaryStatus(sessionImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"sessions\");\n\n    logMessage(context, \"Processing session results imports\");\n    await persistProgress(\n      \"sessionResults\",\n      \"Processing session results imports\"\n    );\n\n    // Load session_results dataset on-demand\n    if (datasetRowsByName.get(\"session_results\")?.length === 0) {\n      datasetRowsByName.set(\n        \"session_results\",\n        await loadDatasetFromStaging(\"session_results\")\n      );\n    }\n\n    const sessionResultsImport = await withTransaction((tx) =>\n      importSessionResults(\n        tx,\n        datasetRowsByName,\n        sessionImport.sessionIdMap,\n        statusIdMap,\n        userIdMap,\n        importJob,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, sessionResultsImport.summary);\n    await persistProgress(\n      \"sessionResults\",\n      formatSummaryStatus(sessionResultsImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"session_results\");\n\n    logMessage(context, \"Processing session tag assignments\");\n    await persistProgress(\"sessionTags\", \"Processing session tag assignments\");\n\n    // Load session_tags dataset on-demand\n    if (datasetRowsByName.get(\"session_tags\")?.length === 0) {\n      datasetRowsByName.set(\n        \"session_tags\",\n        await loadDatasetFromStaging(\"session_tags\")\n      );\n    }\n\n    const sessionTagsSummary = await withTransaction((tx) =>\n      importSessionTags(\n        tx,\n        normalizedConfiguration,\n        datasetRowsByName,\n        sessionImport.sessionIdMap\n      )\n    );\n    recordEntitySummary(context, sessionTagsSummary);\n    await persistProgress(\n      \"sessionTags\",\n      formatSummaryStatus(sessionTagsSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"session_tags\");\n\n    // Load field_values dataset if not already loaded (needed for session values and case values)\n    if (datasetRowsByName.get(\"field_values\")?.length === 0) {\n      datasetRowsByName.set(\n        \"field_values\",\n        await loadDatasetFromStaging(\"field_values\")\n      );\n    }\n\n    // Build mapping from Testmo field_value IDs to field and name\n    const testmoFieldValueMap = new Map<\n      number,\n      { fieldId: number; name: string }\n    >();\n    const fieldValueRows = datasetRowsByName.get(\"field_values\") ?? [];\n    for (const row of fieldValueRows) {\n      const record = row as Record<string, unknown>;\n      const id = toNumberValue(record.id);\n      const fieldId = toNumberValue(record.field_id);\n      const name = toStringValue(record.name);\n      if (id !== null && fieldId !== null && name) {\n        testmoFieldValueMap.set(id, { fieldId, name });\n      }\n    }\n\n    logMessage(context, \"Processing repository imports\");\n    await persistProgress(\"repositories\", \"Processing repository imports\");\n\n    // Load repositories dataset on-demand\n    if (datasetRowsByName.get(\"repositories\")?.length === 0) {\n      datasetRowsByName.set(\n        \"repositories\",\n        await loadDatasetFromStaging(\"repositories\")\n      );\n    }\n\n    const repositoryImport = await withTransaction((tx) =>\n      importRepositories(\n        tx,\n        datasetRowsByName,\n        projectImport.projectIdMap,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, repositoryImport.summary);\n    await persistProgress(\n      \"repositories\",\n      formatSummaryStatus(repositoryImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"repositories\");\n\n    logMessage(context, \"Processing repository folders\");\n    await persistProgress(\"repositoryFolders\", \"Processing repository folders\");\n\n    // Load repository_folders dataset on-demand\n    if (datasetRowsByName.get(\"repository_folders\")?.length === 0) {\n      datasetRowsByName.set(\n        \"repository_folders\",\n        await loadDatasetFromStaging(\"repository_folders\")\n      );\n    }\n    if (repositoryImport.masterRepositoryIds.size > 0) {\n      const filtered = (datasetRowsByName.get(\"repository_folders\") ?? []).filter(\n        (row: any) => {\n          const repoId = toNumberValue(row.repo_id);\n          return repoId === null\n            ? true\n            : repositoryImport.masterRepositoryIds.has(repoId);\n        }\n      );\n      datasetRowsByName.set(\"repository_folders\", filtered);\n    }\n\n    const folderImport = await importRepositoryFolders(\n      datasetRowsByName,\n      projectImport.projectIdMap,\n      repositoryImport.repositoryIdMap,\n      repositoryImport.canonicalRepoIdByProject,\n      importJob,\n      userIdMap,\n      context,\n      persistProgress\n    );\n    recordEntitySummary(context, folderImport.summary);\n    await persistProgress(\n      \"repositoryFolders\",\n      formatSummaryStatus(folderImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"repository_folders\");\n\n    logMessage(context, \"Processing repository cases\");\n    await persistProgress(\"repositoryCases\", \"Processing repository cases\");\n\n    // Load repository_cases and related datasets on-demand\n    if (datasetRowsByName.get(\"repository_cases\")?.length === 0) {\n      datasetRowsByName.set(\n        \"repository_cases\",\n        await loadDatasetFromStaging(\"repository_cases\")\n      );\n    }\n    if (repositoryImport.masterRepositoryIds.size > 0) {\n      const filteredCases =\n        datasetRowsByName\n          .get(\"repository_cases\")\n          ?.filter((row: any) => {\n            const repoId = toNumberValue(row.repo_id);\n            return repoId === null\n              ? true\n              : repositoryImport.masterRepositoryIds.has(repoId);\n          }) ?? [];\n      datasetRowsByName.set(\"repository_cases\", filteredCases);\n    }\n    if (datasetRowsByName.get(\"repository_case_steps\")?.length === 0) {\n      datasetRowsByName.set(\n        \"repository_case_steps\",\n        await loadDatasetFromStaging(\"repository_case_steps\")\n      );\n    }\n    if (repositoryImport.masterRepositoryIds.size > 0) {\n      const filteredSteps =\n        datasetRowsByName\n          .get(\"repository_case_steps\")\n          ?.filter((row: any) => {\n            const repoId = toNumberValue(row.repo_id);\n            return repoId === null\n              ? true\n              : repositoryImport.masterRepositoryIds.has(repoId);\n          }) ?? [];\n      datasetRowsByName.set(\"repository_case_steps\", filteredSteps);\n    }\n\n    // Load repository_case_values dataset if not already loaded\n    // This dataset contains multi-select field values (one row per selected value)\n    if (\n      !datasetRowsByName.has(\"repository_case_values\") ||\n      datasetRowsByName.get(\"repository_case_values\")?.length === 0\n    ) {\n      const caseValuesData = await loadDatasetFromStaging(\n        \"repository_case_values\"\n      );\n      datasetRowsByName.set(\"repository_case_values\", caseValuesData);\n    }\n    if (repositoryImport.masterRepositoryIds.size > 0) {\n      const filteredCaseValues =\n        datasetRowsByName\n          .get(\"repository_case_values\")\n          ?.filter((row: any) => {\n            const repoId = toNumberValue(row.repo_id);\n            return repoId === null\n              ? true\n              : repositoryImport.masterRepositoryIds.has(repoId);\n          }) ?? [];\n      datasetRowsByName.set(\"repository_case_values\", filteredCaseValues);\n    }\n\n    const caseImport = await importRepositoryCases(\n      datasetRowsByName,\n      projectImport.projectIdMap,\n      repositoryImport.repositoryIdMap,\n      repositoryImport.canonicalRepoIdByProject,\n      folderImport.folderIdMap,\n      folderImport.repositoryRootFolderMap,\n      templateIdMap,\n      templateMap,\n      workflowIdMap,\n      userIdMap,\n      caseFieldMap,\n      testmoFieldValueMap,\n      normalizedConfiguration,\n      importJob,\n      context,\n      persistProgress\n    );\n    recordEntitySummary(context, caseImport.summary);\n    await persistProgress(\n      \"repositoryCases\",\n      formatSummaryStatus(caseImport.summary)\n    );\n    releaseDatasetRows(\n      datasetRowsByName,\n      \"repository_cases\",\n      \"repository_case_steps\",\n      \"templates\"\n    );\n\n    logMessage(context, \"Processing repository case tag assignments\");\n    await persistProgress(\n      \"repositoryCaseTags\",\n      \"Processing repository case tag assignments\"\n    );\n\n    // Load repository_case_tags dataset on-demand\n    if (datasetRowsByName.get(\"repository_case_tags\")?.length === 0) {\n      datasetRowsByName.set(\n        \"repository_case_tags\",\n        await loadDatasetFromStaging(\"repository_case_tags\")\n      );\n    }\n\n    const repositoryCaseTagsSummary = await withTransaction((tx) =>\n      importRepositoryCaseTags(\n        tx,\n        normalizedConfiguration,\n        datasetRowsByName,\n        caseImport.caseIdMap\n      )\n    );\n    recordEntitySummary(context, repositoryCaseTagsSummary);\n    await persistProgress(\n      \"repositoryCaseTags\",\n      formatSummaryStatus(repositoryCaseTagsSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"repository_case_tags\");\n\n    // ===== AUTOMATION IMPORTS =====\n    logMessage(context, \"Processing automation case imports\");\n    await persistProgress(\n      \"automationCases\",\n      \"Processing automation case imports\"\n    );\n\n    // Load automation_cases dataset on-demand\n    if (datasetRowsByName.get(\"automation_cases\")?.length === 0) {\n      datasetRowsByName.set(\n        \"automation_cases\",\n        await loadDatasetFromStaging(\"automation_cases\")\n      );\n    }\n\n    const automationCaseImport = await importAutomationCases(\n      prisma,\n      normalizedConfiguration,\n      datasetRowsByName,\n      projectImport.projectIdMap,\n      repositoryImport.repositoryIdMap,\n      folderImport.folderIdMap,\n      templateIdMap,\n      projectImport.defaultTemplateIdByProject,\n      workflowIdMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: AUTOMATION_CASE_CHUNK_SIZE,\n        transactionTimeoutMs: AUTOMATION_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, automationCaseImport.summary);\n    await persistProgress(\n      \"automationCases\",\n      formatSummaryStatus(automationCaseImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"automation_cases\");\n\n    const automationCaseProjectMap =\n      automationCaseImport.automationCaseProjectMap;\n\n    logMessage(context, \"Processing automation run imports\");\n    await persistProgress(\n      \"automationRuns\",\n      \"Processing automation run imports\"\n    );\n\n    // Load automation_runs dataset on-demand\n    if (datasetRowsByName.get(\"automation_runs\")?.length === 0) {\n      datasetRowsByName.set(\n        \"automation_runs\",\n        await loadDatasetFromStaging(\"automation_runs\")\n      );\n    }\n\n    const automationRunImport = await importAutomationRuns(\n      prisma,\n      normalizedConfiguration,\n      datasetRowsByName,\n      projectImport.projectIdMap,\n      configurationIdMap,\n      milestoneImport.milestoneIdMap,\n      workflowIdMap,\n      userIdMap,\n      importJob.createdById,\n      context,\n      persistProgress,\n      {\n        chunkSize: AUTOMATION_RUN_CHUNK_SIZE,\n        transactionTimeoutMs: AUTOMATION_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, automationRunImport.summary);\n    await persistProgress(\n      \"automationRuns\",\n      formatSummaryStatus(automationRunImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"automation_runs\");\n\n    logMessage(context, \"Processing automation run test imports\");\n    await persistProgress(\n      \"automationRunTests\",\n      \"Processing automation run test imports\"\n    );\n\n    // Load automation_run_tests dataset on-demand\n    if (datasetRowsByName.get(\"automation_run_tests\")?.length === 0) {\n      datasetRowsByName.set(\n        \"automation_run_tests\",\n        await loadDatasetFromStaging(\"automation_run_tests\")\n      );\n    }\n\n    const automationRunTestImport = await importAutomationRunTests(\n      prisma,\n      normalizedConfiguration,\n      datasetRowsByName,\n      projectImport.projectIdMap,\n      automationRunImport.testRunIdMap,\n      automationRunImport.testSuiteIdMap,\n      automationRunImport.testRunTimestampMap,\n      automationRunImport.testRunProjectIdMap,\n      automationRunImport.testRunTestmoProjectIdMap,\n      automationCaseProjectMap,\n      statusIdMap,\n      userIdMap,\n      importJob.createdById,\n      context,\n      persistProgress,\n      {\n        chunkSize: AUTOMATION_RUN_TEST_CHUNK_SIZE,\n        transactionTimeoutMs: AUTOMATION_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    const automationRunTestSummary = automationRunTestImport.summary;\n    const automationRunTestCaseMap = automationRunTestImport.testRunCaseIdMap;\n    const automationRunJunitResultMap =\n      automationRunTestImport.junitResultIdMap;\n    recordEntitySummary(context, automationRunTestSummary);\n    await persistProgress(\n      \"automationRunTests\",\n      formatSummaryStatus(automationRunTestSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"automation_run_tests\");\n\n    // Import automation_run_fields\n    logMessage(context, \"Processing automation run fields\");\n    await persistProgress(\n      \"automationRunFields\",\n      \"Processing automation run fields\"\n    );\n\n    if (datasetRowsByName.get(\"automation_run_fields\")?.length === 0) {\n      datasetRowsByName.set(\n        \"automation_run_fields\",\n        await loadDatasetFromStaging(\"automation_run_fields\")\n      );\n    }\n\n    const automationRunFieldsImport = await importAutomationRunFields(\n      prisma,\n      normalizedConfiguration,\n      datasetRowsByName,\n      projectImport.projectIdMap,\n      automationRunImport.testRunIdMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: AUTOMATION_RUN_FIELD_CHUNK_SIZE,\n        transactionTimeoutMs: AUTOMATION_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, automationRunFieldsImport);\n    await persistProgress(\n      \"automationRunFields\",\n      formatSummaryStatus(automationRunFieldsImport)\n    );\n    releaseDatasetRows(datasetRowsByName, \"automation_run_fields\");\n\n    // Import automation_run_links\n    logMessage(context, \"Processing automation run links\");\n    await persistProgress(\n      \"automationRunLinks\",\n      \"Processing automation run links\"\n    );\n\n    if (datasetRowsByName.get(\"automation_run_links\")?.length === 0) {\n      datasetRowsByName.set(\n        \"automation_run_links\",\n        await loadDatasetFromStaging(\"automation_run_links\")\n      );\n    }\n\n    const automationRunLinksImport = await importAutomationRunLinks(\n      prisma,\n      normalizedConfiguration,\n      datasetRowsByName,\n      projectImport.projectIdMap,\n      automationRunImport.testRunIdMap,\n      userIdMap,\n      importJob.createdById,\n      context,\n      persistProgress,\n      {\n        chunkSize: AUTOMATION_RUN_LINK_CHUNK_SIZE,\n        transactionTimeoutMs: AUTOMATION_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, automationRunLinksImport);\n    await persistProgress(\n      \"automationRunLinks\",\n      formatSummaryStatus(automationRunLinksImport)\n    );\n    releaseDatasetRows(datasetRowsByName, \"automation_run_links\");\n\n    // Import automation_run_test_fields\n    logMessage(context, \"Processing automation run test fields\");\n    await persistProgress(\n      \"automationRunTestFields\",\n      \"Processing automation run test fields\"\n    );\n\n    const automationRunTestFieldsImport = await importAutomationRunTestFields(\n      prisma,\n      normalizedConfiguration,\n      datasetRowsByName,\n      projectImport.projectIdMap,\n      automationRunImport.testRunIdMap,\n      automationRunTestCaseMap,\n      automationRunJunitResultMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: AUTOMATION_RUN_TEST_FIELD_CHUNK_SIZE,\n        transactionTimeoutMs: AUTOMATION_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, automationRunTestFieldsImport);\n    await persistProgress(\n      \"automationRunTestFields\",\n      formatSummaryStatus(automationRunTestFieldsImport)\n    );\n    releaseDatasetRows(datasetRowsByName, \"automation_run_test_fields\");\n\n    // Import automation_run_tags\n    logMessage(context, \"Processing automation run tags\");\n    await persistProgress(\n      \"automationRunTags\",\n      \"Processing automation run tags\"\n    );\n\n    if (datasetRowsByName.get(\"automation_run_tags\")?.length === 0) {\n      datasetRowsByName.set(\n        \"automation_run_tags\",\n        await loadDatasetFromStaging(\"automation_run_tags\")\n      );\n    }\n\n    const automationRunTagsImport = await importAutomationRunTags(\n      prisma,\n      normalizedConfiguration,\n      datasetRowsByName,\n      automationRunImport.testRunIdMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: AUTOMATION_RUN_TAG_CHUNK_SIZE,\n        transactionTimeoutMs: AUTOMATION_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, automationRunTagsImport);\n    await persistProgress(\n      \"automationRunTags\",\n      formatSummaryStatus(automationRunTagsImport)\n    );\n    releaseDatasetRows(datasetRowsByName, \"automation_run_tags\");\n\n    // ===== END AUTOMATION IMPORTS =====\n\n    logMessage(context, \"Processing session values imports\");\n    await persistProgress(\"sessionValues\", \"Processing session values imports\");\n\n    // Load session_values dataset on-demand\n    if (datasetRowsByName.get(\"session_values\")?.length === 0) {\n      datasetRowsByName.set(\n        \"session_values\",\n        await loadDatasetFromStaging(\"session_values\")\n      );\n    }\n\n    const sessionValuesImport = await withTransaction((tx) =>\n      importSessionValues(\n        tx,\n        datasetRowsByName,\n        sessionImport.sessionIdMap,\n        testmoFieldValueMap,\n        normalizedConfiguration,\n        caseImport.caseFieldMap,\n        caseImport.caseFieldMetadataById,\n        importJob,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, sessionValuesImport.summary);\n    await persistProgress(\n      \"sessionValues\",\n      formatSummaryStatus(sessionValuesImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"session_values\");\n\n    logMessage(context, \"Processing test run imports\");\n    await persistProgress(\"testRuns\", \"Processing test run imports\");\n\n    // Load runs dataset on-demand\n    if (datasetRowsByName.get(\"runs\")?.length === 0) {\n      datasetRowsByName.set(\"runs\", await loadDatasetFromStaging(\"runs\"));\n    }\n\n    const testRunImport = await withTransaction((tx) =>\n      importTestRuns(\n        tx,\n        datasetRowsByName,\n        projectImport.projectIdMap,\n        repositoryImport.canonicalRepoIdByProject,\n        configurationIdMap,\n        milestoneImport.milestoneIdMap,\n        workflowIdMap,\n        userIdMap,\n        importJob,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, testRunImport.summary);\n    await persistProgress(\n      \"testRuns\",\n      formatSummaryStatus(testRunImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"runs\");\n\n    // Import run_links\n    logMessage(context, \"Processing run links\");\n    await persistProgress(\"runLinks\", \"Processing run links\");\n\n    if (datasetRowsByName.get(\"run_links\")?.length === 0) {\n      datasetRowsByName.set(\n        \"run_links\",\n        await loadDatasetFromStaging(\"run_links\")\n      );\n    }\n\n    const runLinksImport = await withTransaction((tx) =>\n      importRunLinks(\n        tx,\n        normalizedConfiguration,\n        datasetRowsByName,\n        testRunImport.testRunIdMap,\n        context\n      )\n    );\n    recordEntitySummary(context, runLinksImport);\n    await persistProgress(\"runLinks\", formatSummaryStatus(runLinksImport));\n    releaseDatasetRows(datasetRowsByName, \"run_links\");\n\n    logMessage(context, \"Processing test run case imports\");\n    await persistProgress(\"testRunCases\", \"Processing test run case imports\");\n\n    // Load run_tests dataset on-demand\n    if (datasetRowsByName.get(\"run_tests\")?.length === 0) {\n      datasetRowsByName.set(\n        \"run_tests\",\n        await loadDatasetFromStaging(\"run_tests\")\n      );\n    }\n\n    const testRunCaseImport = await importTestRunCases(\n      datasetRowsByName,\n      testRunImport.testRunIdMap,\n      caseImport.caseIdMap,\n      caseImport.caseMetaMap,\n      userIdMap,\n      statusIdMap,\n      context,\n      persistProgress\n    );\n    recordEntitySummary(context, testRunCaseImport.summary);\n    await persistProgress(\n      \"testRunCases\",\n      formatSummaryStatus(testRunCaseImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"run_tests\");\n\n    logMessage(context, \"Processing run tag assignments\");\n    await persistProgress(\"runTags\", \"Processing run tag assignments\");\n\n    // Load run_tags dataset on-demand\n    if (datasetRowsByName.get(\"run_tags\")?.length === 0) {\n      datasetRowsByName.set(\n        \"run_tags\",\n        await loadDatasetFromStaging(\"run_tags\")\n      );\n    }\n\n    const runTagsSummary = await withTransaction((tx) =>\n      importRunTags(\n        tx,\n        normalizedConfiguration,\n        datasetRowsByName,\n        testRunImport.testRunIdMap\n      )\n    );\n    recordEntitySummary(context, runTagsSummary);\n    await persistProgress(\"runTags\", formatSummaryStatus(runTagsSummary));\n    releaseDatasetRows(datasetRowsByName, \"run_tags\");\n\n    logMessage(context, \"Processing test run result imports\");\n    await persistProgress(\n      \"testRunResults\",\n      \"Processing test run result imports\"\n    );\n\n    // Load run_results dataset on-demand\n    if (datasetRowsByName.get(\"run_results\")?.length === 0) {\n      datasetRowsByName.set(\n        \"run_results\",\n        await loadDatasetFromStaging(\"run_results\")\n      );\n    }\n\n    // Merge manual and automation test run case maps\n    const mergedTestRunCaseIdMap = new Map(testRunCaseImport.testRunCaseIdMap);\n    for (const [testmoId, testRunCaseId] of automationRunTestCaseMap) {\n      mergedTestRunCaseIdMap.set(testmoId, testRunCaseId);\n    }\n\n    const testRunResultImport = await importTestRunResults(\n      datasetRowsByName,\n      testRunImport.testRunIdMap,\n      mergedTestRunCaseIdMap,\n      statusIdMap,\n      userIdMap,\n      resultFieldMap,\n      importJob,\n      context,\n      persistProgress\n    );\n    recordEntitySummary(context, testRunResultImport.summary);\n    await persistProgress(\n      \"testRunResults\",\n      formatSummaryStatus(testRunResultImport.summary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"run_results\");\n\n    logMessage(context, \"Processing test run step results\");\n    await persistProgress(\n      \"testRunStepResults\",\n      \"Processing test run step results\"\n    );\n\n    const stepResultsSummary = await importTestRunStepResults(\n      datasetRowsByName,\n      testRunResultImport.testRunResultIdMap,\n      mergedTestRunCaseIdMap,\n      statusIdMap,\n      caseImport.caseIdMap,\n      importJob,\n      context,\n      persistProgress\n    );\n    recordEntitySummary(context, stepResultsSummary);\n    await persistProgress(\n      \"testRunStepResults\",\n      formatSummaryStatus(stepResultsSummary)\n    );\n\n    // Import issue targets (Integration records)\n    logMessage(context, \"Processing issue targets\");\n    await persistProgress(\"issueTargets\", \"Processing issue targets\");\n\n    const issueTargetsImport = await withTransaction((tx) =>\n      importIssueTargets(\n        tx,\n        normalizedConfiguration,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, issueTargetsImport.summary);\n    await persistProgress(\n      \"issueTargets\",\n      formatSummaryStatus(issueTargetsImport.summary)\n    );\n    // Note: We don't need to load/release issue_targets dataset since we use configuration\n\n    // Import issues\n    logMessage(context, \"Processing issues\");\n    await persistProgress(\"issues\", \"Processing issues\");\n\n    if (datasetRowsByName.get(\"issues\")?.length === 0) {\n      datasetRowsByName.set(\n        \"issues\",\n        await loadDatasetFromStaging(\"issues\")\n      );\n    }\n\n    const issuesImport = await withTransaction((tx) =>\n      importIssues(\n        tx,\n        datasetRowsByName,\n        issueTargetsImport.integrationIdMap,\n        projectImport.projectIdMap,\n        importJob.createdById,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, issuesImport.summary);\n    await persistProgress(\"issues\", formatSummaryStatus(issuesImport.summary));\n\n    // Create ProjectIntegration records\n    logMessage(context, \"Creating project-integration connections\");\n    await persistProgress(\n      \"projectIntegrations\",\n      \"Creating project-integration connections\"\n    );\n\n    const projectIntegrationsSummary = await withTransaction((tx) =>\n      createProjectIntegrations(\n        tx,\n        datasetRowsByName,\n        projectImport.projectIdMap,\n        issueTargetsImport.integrationIdMap,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, projectIntegrationsSummary);\n    await persistProgress(\n      \"projectIntegrations\",\n      formatSummaryStatus(projectIntegrationsSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"issues\");\n\n    // Import milestone_issues relationships\n    // NOTE: Skipped - Milestones model does not have an issues relation\n    // To enable: Add 'issues Issue[]' to Milestones model in schema.zmodel\n    logMessage(\n      context,\n      \"Skipping milestone issue relationships (schema limitation)\"\n    );\n    await persistProgress(\n      \"milestoneIssues\",\n      \"Skipped (schema does not support milestone-issue relationships)\"\n    );\n\n    if (datasetRowsByName.get(\"milestone_issues\")?.length === 0) {\n      datasetRowsByName.set(\n        \"milestone_issues\",\n        await loadDatasetFromStaging(\"milestone_issues\")\n      );\n    }\n\n    const milestoneIssuesSummary = await withTransaction((tx) =>\n      importMilestoneIssues(\n        tx,\n        datasetRowsByName,\n        milestoneImport.milestoneIdMap,\n        issuesImport.issueIdMap,\n        context,\n        persistProgress\n      )\n    );\n    recordEntitySummary(context, milestoneIssuesSummary);\n    await persistProgress(\n      \"milestoneIssues\",\n      formatSummaryStatus(milestoneIssuesSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"milestone_issues\");\n\n    // Import repository_case_issues relationships\n    logMessage(context, \"Processing repository case issue relationships\");\n    await persistProgress(\n      \"repositoryCaseIssues\",\n      \"Processing repository case issue relationships\"\n    );\n\n    if (datasetRowsByName.get(\"repository_case_issues\")?.length === 0) {\n      datasetRowsByName.set(\n        \"repository_case_issues\",\n        await loadDatasetFromStaging(\"repository_case_issues\")\n      );\n    }\n\n    const repositoryCaseIssuesSummary = await importRepositoryCaseIssues(\n      prisma,\n      datasetRowsByName,\n      caseImport.caseIdMap,\n      issuesImport.issueIdMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: ISSUE_RELATIONSHIP_CHUNK_SIZE,\n        transactionTimeoutMs: IMPORT_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, repositoryCaseIssuesSummary);\n    await persistProgress(\n      \"repositoryCaseIssues\",\n      formatSummaryStatus(repositoryCaseIssuesSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"repository_case_issues\");\n\n    // Import run_issues relationships\n    logMessage(context, \"Processing test run issue relationships\");\n    await persistProgress(\n      \"runIssues\",\n      \"Processing test run issue relationships\"\n    );\n\n    if (datasetRowsByName.get(\"run_issues\")?.length === 0) {\n      datasetRowsByName.set(\n        \"run_issues\",\n        await loadDatasetFromStaging(\"run_issues\")\n      );\n    }\n\n    const runIssuesSummary = await importRunIssues(\n      prisma,\n      datasetRowsByName,\n      testRunImport.testRunIdMap,\n      issuesImport.issueIdMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: ISSUE_RELATIONSHIP_CHUNK_SIZE,\n        transactionTimeoutMs: IMPORT_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, runIssuesSummary);\n    await persistProgress(\"runIssues\", formatSummaryStatus(runIssuesSummary));\n    releaseDatasetRows(datasetRowsByName, \"run_issues\");\n\n    // Import run_result_issues relationships\n    logMessage(context, \"Processing test run result issue relationships\");\n    await persistProgress(\n      \"runResultIssues\",\n      \"Processing test run result issue relationships\"\n    );\n\n    if (datasetRowsByName.get(\"run_result_issues\")?.length === 0) {\n      datasetRowsByName.set(\n        \"run_result_issues\",\n        await loadDatasetFromStaging(\"run_result_issues\")\n      );\n    }\n\n    const runResultIssuesSummary = await importRunResultIssues(\n      prisma,\n      datasetRowsByName,\n      testRunResultImport.testRunResultIdMap,\n      issuesImport.issueIdMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: ISSUE_RELATIONSHIP_CHUNK_SIZE,\n        transactionTimeoutMs: IMPORT_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, runResultIssuesSummary);\n    await persistProgress(\n      \"runResultIssues\",\n      formatSummaryStatus(runResultIssuesSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"run_result_issues\");\n\n    // Import session_issues relationships\n    logMessage(context, \"Processing session issue relationships\");\n    await persistProgress(\n      \"sessionIssues\",\n      \"Processing session issue relationships\"\n    );\n\n    if (datasetRowsByName.get(\"session_issues\")?.length === 0) {\n      datasetRowsByName.set(\n        \"session_issues\",\n        await loadDatasetFromStaging(\"session_issues\")\n      );\n    }\n\n    const sessionIssuesSummary = await importSessionIssues(\n      prisma,\n      datasetRowsByName,\n      sessionImport.sessionIdMap,\n      issuesImport.issueIdMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: ISSUE_RELATIONSHIP_CHUNK_SIZE,\n        transactionTimeoutMs: IMPORT_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, sessionIssuesSummary);\n    await persistProgress(\n      \"sessionIssues\",\n      formatSummaryStatus(sessionIssuesSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"session_issues\");\n\n    // Import session_result_issues relationships\n    logMessage(context, \"Processing session result issue relationships\");\n    await persistProgress(\n      \"sessionResultIssues\",\n      \"Processing session result issue relationships\"\n    );\n\n    if (datasetRowsByName.get(\"session_result_issues\")?.length === 0) {\n      datasetRowsByName.set(\n        \"session_result_issues\",\n        await loadDatasetFromStaging(\"session_result_issues\")\n      );\n    }\n\n    const sessionResultIssuesSummary = await importSessionResultIssues(\n      prisma,\n      datasetRowsByName,\n      sessionResultsImport.sessionResultIdMap,\n      issuesImport.issueIdMap,\n      context,\n      persistProgress,\n      {\n        chunkSize: ISSUE_RELATIONSHIP_CHUNK_SIZE,\n        transactionTimeoutMs: IMPORT_TRANSACTION_TIMEOUT_MS,\n      }\n    );\n    recordEntitySummary(context, sessionResultIssuesSummary);\n    await persistProgress(\n      \"sessionResultIssues\",\n      formatSummaryStatus(sessionResultIssuesSummary)\n    );\n    releaseDatasetRows(datasetRowsByName, \"session_result_issues\");\n\n    logMessage(context, \"Finalizing import configuration\");\n    await persistProgress(null, \"Finalizing import configuration\");\n    const serializedConfiguration = serializeMappingConfiguration(\n      normalizedConfiguration\n    );\n\n    const totalTimeMs = Date.now() - context.startTime;\n    const totalTimeSeconds = Math.floor(totalTimeMs / 1000);\n    const minutes = Math.floor(totalTimeSeconds / 60);\n    const seconds = totalTimeSeconds % 60;\n    const totalTimeFormatted =\n      minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;\n\n    logMessage(context, \"Import completed successfully.\", {\n      processedEntities: context.processedCount,\n      totalTime: totalTimeFormatted,\n      totalTimeMs,\n    });\n    await persistProgress(null, \"Import completed successfully.\");\n\n    const updatedJob = await prisma.testmoImportJob.update({\n      where: { id: jobId },\n      data: {\n        status: \"COMPLETED\",\n        phase: null,\n        statusMessage: \"Import completed successfully.\",\n        completedAt: new Date(),\n        processedCount: context.processedCount,\n        totalCount: context.processedCount,\n        errorCount: 0,\n        skippedCount: 0,\n        currentEntity: null,\n        estimatedTimeRemaining: null,\n        processingRate: null,\n        durationMs: totalTimeMs,\n        activityLog: toInputJsonValue(context.activityLog),\n        entityProgress: toInputJsonValue(context.entityProgress),\n        configuration: toInputJsonValue(serializedConfiguration),\n      },\n    });\n\n    // Trigger full Elasticsearch reindex after successful import\n    // This ensures all imported data is searchable\n    const elasticsearchReindexQueue = getElasticsearchReindexQueue();\n    if (elasticsearchReindexQueue) {\n      try {\n        logMessage(\n          context,\n          \"Queueing Elasticsearch reindex after successful import\"\n        );\n        const reindexJobData: ReindexJobData = {\n          entityType: \"all\",\n          userId: importJob.createdById,\n        };\n        await elasticsearchReindexQueue.add(\n          `reindex-after-import-${jobId}`,\n          reindexJobData\n        );\n        console.log(\n          `Queued Elasticsearch reindex job after import ${jobId} completion`\n        );\n      } catch (reindexError) {\n        // Don't fail the import if reindex queueing fails\n        console.error(\n          `Failed to queue Elasticsearch reindex after import ${jobId}:`,\n          reindexError\n        );\n        logMessage(\n          context,\n          \"Warning: Failed to queue Elasticsearch reindex. Search results may not include imported data until manual reindex is performed.\",\n          {\n            error:\n              reindexError instanceof Error\n                ? reindexError.message\n                : String(reindexError),\n          }\n        );\n      }\n    } else {\n      console.warn(\n        `Elasticsearch reindex queue not available after import ${jobId}. Search indexes will need to be updated manually.`\n      );\n    }\n\n    return { status: updatedJob.status };\n  } catch (error) {\n    console.error(`Testmo import job ${jobId} failed during import`, error);\n\n    const errorDetails: Record<string, unknown> = {\n      message: error instanceof Error ? error.message : String(error),\n    };\n    logMessage(context, \"Import failed\", errorDetails);\n\n    const serializedConfiguration = serializeMappingConfiguration(\n      normalizedConfiguration\n    );\n\n    await prisma.testmoImportJob.update({\n      where: { id: jobId },\n      data: {\n        status: \"FAILED\",\n        phase: null,\n        statusMessage: \"Import failed\",\n        error: error instanceof Error ? error.message : String(error),\n        completedAt: new Date(),\n        currentEntity,\n        processedCount: context.processedCount,\n        totalCount: context.processedCount,\n        activityLog: toInputJsonValue(context.activityLog),\n        entityProgress: toInputJsonValue(context.entityProgress),\n        configuration: toInputJsonValue(serializedConfiguration),\n      },\n    });\n\n    throw error;\n  }\n}\n\ntype TestmoQueueMode = \"analyze\" | \"import\";\n\nasync function processor(job: Job<{ jobId: string; mode?: TestmoQueueMode }>) {\n  const { jobId, mode = \"analyze\" } = job.data;\n\n  if (!jobId) {\n    throw new Error(\"Job id is required\");\n  }\n\n  const importJob = await prisma.testmoImportJob.findUnique({\n    where: { id: jobId },\n  });\n\n  if (!importJob) {\n    throw new Error(`Testmo import job ${jobId} not found`);\n  }\n\n  if (FINAL_STATUSES.has(importJob.status)) {\n    return { status: importJob.status };\n  }\n\n  if (mode === \"import\") {\n    return processImportMode(importJob, jobId);\n  }\n\n  if (mode !== \"analyze\") {\n    throw new Error(`Unsupported Testmo import job mode: ${mode}`);\n  }\n\n  if (!bucketName && !importJob.storageBucket) {\n    throw new Error(\"AWS bucket is not configured\");\n  }\n\n  const resolvedBucket = importJob.storageBucket || bucketName!;\n\n  if (!importJob.storageKey) {\n    throw new Error(\"Storage key missing on import job\");\n  }\n\n  if (importJob.cancelRequested) {\n    await prisma.testmoImportJob.update({\n      where: { id: jobId },\n      data: {\n        status: \"CANCELED\",\n        statusMessage: \"Import was canceled before it started\",\n        canceledAt: new Date(),\n        phase: null,\n      },\n    });\n    return { status: \"CANCELED\" };\n  }\n\n  await prisma.testmoImportDataset.deleteMany({ where: { jobId } });\n\n  await prisma.testmoImportJob.update({\n    where: { id: jobId },\n    data: {\n      status: \"RUNNING\",\n      phase: \"ANALYZING\",\n      statusMessage: \"Opening and scanning export file...\",\n      startedAt: new Date(),\n      processedDatasets: 0,\n      processedRows: BigInt(0),\n    },\n  });\n\n  // Download the entire file to a temporary location first, then process it\n  // This avoids streaming issues with large files\n  const { tmpdir } = await import(\"os\");\n  const { join } = await import(\"path\");\n  const { createWriteStream, createReadStream, unlink } = await import(\"fs\");\n  const { pipeline } = await import(\"stream/promises\");\n  const { promisify } = await import(\"util\");\n  const unlinkAsync = promisify(unlink);\n\n  const tempFilePath = join(tmpdir(), `testmo-import-${jobId}.json`);\n  console.log(\n    `[Worker] Downloading file to temporary location: ${tempFilePath}`\n  );\n\n  await prisma.testmoImportJob.update({\n    where: { id: jobId },\n    data: {\n      statusMessage: \"Preparing data...\",\n    },\n  });\n\n  // Download file from S3\n  const getObjectResponse = await s3Client.send(\n    new GetObjectCommand({\n      Bucket: resolvedBucket,\n      Key: importJob.storageKey,\n    })\n  );\n\n  const s3Stream = getObjectResponse.Body as Readable | null;\n  if (!s3Stream) {\n    throw new Error(\"Failed to open uploaded file for download\");\n  }\n\n  const fileSizeBigInt =\n    getObjectResponse.ContentLength ?? importJob.originalFileSize;\n  const fileSize = fileSizeBigInt ? Number(fileSizeBigInt) : undefined;\n\n  console.log(\n    `[Worker] File size: ${fileSize ? `${fileSize} bytes (${(fileSize / 1024 / 1024 / 1024).toFixed(2)} GB)` : \"unknown\"}`\n  );\n\n  const tempFileStream = createWriteStream(tempFilePath);\n  let bodyStream: Readable;\n\n  try {\n    // Download the file completely to disk\n    console.log(`[Worker] Streaming file from S3 to disk...`);\n    await pipeline(s3Stream, tempFileStream);\n\n    console.log(`[Worker] Download complete. File saved to ${tempFilePath}`);\n\n    await prisma.testmoImportJob.update({\n      where: { id: jobId },\n      data: {\n        statusMessage: \"Download complete. Starting analysis...\",\n      },\n    });\n\n    // Now open the local file for processing\n    bodyStream = createReadStream(tempFilePath);\n    if (fileSize) {\n      (bodyStream as any).__fileSize = fileSize;\n    }\n\n    // Clean up temp file after processing\n    bodyStream.on(\"close\", async () => {\n      try {\n        await unlinkAsync(tempFilePath);\n        console.log(`[Worker] Cleaned up temporary file: ${tempFilePath}`);\n      } catch (error) {\n        console.error(`[Worker] Failed to clean up temporary file:`, error);\n      }\n    });\n  } catch (error) {\n    // Clean up temp file on error\n    try {\n      await unlinkAsync(tempFilePath);\n      console.log(\n        `[Worker] Cleaned up temporary file after error: ${tempFilePath}`\n      );\n    } catch (cleanupError) {\n      console.error(\n        `[Worker] Failed to clean up temporary file after error:`,\n        cleanupError\n      );\n    }\n    throw error;\n  }\n\n  let processedDatasets = 0;\n  let processedRows = BigInt(0);\n  let cancelRequested = false;\n\n  const handleProgress = async (\n    bytesRead: number,\n    totalBytes: number,\n    percentage: number,\n    estimatedTimeRemaining?: number | null\n  ) => {\n    if (cancelRequested) {\n      return;\n    }\n\n    // Format ETA for logging\n    let etaDisplay = \"\";\n    if (estimatedTimeRemaining) {\n      if (estimatedTimeRemaining < 60) {\n        etaDisplay = ` - ETA: ${estimatedTimeRemaining}s`;\n      } else if (estimatedTimeRemaining < 3600) {\n        const minutes = Math.ceil(estimatedTimeRemaining / 60);\n        etaDisplay = ` - ETA: ${minutes}m`;\n      } else {\n        const hours = Math.floor(estimatedTimeRemaining / 3600);\n        const minutes = Math.ceil((estimatedTimeRemaining % 3600) / 60);\n        etaDisplay = ` - ETA: ${hours}h ${minutes}m`;\n      }\n    }\n\n    console.log(\n      `[Worker] Progress update: ${percentage}% (${bytesRead}/${totalBytes} bytes)${etaDisplay}`\n    );\n\n    await prisma.testmoImportJob.update({\n      where: { id: jobId },\n      data: {\n        statusMessage: `Scanning file... ${percentage}% complete`,\n        estimatedTimeRemaining: estimatedTimeRemaining?.toString() ?? null,\n      },\n    });\n  };\n\n  const handleDatasetComplete = async (dataset: TestmoDatasetSummary) => {\n    if (cancelRequested) {\n      return;\n    }\n\n    processedDatasets += 1;\n    processedRows += BigInt(dataset.rowCount);\n\n    const schemaValue =\n      dataset.schema !== undefined && dataset.schema !== null\n        ? (JSON.parse(JSON.stringify(dataset.schema)) as Prisma.InputJsonValue)\n        : Prisma.JsonNull;\n\n    const sampleRowsValue =\n      dataset.sampleRows.length > 0\n        ? (JSON.parse(\n            JSON.stringify(dataset.sampleRows)\n          ) as Prisma.InputJsonValue)\n        : Prisma.JsonNull;\n\n    const allRowsValue =\n      dataset.allRows && dataset.allRows.length > 0\n        ? (JSON.parse(JSON.stringify(dataset.allRows)) as Prisma.InputJsonValue)\n        : Prisma.JsonNull;\n\n    await prisma.testmoImportDataset.create({\n      data: {\n        jobId,\n        name: dataset.name,\n        rowCount: dataset.rowCount,\n        sampleRowCount: dataset.sampleRows.length,\n        truncated: dataset.truncated,\n        schema: schemaValue,\n        sampleRows: sampleRowsValue,\n        allRows: allRowsValue,\n      },\n    });\n\n    const updatedJob = await prisma.testmoImportJob.update({\n      where: { id: jobId },\n      data: {\n        processedDatasets,\n        processedRows,\n        statusMessage: `Found ${dataset.name} (${dataset.rowCount.toLocaleString()} rows)`,\n      },\n      select: {\n        cancelRequested: true,\n      },\n    });\n\n    cancelRequested = updatedJob.cancelRequested;\n  };\n\n  try {\n    const summary = await analyzeTestmoExport(bodyStream, jobId, prisma, {\n      onDatasetComplete: handleDatasetComplete,\n      onProgress: handleProgress,\n      shouldAbort: () => cancelRequested,\n    });\n\n    if (cancelRequested) {\n      await prisma.testmoImportJob.update({\n        where: { id: jobId },\n        data: {\n          status: \"CANCELED\",\n          statusMessage: \"Import was canceled\",\n          canceledAt: new Date(),\n          phase: null,\n        },\n      });\n\n      return { status: \"CANCELED\" };\n    }\n\n    const analysisPayload = {\n      meta: {\n        totalDatasets: summary.meta.totalDatasets,\n        totalRows: summary.meta.totalRows,\n        durationMs: summary.meta.durationMs,\n        startedAt: summary.meta.startedAt.toISOString(),\n        completedAt: summary.meta.completedAt.toISOString(),\n        fileSizeBytes:\n          Number(\n            importJob.originalFileSize ?? summary.meta.fileSizeBytes ?? 0\n          ) || 0,\n      },\n    } satisfies Record<string, unknown>;\n\n    await prisma.testmoImportJob.update({\n      where: { id: jobId },\n      data: {\n        status: \"READY\",\n        phase: \"CONFIGURING\",\n        statusMessage: \"Analysis complete. Configure mapping to continue.\",\n        totalDatasets: summary.meta.totalDatasets,\n        totalRows: BigInt(summary.meta.totalRows),\n        processedDatasets,\n        processedRows,\n        durationMs: summary.meta.durationMs,\n        analysisGeneratedAt: new Date(),\n        configuration: Prisma.JsonNull,\n        options: Prisma.JsonNull,\n        analysis: analysisPayload as Prisma.JsonObject,\n        processedCount: 0,\n        errorCount: 0,\n        skippedCount: 0,\n        totalCount: 0,\n        currentEntity: null,\n        estimatedTimeRemaining: null,\n        processingRate: null,\n        activityLog: Prisma.JsonNull,\n        entityProgress: Prisma.JsonNull,\n      },\n    });\n\n    if (processedDatasets === 0 && summary.meta.totalDatasets === 0) {\n      await prisma.testmoImportJob.update({\n        where: { id: jobId },\n        data: {\n          statusMessage: \"Analysis complete (no datasets found)\",\n        },\n      });\n    }\n\n    return { status: \"READY\" };\n  } catch (error) {\n    if (\n      cancelRequested ||\n      (error instanceof Error && error.name === \"AbortError\")\n    ) {\n      await prisma.testmoImportJob.update({\n        where: { id: jobId },\n        data: {\n          status: \"CANCELED\",\n          statusMessage: \"Import was canceled\",\n          canceledAt: new Date(),\n          phase: null,\n        },\n      });\n\n      return { status: \"CANCELED\" };\n    }\n\n    console.error(`Testmo import job ${jobId} failed`, error);\n\n    await prisma.testmoImportJob.update({\n      where: { id: jobId },\n      data: {\n        status: \"FAILED\",\n        statusMessage: \"Import failed\",\n        error: error instanceof Error ? error.message : String(error),\n        phase: null,\n      },\n    });\n\n    throw error;\n  }\n}\n\nasync function startWorker() {\n  // Log multi-tenant mode status\n  if (isMultiTenantMode()) {\n    console.log(\"Testmo import worker starting in MULTI-TENANT mode\");\n    console.warn(\"WARNING: Testmo import currently only supports single-tenant mode. Multi-tenant support requires refactoring.\");\n  } else {\n    console.log(\"Testmo import worker starting in SINGLE-TENANT mode\");\n  }\n\n  if (!valkeyConnection) {\n    console.warn(\n      \"Valkey connection not available. Testmo import worker cannot start.\"\n    );\n    process.exit(1);\n  }\n\n  const worker = new Worker(TESTMO_IMPORT_QUEUE_NAME, processor, {\n    connection: valkeyConnection,\n    concurrency: 1,\n  });\n\n  worker.on(\"completed\", (job) => {\n    console.log(\n      `Testmo import job ${job.id} completed successfully (${job.name}).`\n    );\n  });\n\n  worker.on(\"failed\", (job, err) => {\n    console.error(`Testmo import job ${job?.id} failed with error:`, err);\n  });\n\n  worker.on(\"error\", (err) => {\n    console.error(\"Testmo import worker encountered an error:\", err);\n  });\n\n  console.log(\"Testmo import worker started and listening for jobs...\");\n\n  const shutdown = async () => {\n    console.log(\"Shutting down Testmo import worker...\");\n    await worker.close();\n    await prisma.$disconnect();\n    // Disconnect all tenant Prisma clients in multi-tenant mode\n    if (isMultiTenantMode()) {\n      await disconnectAllTenantClients();\n    }\n    console.log(\"Testmo import worker shut down gracefully.\");\n    process.exit(0);\n  };\n\n  process.on(\"SIGTERM\", shutdown);\n  process.on(\"SIGINT\", shutdown);\n}\n\n// Start worker when file is run directly (works with both ESM and CommonJS)\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  (typeof import.meta === \"undefined\" ||\n    (import.meta as any).url === undefined)\n) {\n  startWorker().catch((err) => {\n    console.error(\"Failed to start Testmo import worker:\", err);\n    process.exit(1);\n  });\n}\n", "// lib/multiTenantPrisma.ts\n// Multi-tenant Prisma client factory for shared worker containers\n\nimport { PrismaClient } from \"@prisma/client\";\n\n/**\n * Tenant configuration interface\n */\nexport interface TenantConfig {\n  tenantId: string;\n  databaseUrl: string;\n  elasticsearchNode?: string;\n  elasticsearchIndex?: string;\n}\n\n/**\n * Check if multi-tenant mode is enabled\n */\nexport function isMultiTenantMode(): boolean {\n  return process.env.MULTI_TENANT_MODE === \"true\";\n}\n\n/**\n * Get the current instance's tenant ID\n * In multi-tenant mode, each web app instance belongs to a single tenant\n * Set via INSTANCE_TENANT_ID environment variable\n * Returns undefined in single-tenant mode or if not configured\n */\nexport function getCurrentTenantId(): string | undefined {\n  if (!isMultiTenantMode()) {\n    return undefined;\n  }\n  return process.env.INSTANCE_TENANT_ID;\n}\n\n/**\n * Cache of Prisma clients per tenant to avoid creating new connections for each job\n */\nconst tenantClients: Map<string, PrismaClient> = new Map();\n\n/**\n * Tenant configurations loaded from environment or config file\n */\nlet tenantConfigs: Map<string, TenantConfig> | null = null;\n\n/**\n * Load tenant configurations from environment variable\n * Expected format: TENANT_CONFIGS='{\"tenant1\": {\"databaseUrl\": \"...\", \"elasticsearchNode\": \"...\"}, ...}'\n * Or from individual environment variables: TENANT_<ID>_DATABASE_URL, TENANT_<ID>_ELASTICSEARCH_NODE\n */\nexport function loadTenantConfigs(): Map<string, TenantConfig> {\n  if (tenantConfigs) {\n    return tenantConfigs;\n  }\n\n  tenantConfigs = new Map();\n\n  // Try loading from JSON config first\n  const configJson = process.env.TENANT_CONFIGS;\n  if (configJson) {\n    try {\n      const configs = JSON.parse(configJson) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(configs)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n        });\n      }\n      console.log(`Loaded ${tenantConfigs.size} tenant configurations from TENANT_CONFIGS`);\n    } catch (error) {\n      console.error(\"Failed to parse TENANT_CONFIGS:\", error);\n    }\n  }\n\n  // Also check for individual tenant environment variables\n  // Format: TENANT_<TENANT_ID>_DATABASE_URL, TENANT_<TENANT_ID>_ELASTICSEARCH_NODE\n  for (const [key, value] of Object.entries(process.env)) {\n    const match = key.match(/^TENANT_([A-Z0-9_]+)_DATABASE_URL$/);\n    if (match && value) {\n      const tenantId = match[1].toLowerCase();\n      if (!tenantConfigs.has(tenantId)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: value,\n          elasticsearchNode: process.env[`TENANT_${match[1]}_ELASTICSEARCH_NODE`],\n          elasticsearchIndex: process.env[`TENANT_${match[1]}_ELASTICSEARCH_INDEX`],\n        });\n      }\n    }\n  }\n\n  if (tenantConfigs.size === 0) {\n    console.warn(\"No tenant configurations found. Multi-tenant mode will not work without configurations.\");\n  }\n\n  return tenantConfigs;\n}\n\n/**\n * Get tenant configuration by ID\n */\nexport function getTenantConfig(tenantId: string): TenantConfig | undefined {\n  const configs = loadTenantConfigs();\n  return configs.get(tenantId);\n}\n\n/**\n * Get all tenant IDs\n */\nexport function getAllTenantIds(): string[] {\n  const configs = loadTenantConfigs();\n  return Array.from(configs.keys());\n}\n\n/**\n * Create a Prisma client for a specific tenant\n */\nfunction createTenantPrismaClient(config: TenantConfig): PrismaClient {\n  const client = new PrismaClient({\n    datasources: {\n      db: {\n        url: config.databaseUrl,\n      },\n    },\n    errorFormat: \"pretty\",\n  });\n\n  return client;\n}\n\n/**\n * Get or create a Prisma client for a specific tenant\n * Caches clients to reuse connections\n */\nexport function getTenantPrismaClient(tenantId: string): PrismaClient {\n  // Check cache first\n  let client = tenantClients.get(tenantId);\n  if (client) {\n    return client;\n  }\n\n  // Get tenant config\n  const config = getTenantConfig(tenantId);\n  if (!config) {\n    throw new Error(`No configuration found for tenant: ${tenantId}`);\n  }\n\n  // Create and cache new client\n  client = createTenantPrismaClient(config);\n  tenantClients.set(tenantId, client);\n  console.log(`Created Prisma client for tenant: ${tenantId}`);\n\n  return client;\n}\n\n/**\n * Get a Prisma client based on job data\n * In single-tenant mode, returns the default client\n * In multi-tenant mode, returns tenant-specific client\n */\nexport function getPrismaClientForJob(jobData: { tenantId?: string }): PrismaClient {\n  if (!isMultiTenantMode()) {\n    // Single-tenant mode: use lightweight Prisma client (no ES sync extensions)\n    // Import lazily to avoid circular dependencies\n    const { prisma } = require(\"./prismaBase\");\n    return prisma;\n  }\n\n  // Multi-tenant mode: require tenantId\n  if (!jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n\n  return getTenantPrismaClient(jobData.tenantId);\n}\n\n/**\n * Disconnect all tenant clients (for graceful shutdown)\n */\nexport async function disconnectAllTenantClients(): Promise<void> {\n  const disconnectPromises: Promise<void>[] = [];\n\n  for (const [tenantId, client] of tenantClients) {\n    console.log(`Disconnecting Prisma client for tenant: ${tenantId}`);\n    disconnectPromises.push(client.$disconnect());\n  }\n\n  await Promise.all(disconnectPromises);\n  tenantClients.clear();\n  console.log(\"All tenant Prisma clients disconnected\");\n}\n\n/**\n * Base interface for job data that supports multi-tenancy\n */\nexport interface MultiTenantJobData {\n  tenantId?: string; // Optional in single-tenant mode, required in multi-tenant mode\n}\n\n/**\n * Validate job data for multi-tenant mode\n */\nexport function validateMultiTenantJobData(jobData: MultiTenantJobData): void {\n  if (isMultiTenantMode() && !jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n}\n", "import IORedis from \"ioredis\";\n\n// Check if we should skip Valkey connection (useful during build)\nconst skipConnection = process.env.SKIP_VALKEY_CONNECTION === \"true\";\n\n// Get Valkey URL from environment\nconst valkeyUrl = process.env.VALKEY_URL;\n\nif (!valkeyUrl && !skipConnection) {\n  // Log an error, but maybe don't throw immediately\n  // depending on whether Valkey is strictly required at startup\n  console.error(\n    \"VALKEY_URL environment variable is not set. Background jobs may fail.\"\n  );\n  // Optional: throw new Error('VALKEY_URL environment variable is not set.');\n}\n\n// Configure the connection options\nconst connectionOptions = {\n  maxRetriesPerRequest: null, // Required by BullMQ\n  enableReadyCheck: false, // Optional: Sometimes helps with startup race conditions\n};\n\nlet valkeyConnection: IORedis | null = null;\n\nif (valkeyUrl && !skipConnection) {\n  // Convert valkey:// to redis:// for ioredis compatibility\n  // ioredis expects redis:// protocol but we're connecting to Valkey\n  const connectionUrl = valkeyUrl.replace(/^valkey:\\/\\//, 'redis://');\n  \n  // Create and export the connection instance only if URL is provided\n  valkeyConnection = new IORedis(connectionUrl, connectionOptions);\n\n  valkeyConnection.on(\"connect\", () => {\n    console.log(\"Successfully connected to Valkey.\");\n  });\n\n  valkeyConnection.on(\"error\", (err) => {\n    console.error(\"Valkey connection error:\", err);\n  });\n} else {\n  console.warn(\"Valkey URL not provided. Valkey connection not established.\");\n}\n\nexport default valkeyConnection;", "import { Queue } from \"bullmq\";\nimport valkeyConnection from \"./valkey\";\nimport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n} from \"./queueNames\";\n\n// Re-export queue names for backward compatibility\nexport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n};\n\n// Lazy-initialized queue instances\nlet _forecastQueue: Queue | null = null;\nlet _notificationQueue: Queue | null = null;\nlet _emailQueue: Queue | null = null;\nlet _syncQueue: Queue | null = null;\nlet _testmoImportQueue: Queue | null = null;\nlet _elasticsearchReindexQueue: Queue | null = null;\n\n/**\n * Get the forecast queue instance (lazy initialization)\n * Only creates the queue when first accessed\n */\nexport function getForecastQueue(): Queue | null {\n  if (_forecastQueue) return _forecastQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${FORECAST_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _forecastQueue = new Queue(FORECAST_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${FORECAST_QUEUE_NAME}\" initialized.`);\n\n  _forecastQueue.on(\"error\", (error) => {\n    console.error(`Queue ${FORECAST_QUEUE_NAME} error:`, error);\n  });\n\n  return _forecastQueue;\n}\n\n/**\n * Get the notification queue instance (lazy initialization)\n */\nexport function getNotificationQueue(): Queue | null {\n  if (_notificationQueue) return _notificationQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${NOTIFICATION_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _notificationQueue = new Queue(NOTIFICATION_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${NOTIFICATION_QUEUE_NAME}\" initialized.`);\n\n  _notificationQueue.on(\"error\", (error) => {\n    console.error(`Queue ${NOTIFICATION_QUEUE_NAME} error:`, error);\n  });\n\n  return _notificationQueue;\n}\n\n/**\n * Get the email queue instance (lazy initialization)\n */\nexport function getEmailQueue(): Queue | null {\n  if (_emailQueue) return _emailQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${EMAIL_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _emailQueue = new Queue(EMAIL_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 5,\n      backoff: {\n        type: \"exponential\",\n        delay: 10000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 5000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${EMAIL_QUEUE_NAME}\" initialized.`);\n\n  _emailQueue.on(\"error\", (error) => {\n    console.error(`Queue ${EMAIL_QUEUE_NAME} error:`, error);\n  });\n\n  return _emailQueue;\n}\n\n/**\n * Get the sync queue instance (lazy initialization)\n */\nexport function getSyncQueue(): Queue | null {\n  if (_syncQueue) return _syncQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${SYNC_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _syncQueue = new Queue(SYNC_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 3,\n        count: 500,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 7,\n      },\n    },\n  });\n\n  console.log(`Queue \"${SYNC_QUEUE_NAME}\" initialized.`);\n\n  _syncQueue.on(\"error\", (error) => {\n    console.error(`Queue ${SYNC_QUEUE_NAME} error:`, error);\n  });\n\n  return _syncQueue;\n}\n\n/**\n * Get the Testmo import queue instance (lazy initialization)\n */\nexport function getTestmoImportQueue(): Queue | null {\n  if (_testmoImportQueue) return _testmoImportQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _testmoImportQueue = new Queue(TESTMO_IMPORT_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 100,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" initialized.`);\n\n  _testmoImportQueue.on(\"error\", (error) => {\n    console.error(`Queue ${TESTMO_IMPORT_QUEUE_NAME} error:`, error);\n  });\n\n  return _testmoImportQueue;\n}\n\n/**\n * Get the Elasticsearch reindex queue instance (lazy initialization)\n */\nexport function getElasticsearchReindexQueue(): Queue | null {\n  if (_elasticsearchReindexQueue) return _elasticsearchReindexQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _elasticsearchReindexQueue = new Queue(ELASTICSEARCH_REINDEX_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 50,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" initialized.`);\n\n  _elasticsearchReindexQueue.on(\"error\", (error) => {\n    console.error(`Queue ${ELASTICSEARCH_REINDEX_QUEUE_NAME} error:`, error);\n  });\n\n  return _elasticsearchReindexQueue;\n}\n\n/**\n * Get all queues (initializes all of them)\n * Use this only when you need access to all queues (e.g., admin dashboard)\n */\nexport function getAllQueues() {\n  return {\n    forecastQueue: getForecastQueue(),\n    notificationQueue: getNotificationQueue(),\n    emailQueue: getEmailQueue(),\n    syncQueue: getSyncQueue(),\n    testmoImportQueue: getTestmoImportQueue(),\n    elasticsearchReindexQueue: getElasticsearchReindexQueue(),\n  };\n}\n", "// Queue name constants - no initialization, just names\nexport const FORECAST_QUEUE_NAME = \"forecast-updates\";\nexport const NOTIFICATION_QUEUE_NAME = \"notifications\";\nexport const EMAIL_QUEUE_NAME = \"emails\";\nexport const SYNC_QUEUE_NAME = \"issue-sync\";\nexport const TESTMO_IMPORT_QUEUE_NAME = \"testmo-imports\";\nexport const ELASTICSEARCH_REINDEX_QUEUE_NAME = \"elasticsearch-reindex\";\n", "import { createReadStream, statSync } from \"node:fs\";\nimport type { Readable } from \"node:stream\";\nimport { Transform } from \"node:stream\";\nimport { chain } from \"stream-chain\";\nimport { parser } from \"stream-json\";\nimport Assembler from \"stream-json/Assembler\";\nimport { fileURLToPath } from \"node:url\";\nimport { PrismaClient, Prisma } from \"@prisma/client\";\nimport { TestmoStagingService } from \"./TestmoStagingService\";\nimport {\n  TestmoDatasetSummary,\n  TestmoExportAnalyzerOptions,\n  TestmoExportSummary,\n  TestmoReadableSource,\n} from \"./types\";\n\nconst DEFAULT_SAMPLE_ROW_LIMIT = 5;\nconst STAGING_BATCH_SIZE = 1000; // Batch size for staging to database\nconst ATTACHMENT_DATASET_PATTERN = /attachment/i;\n\nconst DEFAULT_PRESERVE_DATASETS = new Set([\n  \"users\",\n  \"roles\",\n  \"groups\",\n  \"user_groups\",\n  \"states\",\n  \"statuses\",\n  \"templates\",\n  \"template_fields\",\n  \"fields\",\n  \"field_values\",\n  \"configs\",\n  \"tags\",\n  \"projects\",\n  \"repositories\",\n  \"repository_folders\",\n  \"repository_cases\",\n  \"milestones\",\n  \"sessions\",\n  \"session_results\",\n  \"session_issues\",\n  \"session_tags\",\n  \"session_values\",\n  \"issue_targets\",\n  \"milestone_types\",\n]);\n\nconst DATASET_CONTAINER_KEYS = new Set([\"datasets\", \"entities\"]);\nconst DATASET_DATA_KEYS = new Set([\"data\", \"rows\", \"records\", \"items\"]);\nconst DATASET_SCHEMA_KEYS = new Set([\"schema\", \"columns\", \"fields\"]);\nconst DATASET_NAME_KEYS = new Set([\"name\", \"dataset\"]);\nconst IGNORED_DATASET_KEYS = new Set([\"meta\", \"summary\"]);\n\ntype StackEntry = {\n  type: \"object\" | \"array\";\n  key: string | null;\n  datasetName?: string | null;\n};\n\ninterface ActiveCapture {\n  assembler: Assembler;\n  datasetName: string;\n  purpose: \"schema\" | \"row\";\n  completed: boolean;\n  rowIndex?: number;\n  store: (value: unknown) => void;\n}\n\ntype InternalDatasetSummary = TestmoDatasetSummary & {\n  preserveAllRows: boolean;\n};\n\nexport interface TestmoExportAnalyzerOptionsWithStaging\n  extends TestmoExportAnalyzerOptions {\n  jobId: string;\n  prisma: PrismaClient | Prisma.TransactionClient;\n  onProgress?: (\n    bytesRead: number,\n    totalBytes: number,\n    percentage: number,\n    estimatedTimeRemaining?: number | null\n  ) => void | Promise<void>;\n}\n\nfunction createAbortError(message: string): Error {\n  const error = new Error(message);\n  error.name = \"AbortError\";\n  return error;\n}\n\nfunction createProgressTracker(\n  totalBytes: number,\n  onProgress?: (\n    bytesRead: number,\n    totalBytes: number,\n    percentage: number,\n    estimatedTimeRemaining?: number | null\n  ) => void | Promise<void>\n): Transform {\n  let bytesRead = 0;\n  let lastReportedPercentage = -1;\n  const REPORT_INTERVAL_PERCENTAGE = 1; // Report every 1% progress\n  const startTime = Date.now();\n\n  console.log(`[ProgressTracker] Created for file size: ${totalBytes} bytes`);\n\n  return new Transform({\n    transform(chunk: Buffer, encoding, callback) {\n      bytesRead += chunk.length;\n      const percentage =\n        totalBytes > 0 ? Math.floor((bytesRead / totalBytes) * 100) : 0;\n\n      // Only report when percentage changes by at least REPORT_INTERVAL_PERCENTAGE\n      if (\n        onProgress &&\n        percentage >= lastReportedPercentage + REPORT_INTERVAL_PERCENTAGE\n      ) {\n        lastReportedPercentage = percentage;\n\n        // Calculate ETA\n        const now = Date.now();\n        const elapsedMs = now - startTime;\n        const elapsedSeconds = elapsedMs / 1000;\n\n        let etaMessage = \"\";\n        let etaSeconds: number | null = null;\n        if (elapsedSeconds >= 2 && bytesRead > 0 && percentage > 0) {\n          const bytesPerSecond = bytesRead / elapsedSeconds;\n          const remainingBytes = totalBytes - bytesRead;\n          const estimatedSecondsRemaining = remainingBytes / bytesPerSecond;\n          etaSeconds = Math.ceil(estimatedSecondsRemaining);\n\n          // Format ETA for logging\n          if (estimatedSecondsRemaining < 60) {\n            etaMessage = ` - ETA: ${etaSeconds}s`;\n          } else if (estimatedSecondsRemaining < 3600) {\n            const minutes = Math.ceil(estimatedSecondsRemaining / 60);\n            etaMessage = ` - ETA: ${minutes}m`;\n          } else {\n            const hours = Math.floor(estimatedSecondsRemaining / 3600);\n            const minutes = Math.ceil((estimatedSecondsRemaining % 3600) / 60);\n            etaMessage = ` - ETA: ${hours}h ${minutes}m`;\n          }\n        }\n\n        console.log(\n          `[ProgressTracker] Progress: ${percentage}% (${bytesRead}/${totalBytes} bytes)${etaMessage}`\n        );\n        const result = onProgress(bytesRead, totalBytes, percentage, etaSeconds);\n        if (result instanceof Promise) {\n          result.then(() => callback(null, chunk)).catch(callback);\n        } else {\n          callback(null, chunk);\n        }\n      } else {\n        callback(null, chunk);\n      }\n    },\n  });\n}\n\nfunction isReadable(value: unknown): value is Readable {\n  return (\n    !!value &&\n    typeof value === \"object\" &&\n    typeof (value as Readable).pipe === \"function\" &&\n    typeof (value as Readable).read === \"function\"\n  );\n}\n\nfunction resolveSource(source: TestmoReadableSource): {\n  stream: Readable;\n  dispose: () => Promise<void>;\n  size?: number;\n} {\n  if (typeof source === \"string\") {\n    const stream = createReadStream(source);\n    const dispose = async () => {\n      if (!stream.destroyed) {\n        await new Promise<void>((resolve) => {\n          stream.once(\"close\", resolve);\n          stream.destroy();\n        });\n      }\n    };\n    let size: number | undefined;\n    try {\n      size = statSync(source).size;\n    } catch {\n      size = undefined;\n    }\n    return { stream, dispose, size };\n  }\n\n  if (source instanceof URL) {\n    return resolveSource(fileURLToPath(source));\n  }\n\n  if (typeof source === \"function\") {\n    const stream = source();\n    if (!isReadable(stream)) {\n      throw new TypeError(\n        \"Testmo readable factory did not return a readable stream\"\n      );\n    }\n    const dispose = async () => {\n      if (!stream.destroyed) {\n        await new Promise<void>((resolve) => {\n          stream.once(\"close\", resolve);\n          stream.destroy();\n        });\n      }\n    };\n    return { stream, dispose };\n  }\n\n  if (isReadable(source)) {\n    const dispose = async () => {\n      if (!source.destroyed) {\n        await new Promise<void>((resolve) => {\n          source.once(\"close\", resolve);\n          source.destroy();\n        });\n      }\n    };\n    // Check if stream has size attached (e.g., from S3 ContentLength)\n    const size = (source as any).__fileSize as number | undefined;\n    return { stream: source, dispose, size };\n  }\n\n  throw new TypeError(\"Unsupported Testmo readable source\");\n}\n\nfunction isDatasetContainerKey(key: string | null | undefined): boolean {\n  if (!key) {\n    return false;\n  }\n  return DATASET_CONTAINER_KEYS.has(key);\n}\n\nfunction currentDatasetName(stack: StackEntry[]): string | null {\n  for (let i = stack.length - 1; i >= 0; i -= 1) {\n    const entry = stack[i];\n    if (entry.datasetName) {\n      return entry.datasetName;\n    }\n  }\n\n  for (let i = stack.length - 1; i >= 0; i -= 1) {\n    const entry = stack[i];\n    if (\n      entry.type === \"object\" &&\n      typeof entry.key === \"string\" &&\n      !DATASET_SCHEMA_KEYS.has(entry.key) &&\n      !DATASET_DATA_KEYS.has(entry.key) &&\n      !isDatasetContainerKey(entry.key) &&\n      !IGNORED_DATASET_KEYS.has(entry.key)\n    ) {\n      const parent = stack[i - 1];\n      if (\n        parent &&\n        parent.type === \"object\" &&\n        (parent.key === null || isDatasetContainerKey(parent.key))\n      ) {\n        return entry.key;\n      }\n    }\n  }\n  return null;\n}\n\nfunction coercePrimitive(chunkName: string, value: unknown): unknown {\n  switch (chunkName) {\n    case \"numberValue\":\n      return typeof value === \"string\" ? Number(value) : value;\n    case \"trueValue\":\n      return true;\n    case \"falseValue\":\n      return false;\n    case \"nullValue\":\n      return null;\n    default:\n      return value;\n  }\n}\n\nconst SAMPLE_TRUNCATION_CONFIG = {\n  maxStringLength: 1000,\n  maxArrayItems: 10,\n  maxObjectKeys: 20,\n  maxDepth: 3,\n};\n\nfunction sanitizeSampleValue(value: unknown, depth = 0): unknown {\n  if (depth > SAMPLE_TRUNCATION_CONFIG.maxDepth) {\n    return \"[truncated depth]\";\n  }\n\n  if (typeof value === \"string\") {\n    if (value.length > SAMPLE_TRUNCATION_CONFIG.maxStringLength) {\n      const truncated = value.slice(\n        0,\n        SAMPLE_TRUNCATION_CONFIG.maxStringLength\n      );\n      const remaining = value.length - SAMPLE_TRUNCATION_CONFIG.maxStringLength;\n      return `${truncated}\\u2026 [${remaining} more characters]`;\n    }\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    const items = value\n      .slice(0, SAMPLE_TRUNCATION_CONFIG.maxArrayItems)\n      .map((item) => sanitizeSampleValue(item, depth + 1));\n    if (value.length > SAMPLE_TRUNCATION_CONFIG.maxArrayItems) {\n      items.push(\n        `[${value.length - SAMPLE_TRUNCATION_CONFIG.maxArrayItems} more items]`\n      );\n    }\n    return items;\n  }\n\n  if (value && typeof value === \"object\") {\n    const entries = Object.entries(value as Record<string, unknown>);\n    const result: Record<string, unknown> = {};\n    for (const [key, entryValue] of entries.slice(\n      0,\n      SAMPLE_TRUNCATION_CONFIG.maxObjectKeys\n    )) {\n      result[key] = sanitizeSampleValue(entryValue, depth + 1);\n    }\n    if (entries.length > SAMPLE_TRUNCATION_CONFIG.maxObjectKeys) {\n      result.__truncated_keys__ = `${entries.length - SAMPLE_TRUNCATION_CONFIG.maxObjectKeys} more keys`;\n    }\n    return result;\n  }\n\n  return value;\n}\n\nexport class TestmoExportAnalyzer {\n  private stagingBatches = new Map<\n    string,\n    Array<{ index: number; data: any }>\n  >();\n  private stagingService: TestmoStagingService | null = null;\n  private jobId: string | null = null;\n  private readonly masterRepositoryIds = new Set<number>();\n\n  constructor(\n    private readonly defaults: {\n      sampleRowLimit: number;\n      preserveDatasets: Set<string>;\n      maxRowsToPreserve: number;\n    } = {\n      sampleRowLimit: DEFAULT_SAMPLE_ROW_LIMIT,\n      preserveDatasets: DEFAULT_PRESERVE_DATASETS,\n      maxRowsToPreserve: Number.POSITIVE_INFINITY,\n    }\n  ) {}\n\n  /**\n   * Analyze a Testmo export and stream data to staging tables.\n   */\n  async analyze(\n    source: TestmoReadableSource,\n    options: TestmoExportAnalyzerOptionsWithStaging\n  ): Promise<TestmoExportSummary> {\n    this.stagingService = new TestmoStagingService(options.prisma);\n    this.jobId = options.jobId;\n    this.masterRepositoryIds.clear();\n\n    const startedAt = new Date();\n    const preserveDatasets =\n      options.preserveDatasets ?? this.defaults.preserveDatasets;\n    const sampleRowLimit =\n      options.sampleRowLimit ?? this.defaults.sampleRowLimit;\n\n    const { stream, dispose, size } = resolveSource(source);\n    const abortSignal = options.signal;\n\n    if (abortSignal?.aborted) {\n      await dispose();\n      throw createAbortError(\"Testmo export analysis aborted before start\");\n    }\n\n    const stack: StackEntry[] = [];\n    const datasets = new Map<string, InternalDatasetSummary>();\n    let lastKey: string | null = null;\n    let totalRows = 0;\n    let activeCaptures: ActiveCapture[] = [];\n    const currentRowIndexes = new Map<string, number>();\n\n    // Create pipeline with progress tracker if size is known\n    const pipelineStages: any[] = [stream];\n    console.log(\n      `[Analyzer] File size: ${size}, onProgress callback: ${!!options.onProgress}`\n    );\n    if (size && size > 0 && options.onProgress) {\n      console.log(`[Analyzer] Adding progress tracker to pipeline`);\n      pipelineStages.push(createProgressTracker(size, options.onProgress));\n    } else {\n      console.log(\n        `[Analyzer] NOT adding progress tracker - size: ${size}, hasCallback: ${!!options.onProgress}`\n      );\n    }\n    pipelineStages.push(parser());\n\n    const pipeline = chain(pipelineStages);\n\n    const abortHandler = () => {\n      pipeline.destroy(createAbortError(\"Testmo export analysis aborted\"));\n    };\n    abortSignal?.addEventListener(\"abort\", abortHandler, { once: true });\n\n    const ensureSummary = (name: string): InternalDatasetSummary => {\n      let summary = datasets.get(name);\n      if (!summary) {\n        summary = {\n          name,\n          rowCount: 0,\n          schema: null,\n          sampleRows: [],\n          truncated: false,\n          preserveAllRows: false, // We don't preserve in memory anymore\n        };\n        datasets.set(name, summary);\n        currentRowIndexes.set(name, 0);\n      }\n      return summary;\n    };\n\n    const finalizeCapture = async (capture: ActiveCapture) => {\n      if (capture.completed) {\n        return;\n      }\n      const value = capture.assembler.current;\n\n      // If this is a row, stage it\n      if (capture.purpose === \"row\" && this.stagingService && this.jobId) {\n        const rowIndex = capture.rowIndex ?? 0;\n        await this.stageRow(capture.datasetName, rowIndex, value);\n\n        if (!ATTACHMENT_DATASET_PATTERN.test(capture.datasetName)) {\n          const summary = datasets.get(capture.datasetName);\n          if (summary && summary.sampleRows.length < sampleRowLimit) {\n            summary.sampleRows.push(sanitizeSampleValue(value));\n          }\n        }\n      } else {\n        capture.store(value);\n      }\n\n      capture.completed = true;\n    };\n\n    const handleChunk = async (chunk: any) => {\n      try {\n        if (abortSignal?.aborted) {\n          throw createAbortError(\"Testmo export analysis aborted\");\n        }\n\n        if (options.shouldAbort?.()) {\n          throw createAbortError(\"Testmo export analysis aborted\");\n        }\n\n        for (const capture of activeCaptures) {\n          const assemblerAny = capture.assembler as unknown as Record<\n            string,\n            (value: unknown) => void\n          >;\n          const handler = assemblerAny[chunk.name];\n          if (typeof handler === \"function\") {\n            handler.call(capture.assembler, chunk.value);\n          }\n        }\n\n        if (activeCaptures.length > 0) {\n          const stillActive: ActiveCapture[] = [];\n          for (const capture of activeCaptures) {\n            if (!capture.completed && capture.assembler.done) {\n              await finalizeCapture(capture);\n            }\n            if (!capture.completed) {\n              stillActive.push(capture);\n            }\n          }\n          activeCaptures = stillActive;\n        }\n\n        switch (chunk.name) {\n          case \"startObject\": {\n            const parent = stack[stack.length - 1];\n            const entry: StackEntry = {\n              type: \"object\",\n              key: lastKey,\n              datasetName: parent?.datasetName ?? null,\n            };\n            stack.push(entry);\n\n            const parentDataset = parent?.datasetName ?? null;\n            if (\n              typeof entry.key === \"string\" &&\n              (!DATASET_SCHEMA_KEYS.has(entry.key) || parentDataset === null) &&\n              !DATASET_DATA_KEYS.has(entry.key) &&\n              !isDatasetContainerKey(entry.key) &&\n              !IGNORED_DATASET_KEYS.has(entry.key)\n            ) {\n              entry.datasetName = entry.key;\n            }\n\n            const datasetNameForEntry = currentDatasetName(stack);\n            if (datasetNameForEntry) {\n              entry.datasetName = entry.datasetName ?? datasetNameForEntry;\n              ensureSummary(datasetNameForEntry);\n            }\n\n            if (entry.key && DATASET_SCHEMA_KEYS.has(entry.key)) {\n              const datasetName = currentDatasetName(stack);\n              if (datasetName) {\n                const summary = ensureSummary(datasetName);\n                const assembler = new Assembler();\n                assembler.startObject();\n                const capture: ActiveCapture = {\n                  assembler,\n                  datasetName,\n                  purpose: \"schema\",\n                  completed: false,\n                  store: (value: unknown) => {\n                    summary.schema = (value ?? null) as Record<\n                      string,\n                      unknown\n                    > | null;\n                  },\n                };\n                activeCaptures.push(capture);\n              }\n            } else if (\n              parent?.type === \"array\" &&\n              parent.datasetName &&\n              parent.key &&\n              DATASET_DATA_KEYS.has(parent.key)\n            ) {\n              const summary = ensureSummary(parent.datasetName);\n              const currentIndex =\n                currentRowIndexes.get(parent.datasetName) ?? 0;\n              summary.rowCount += 1;\n              totalRows += 1;\n              currentRowIndexes.set(parent.datasetName, currentIndex + 1);\n\n              // Always capture rows for staging\n              const assembler = new Assembler();\n              assembler.startObject();\n              const capture: ActiveCapture = {\n                assembler,\n                datasetName: parent.datasetName,\n                purpose: \"row\",\n                completed: false,\n                rowIndex: currentIndex,\n                store: (value: unknown) => {\n                  // This is only called for schema captures now\n                },\n              };\n              activeCaptures.push(capture);\n            }\n            break;\n          }\n          case \"endObject\":\n            stack.pop();\n            break;\n          case \"startArray\": {\n            const entry: StackEntry = {\n              type: \"array\",\n              key: lastKey,\n              datasetName: null,\n            };\n            if (lastKey && DATASET_DATA_KEYS.has(lastKey)) {\n              const datasetName = currentDatasetName(stack);\n              if (datasetName) {\n                entry.datasetName = datasetName;\n              }\n            }\n            stack.push(entry);\n            break;\n          }\n          case \"endArray\":\n            stack.pop();\n            break;\n          case \"keyValue\":\n            lastKey = String(chunk.value);\n            break;\n          case \"stringValue\":\n          case \"numberValue\":\n          case \"trueValue\":\n          case \"falseValue\":\n          case \"nullValue\":\n            coercePrimitive(chunk.name, chunk.value);\n            break;\n        }\n      } catch (error) {\n        if (error instanceof Error && error.name === \"AbortError\") {\n          throw error;\n        }\n        throw new Error(\n          `Error processing chunk: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    };\n\n    try {\n      for await (const chunk of pipeline) {\n        await handleChunk(chunk);\n      }\n    } catch (error) {\n      console.error(`[Analyzer] Error during analysis:`, error);\n      if (error instanceof Error && error.name === \"AbortError\") {\n        // Normal abort, not an error\n      } else {\n        throw error;\n      }\n    } finally {\n      abortSignal?.removeEventListener(\"abort\", abortHandler);\n\n      // Flush any remaining staging batches\n      await this.flushAllStagingBatches();\n\n      // Ensure all active captures are finalized\n      for (const capture of activeCaptures) {\n        await finalizeCapture(capture);\n      }\n\n      // Call onDatasetComplete for each dataset if provided\n      if (options.onDatasetComplete) {\n        for (const [name, dataset] of datasets) {\n          const datasetSummary: TestmoDatasetSummary = {\n            name: dataset.name,\n            rowCount: dataset.rowCount,\n            schema: dataset.schema,\n            sampleRows: dataset.sampleRows,\n            truncated: dataset.truncated,\n          };\n          await options.onDatasetComplete(datasetSummary);\n        }\n      }\n\n      await dispose();\n    }\n\n    const completedAt = new Date();\n    const durationMs = completedAt.getTime() - startedAt.getTime();\n\n    // Convert internal summaries to external format\n    const datasetsRecord = Array.from(datasets.values()).reduce(\n      (acc, ds) => {\n        acc[ds.name] = {\n          name: ds.name,\n          rowCount: ds.rowCount,\n          schema: ds.schema,\n          sampleRows: ds.sampleRows,\n          truncated: ds.truncated,\n        };\n        return acc;\n      },\n      {} as Record<string, TestmoDatasetSummary>\n    );\n\n    return {\n      datasets: datasetsRecord,\n      meta: {\n        totalDatasets: datasets.size,\n        totalRows,\n        durationMs,\n        startedAt,\n        completedAt,\n        fileSizeBytes: size,\n      },\n    };\n  }\n\n  /**\n   * Stage a row to the database batch\n  */\n  private async stageRow(datasetName: string, rowIndex: number, rowData: any) {\n    if (ATTACHMENT_DATASET_PATTERN.test(datasetName)) {\n      return;\n    }\n\n    if (this.shouldSkipRow(datasetName, rowData)) {\n      return;\n    }\n\n    if (!this.stagingBatches.has(datasetName)) {\n      this.stagingBatches.set(datasetName, []);\n    }\n\n    const batch = this.stagingBatches.get(datasetName)!;\n    batch.push({ index: rowIndex, data: rowData });\n\n    // Flush batch if it reaches the size limit\n    if (batch.length >= STAGING_BATCH_SIZE) {\n      await this.flushStagingBatch(datasetName);\n    }\n  }\n\n  /**\n   * Flush a specific staging batch to the database\n   */\n  private async flushStagingBatch(datasetName: string) {\n    if (!this.stagingService || !this.jobId) {\n      console.error(\n        `[Analyzer] Cannot flush batch - no staging service or job ID`\n      );\n      return;\n    }\n\n    const batch = this.stagingBatches.get(datasetName);\n    if (!batch || batch.length === 0) return;\n\n    try {\n      await this.stagingService.stageBatch(this.jobId, datasetName, batch);\n      this.stagingBatches.set(datasetName, []);\n    } catch (error) {\n      console.error(\n        `[Analyzer] Failed to stage batch for dataset ${datasetName}:`,\n        error\n      );\n      // Log more details about the error\n      if (error instanceof Error) {\n        console.error(`[Analyzer] Error message: ${error.message}`);\n        console.error(`[Analyzer] Error stack: ${error.stack}`);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Flush all remaining staging batches\n   */\n  private async flushAllStagingBatches() {\n    const flushPromises: Promise<void>[] = [];\n\n    console.log(\n      `[Analyzer] Flushing ${this.stagingBatches.size} dataset batches`\n    );\n    for (const [datasetName, batch] of this.stagingBatches) {\n      if (batch.length > 0) {\n        console.log(\n          `[Analyzer] Flushing ${batch.length} rows for dataset: ${datasetName}`\n        );\n        flushPromises.push(this.flushStagingBatch(datasetName));\n      }\n    }\n\n    await Promise.all(flushPromises);\n    console.log(`[Analyzer] All batches flushed`);\n  }\n\n  private shouldSkipRow(datasetName: string, rowData: any): boolean {\n    if (!rowData || typeof rowData !== \"object\") {\n      return false;\n    }\n\n    if (datasetName === \"repositories\") {\n      const repoId = this.toNumberSafe((rowData as any).id);\n      const isSnapshot =\n        this.toNumberSafe((rowData as any).is_snapshot) === 1 ||\n        String((rowData as any).is_snapshot ?? \"\")\n          .toLowerCase()\n          .includes(\"true\");\n      if (!isSnapshot && repoId !== null) {\n        this.masterRepositoryIds.add(repoId);\n      }\n      return isSnapshot;\n    }\n\n    if (\n      datasetName.startsWith(\"repository_\") &&\n      datasetName !== \"repository_case_tags\"\n    ) {\n      const repoId = this.toNumberSafe((rowData as any).repo_id);\n      if (repoId !== null && this.masterRepositoryIds.size > 0) {\n        return !this.masterRepositoryIds.has(repoId);\n      }\n    }\n\n    return false;\n  }\n\n  private toNumberSafe(value: unknown): number | null {\n    if (typeof value === \"number\" && Number.isFinite(value)) {\n      return value;\n    }\n    if (typeof value === \"string\") {\n      const trimmed = value.trim();\n      if (!trimmed) {\n        return null;\n      }\n      const parsed = Number(trimmed);\n      return Number.isFinite(parsed) ? parsed : null;\n    }\n    if (typeof value === \"bigint\") {\n      return Number(value);\n    }\n    return null;\n  }\n}\n\n/**\n * Convenience function for analyzing Testmo exports with staging.\n */\nexport const analyzeTestmoExport = async (\n  source: TestmoReadableSource,\n  jobId: string,\n  prisma: PrismaClient | Prisma.TransactionClient,\n  options?: Omit<TestmoExportAnalyzerOptionsWithStaging, \"jobId\" | \"prisma\">\n): Promise<TestmoExportSummary> => {\n  const analyzer = new TestmoExportAnalyzer();\n  return analyzer.analyze(source, {\n    ...options,\n    jobId,\n    prisma,\n  });\n};\n", "import { Prisma, PrismaClient } from '@prisma/client';\n\n/**\n * Service for managing Testmo import staging data in the database.\n * This service handles all database operations related to staging import data,\n * allowing the import process to work with large datasets without memory constraints.\n */\ntype StagingRowData = {\n  jobId: string;\n  datasetName: string;\n  rowIndex: number;\n  rowData: Prisma.InputJsonValue;\n  fieldName: string | null;\n  fieldValue: string | null;\n  text1: string | null;\n  text2: string | null;\n  text3: string | null;\n  text4: string | null;\n  processed: boolean;\n};\n\nexport class TestmoStagingService {\n  constructor(private prisma: PrismaClient | Prisma.TransactionClient) {}\n\n  private prepareStagingRow(\n    jobId: string,\n    datasetName: string,\n    rowIndex: number,\n    rowData: any\n  ): StagingRowData {\n    let sanitizedData: Prisma.InputJsonValue = rowData as Prisma.InputJsonValue;\n    let fieldName: string | null = null;\n    let fieldValue: string | null = null;\n    let text1: string | null = null;\n    let text2: string | null = null;\n    let text3: string | null = null;\n    let text4: string | null = null;\n\n    if (\n      datasetName === 'automation_run_test_fields' &&\n      rowData &&\n      typeof rowData === 'object' &&\n      !Array.isArray(rowData)\n    ) {\n      const clone = { ...(rowData as Record<string, unknown>) };\n      const rawValue = (clone as { value?: unknown }).value;\n\n      if (rawValue !== undefined) {\n        if (typeof rawValue === 'string') {\n          fieldValue = rawValue;\n        } else if (rawValue !== null) {\n          try {\n            fieldValue = JSON.stringify(rawValue);\n          } catch {\n            fieldValue = String(rawValue);\n          }\n        }\n        delete clone.value;\n      }\n\n      const rawName = (rowData as { name?: unknown }).name;\n      if (typeof rawName === 'string') {\n        fieldName = rawName;\n      }\n\n      sanitizedData = clone as Prisma.InputJsonValue;\n    }\n    if (\n      datasetName === 'run_result_steps' &&\n      rowData &&\n      typeof rowData === 'object' &&\n      !Array.isArray(rowData)\n    ) {\n      const clone = { ...(rowData as Record<string, unknown>) };\n\n      const extractText = (key: `text${1 | 2 | 3 | 4}`) => {\n        const raw = clone[key];\n        if (raw === undefined) {\n          return null;\n        }\n        delete clone[key];\n        if (raw === null) {\n          return null;\n        }\n        if (typeof raw === 'string') {\n          return raw;\n        }\n        try {\n          return JSON.stringify(raw);\n        } catch {\n          return String(raw);\n        }\n      };\n\n      text1 = extractText('text1');\n      text2 = extractText('text2');\n      text3 = extractText('text3');\n      text4 = extractText('text4');\n\n      sanitizedData = clone as Prisma.InputJsonValue;\n    }\n\n    return {\n      jobId,\n      datasetName,\n      rowIndex,\n      rowData: sanitizedData,\n      fieldName,\n      fieldValue,\n      text1,\n      text2,\n      text3,\n      text4,\n      processed: false,\n    };\n  }\n\n  /**\n   * Stage a single dataset row for later processing\n   */\n  async stageDatasetRow(\n    jobId: string,\n    datasetName: string,\n    rowIndex: number,\n    rowData: any\n  ) {\n    return this.prisma.testmoImportStaging.create({\n      data: this.prepareStagingRow(jobId, datasetName, rowIndex, rowData),\n    });\n  }\n\n  /**\n   * Batch stage multiple rows for better performance\n   */\n  async stageBatch(\n    jobId: string,\n    datasetName: string,\n    rows: Array<{ index: number; data: any }>\n  ) {\n    if (rows.length === 0) return { count: 0 };\n\n    const data = rows.map(({ index, data }) =>\n      this.prepareStagingRow(jobId, datasetName, index, data)\n    );\n\n    return this.prisma.testmoImportStaging.createMany({ data });\n  }\n\n  /**\n   * Store or update an entity mapping\n   */\n  async storeMapping(\n    jobId: string,\n    entityType: string,\n    sourceId: number,\n    targetId: string | null,\n    targetType: 'map' | 'create',\n    metadata?: any\n  ) {\n    return this.prisma.testmoImportMapping.upsert({\n      where: {\n        jobId_entityType_sourceId: {\n          jobId,\n          entityType,\n          sourceId,\n        },\n      },\n      create: {\n        jobId,\n        entityType,\n        sourceId,\n        targetId,\n        targetType,\n        metadata: metadata as Prisma.InputJsonValue,\n      },\n      update: {\n        targetId,\n        targetType,\n        metadata: metadata as Prisma.InputJsonValue,\n      },\n    });\n  }\n\n  /**\n   * Batch store multiple mappings\n   */\n  async storeMappingBatch(\n    jobId: string,\n    mappings: Array<{\n      entityType: string;\n      sourceId: number;\n      targetId: string | null;\n      targetType: 'map' | 'create';\n      metadata?: any;\n    }>\n  ) {\n    if (mappings.length === 0) return { count: 0 };\n\n    const operations = mappings.map(mapping =>\n      this.prisma.testmoImportMapping.upsert({\n        where: {\n          jobId_entityType_sourceId: {\n            jobId,\n            entityType: mapping.entityType,\n            sourceId: mapping.sourceId,\n          },\n        },\n        create: {\n          jobId,\n          entityType: mapping.entityType,\n          sourceId: mapping.sourceId,\n          targetId: mapping.targetId,\n          targetType: mapping.targetType,\n          metadata: mapping.metadata as Prisma.InputJsonValue,\n        },\n        update: {\n          targetId: mapping.targetId,\n          targetType: mapping.targetType,\n          metadata: mapping.metadata as Prisma.InputJsonValue,\n        },\n      })\n    );\n\n    const results = await Promise.all(operations);\n    return { count: results.length };\n  }\n\n  /**\n   * Get a specific mapping\n   */\n  async getMapping(jobId: string, entityType: string, sourceId: number) {\n    return this.prisma.testmoImportMapping.findUnique({\n      where: {\n        jobId_entityType_sourceId: {\n          jobId,\n          entityType,\n          sourceId,\n        },\n      },\n    });\n  }\n\n  /**\n   * Get all mappings for a specific entity type\n   */\n  async getMappingsByType(jobId: string, entityType: string) {\n    return this.prisma.testmoImportMapping.findMany({\n      where: {\n        jobId,\n        entityType,\n      },\n    });\n  }\n\n  /**\n   * Process staged rows in batches with cursor pagination.\n   * This allows processing large datasets without loading everything into memory.\n   */\n  async processStagedBatch<T>(\n    jobId: string,\n    datasetName: string,\n    batchSize: number,\n    processor: (\n      rows: Array<{\n        id: string;\n        rowIndex: number;\n        rowData: T;\n        fieldName?: string | null;\n        fieldValue?: string | null;\n        text1?: string | null;\n        text2?: string | null;\n        text3?: string | null;\n        text4?: string | null;\n      }>\n    ) => Promise<string[]>\n  ): Promise<{ processedCount: number; errorCount: number }> {\n    let cursor: string | undefined;\n    let processedCount = 0;\n    let errorCount = 0;\n\n    while (true) {\n      // Fetch the next batch of unprocessed rows\n      const batch = await this.prisma.testmoImportStaging.findMany({\n        where: {\n          jobId,\n          datasetName,\n          processed: false,\n        },\n        take: batchSize,\n        cursor: cursor ? { id: cursor } : undefined,\n        orderBy: { rowIndex: 'asc' }, // Maintain original order\n      });\n\n      if (batch.length === 0) break;\n\n      try {\n        // Process the batch and get successfully processed IDs\n        const processedIds = await processor(\n          batch.map(b => ({\n            id: b.id,\n            rowIndex: b.rowIndex,\n            rowData: b.rowData as T,\n            fieldName: b.fieldName,\n            fieldValue: b.fieldValue,\n            text1: b.text1,\n            text2: b.text2,\n            text3: b.text3,\n            text4: b.text4,\n          }))\n        );\n\n        // Mark successfully processed rows\n        if (processedIds.length > 0) {\n          await this.prisma.testmoImportStaging.updateMany({\n            where: { id: { in: processedIds } },\n            data: { processed: true },\n          });\n          processedCount += processedIds.length;\n        }\n\n        // Mark failed rows (those not in processedIds)\n        const failedIds = batch\n          .filter(b => !processedIds.includes(b.id))\n          .map(b => b.id);\n\n        if (failedIds.length > 0) {\n          await this.prisma.testmoImportStaging.updateMany({\n            where: { id: { in: failedIds } },\n            data: {\n              processed: true,\n              error: 'Processing failed',\n            },\n          });\n          errorCount += failedIds.length;\n        }\n      } catch (error) {\n        // If the entire batch fails, mark all as failed\n        const ids = batch.map(b => b.id);\n        await this.prisma.testmoImportStaging.updateMany({\n          where: { id: { in: ids } },\n          data: {\n            processed: true,\n            error: error instanceof Error ? error.message : 'Unknown error',\n          },\n        });\n        errorCount += batch.length;\n      }\n\n      // Set cursor for next batch\n      cursor = batch[batch.length - 1].id;\n\n      // Allow garbage collection between batches\n      await new Promise(resolve => setImmediate(resolve));\n    }\n\n    return { processedCount, errorCount };\n  }\n\n  /**\n   * Get count of unprocessed rows for progress tracking\n   */\n  async getUnprocessedCount(jobId: string, datasetName?: string) {\n    return this.prisma.testmoImportStaging.count({\n      where: {\n        jobId,\n        ...(datasetName && { datasetName }),\n        processed: false,\n      },\n    });\n  }\n\n  /**\n   * Get total count of rows for a dataset\n   */\n  async getTotalCount(jobId: string, datasetName?: string) {\n    return this.prisma.testmoImportStaging.count({\n      where: {\n        jobId,\n        ...(datasetName && { datasetName }),\n      },\n    });\n  }\n\n  /**\n   * Get processing statistics\n   */\n  async getProcessingStats(jobId: string, datasetName?: string) {\n    const where = {\n      jobId,\n      ...(datasetName && { datasetName }),\n    };\n\n    const [total, processed, errors] = await Promise.all([\n      this.prisma.testmoImportStaging.count({ where }),\n      this.prisma.testmoImportStaging.count({\n        where: { ...where, processed: true, error: null },\n      }),\n      this.prisma.testmoImportStaging.count({\n        where: { ...where, processed: true, error: { not: null } },\n      }),\n    ]);\n\n    return {\n      total,\n      processed,\n      errors,\n      pending: total - processed - errors,\n      percentComplete: total > 0 ? Math.round(((processed + errors) / total) * 100) : 0,\n    };\n  }\n\n  /**\n   * Get failed rows with error details\n   */\n  async getFailedRows(jobId: string, datasetName?: string, limit = 100) {\n    return this.prisma.testmoImportStaging.findMany({\n      where: {\n        jobId,\n        ...(datasetName && { datasetName }),\n        processed: true,\n        error: { not: null },\n      },\n      take: limit,\n      orderBy: { rowIndex: 'asc' },\n      select: {\n        id: true,\n        rowIndex: true,\n        datasetName: true,\n        error: true,\n        rowData: true,\n      },\n    });\n  }\n\n  /**\n   * Reset processing status for failed rows (for retry)\n   */\n  async resetFailedRows(jobId: string, datasetName?: string) {\n    return this.prisma.testmoImportStaging.updateMany({\n      where: {\n        jobId,\n        ...(datasetName && { datasetName }),\n        processed: true,\n        error: { not: null },\n      },\n      data: {\n        processed: false,\n        error: null,\n      },\n    });\n  }\n\n  /**\n   * Mark specific rows as failed with an error message\n   */\n  async markFailed(ids: string[], error: string) {\n    return this.prisma.testmoImportStaging.updateMany({\n      where: { id: { in: ids } },\n      data: {\n        processed: true,\n        error,\n      },\n    });\n  }\n\n  /**\n   * Clean up all staging data for a job\n   */\n  async cleanup(jobId: string) {\n    await Promise.all([\n      this.prisma.testmoImportStaging.deleteMany({ where: { jobId } }),\n      this.prisma.testmoImportMapping.deleteMany({ where: { jobId } }),\n    ]);\n  }\n\n  /**\n   * Clean up only processed staging data (keep mappings)\n   */\n  async cleanupProcessedStaging(jobId: string) {\n    return this.prisma.testmoImportStaging.deleteMany({\n      where: {\n        jobId,\n        processed: true,\n      },\n    });\n  }\n\n  /**\n   * Check if a job has staging data\n   */\n  async hasStagingData(jobId: string): Promise<boolean> {\n    const count = await this.prisma.testmoImportStaging.count({\n      where: { jobId },\n      take: 1,\n    });\n    return count > 0;\n  }\n\n  /**\n   * Get distinct dataset names for a job\n   */\n  async getDatasetNames(jobId: string): Promise<string[]> {\n    const results = await this.prisma.testmoImportStaging.findMany({\n      where: { jobId },\n      distinct: ['datasetName'],\n      select: { datasetName: true },\n    });\n    return results.map(r => r.datasetName);\n  }\n}\n", "const DEFAULT_LENGTH = 16;\nconst CHARSET =\n  \"ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz0123456789!@#$%^&*()-_=+\";\n\nexport const generateRandomPassword = (length = DEFAULT_LENGTH): string => {\n  const targetLength = Math.max(8, length);\n  const values =\n    typeof globalThis !== \"undefined\" && globalThis.crypto?.getRandomValues\n      ? globalThis.crypto.getRandomValues(new Uint32Array(targetLength))\n      : null;\n\n  const result: string[] = [];\n\n  if (values) {\n    for (let i = 0; i < targetLength; i += 1) {\n      const index = values[i] % CHARSET.length;\n      result.push(CHARSET[index]);\n    }\n    return result.join(\"\");\n  }\n\n  for (let i = 0; i < targetLength; i += 1) {\n    const index = Math.floor(Math.random() * CHARSET.length);\n    result.push(CHARSET[index]);\n  }\n  return result.join(\"\");\n};\n", "import type {\n  TestmoGroupMappingConfig,\n  TestmoMappingConfiguration,\n  TestmoMilestoneTypeMappingConfig,\n  TestmoConfigurationMappingConfig,\n  TestmoConfigVariantMappingConfig,\n  TestmoConfigVariantAction,\n  TestmoRoleMappingConfig,\n  TestmoStatusMappingConfig,\n  TestmoTagMappingConfig,\n  TestmoIssueTargetMappingConfig,\n  TestmoWorkflowMappingConfig,\n  TestmoRolePermissions,\n  TestmoRolePermissionConfig,\n  TestmoUserMappingConfig,\n  TestmoFieldOptionConfig,\n  TestmoTemplateFieldMappingConfig,\n  TestmoTemplateMappingConfig,\n  TestmoTemplateAction,\n} from \"./types\";\nimport type { Access } from \"@prisma/client\";\nimport { generateRandomPassword } from \"~/utils/randomPassword\";\n\nconst ACTION_MAP = new Set([\"map\", \"create\"]);\nconst CONFIG_VARIANT_ACTIONS = new Set([\n  \"map-variant\",\n  \"create-variant-existing-category\",\n  \"create-category-variant\",\n]);\n\nconst toNumber = (value: unknown): number | null => {\n  if (typeof value === \"number\" && Number.isFinite(value)) {\n    return value;\n  }\n  if (typeof value === \"bigint\") {\n    return Number(value);\n  }\n  if (typeof value === \"string\") {\n    const parsed = Number(value);\n    if (Number.isFinite(parsed)) {\n      return parsed;\n    }\n  }\n  return null;\n};\n\nconst toBoolean = (value: unknown, fallback = false): boolean => {\n  if (value === null || value === undefined) {\n    return fallback;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value !== 0;\n  }\n  if (typeof value === \"string\") {\n    const normalized = value.toLowerCase();\n    return normalized === \"1\" || normalized === \"true\" || normalized === \"yes\";\n  }\n  return fallback;\n};\n\nconst toStringValue = (value: unknown): string | undefined => {\n  if (typeof value !== \"string\") {\n    return undefined;\n  }\n  const trimmed = value.trim();\n  return trimmed.length > 0 ? trimmed : undefined;\n};\n\nconst toAccessValue = (value: unknown): Access | undefined => {\n  if (typeof value !== \"string\") {\n    return undefined;\n  }\n  const normalized = value.trim().toUpperCase();\n  switch (normalized) {\n    case \"ADMIN\":\n    case \"USER\":\n    case \"PROJECTADMIN\":\n    case \"NONE\":\n      return normalized as Access;\n    default:\n      return undefined;\n  }\n};\n\nexport const createEmptyMappingConfiguration = (): TestmoMappingConfiguration => ({\n  workflows: {},\n  statuses: {},\n  roles: {},\n  milestoneTypes: {},\n  groups: {},\n  tags: {},\n  issueTargets: {},\n  users: {},\n  configurations: {},\n  templateFields: {},\n  templates: {},\n  customFields: {},\n});\n\nexport const normalizeWorkflowConfig = (\n  value: unknown\n): TestmoWorkflowMappingConfig => {\n  const base: TestmoWorkflowMappingConfig = {\n    action: \"map\",\n    mappedTo: null,\n    workflowType: null,\n    name: null,\n    scope: null,\n    iconId: null,\n    colorId: null,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"map\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"map\";\n\n  const mappedTo = toNumber(record.mappedTo);\n  const workflowType =\n    typeof record.workflowType === \"string\"\n      ? record.workflowType\n      : typeof record.suggestedWorkflowType === \"string\"\n      ? record.suggestedWorkflowType\n      : null;\n\n  const name = typeof record.name === \"string\" ? record.name : base.name;\n  const scope = typeof record.scope === \"string\" ? record.scope : base.scope;\n  const iconId = toNumber(record.iconId);\n  const colorId = toNumber(record.colorId);\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    workflowType,\n    name: action === \"create\" ? name : undefined,\n    scope: action === \"create\" ? scope : undefined,\n    iconId: action === \"create\" ? iconId ?? null : undefined,\n    colorId: action === \"create\" ? colorId ?? null : undefined,\n  };\n};\n\nexport const normalizeStatusConfig = (\n  value: unknown\n): TestmoStatusMappingConfig => {\n  const base: TestmoStatusMappingConfig = {\n    action: \"create\",\n    mappedTo: null,\n    name: undefined,\n    systemName: undefined,\n    colorHex: undefined,\n    colorId: null,\n    aliases: undefined,\n    isSuccess: false,\n    isFailure: false,\n    isCompleted: false,\n    isEnabled: true,\n    scopeIds: [],\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"create\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"create\";\n  const mappedTo = toNumber(record.mappedTo);\n\n  const colorId = toNumber(record.colorId);\n  const scopeIds: number[] | undefined = Array.isArray(record.scopeIds)\n    ? (record.scopeIds as unknown[])\n        .map((value) => toNumber(value))\n        .filter((value): value is number => value !== null)\n    : undefined;\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    name: typeof record.name === \"string\" ? record.name : base.name,\n    systemName:\n      typeof record.systemName === \"string\"\n        ? record.systemName\n        : typeof record.system_name === \"string\"\n        ? record.system_name\n        : base.systemName,\n    colorHex: typeof record.colorHex === \"string\" ? record.colorHex : base.colorHex,\n    colorId: action === \"create\" ? colorId ?? null : undefined,\n    aliases: typeof record.aliases === \"string\" ? record.aliases : base.aliases,\n    isSuccess: toBoolean(record.isSuccess, base.isSuccess ?? false),\n    isFailure: toBoolean(record.isFailure, base.isFailure ?? false),\n    isCompleted: toBoolean(record.isCompleted, base.isCompleted ?? false),\n    isEnabled: toBoolean(record.isEnabled, base.isEnabled ?? true),\n    scopeIds: action === \"create\" ? scopeIds ?? [] : undefined,\n  };\n};\n\nexport const normalizeGroupConfig = (\n  value: unknown\n): TestmoGroupMappingConfig => {\n  const base: TestmoGroupMappingConfig = {\n    action: \"create\",\n    mappedTo: null,\n    name: undefined,\n    note: undefined,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"create\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"create\";\n  const mappedTo = toNumber(record.mappedTo);\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    name: typeof record.name === \"string\" ? record.name : base.name,\n    note: typeof record.note === \"string\" ? record.note : base.note,\n  };\n};\n\nexport const normalizeTagConfig = (\n  value: unknown\n): TestmoTagMappingConfig => {\n  const base: TestmoTagMappingConfig = {\n    action: \"create\",\n    mappedTo: null,\n    name: undefined,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"create\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"create\";\n  const mappedTo = toNumber(record.mappedTo);\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    name: typeof record.name === \"string\" ? record.name : base.name,\n  };\n};\n\nexport const normalizeIssueTargetConfig = (\n  value: unknown\n): TestmoIssueTargetMappingConfig => {\n  const base: TestmoIssueTargetMappingConfig = {\n    action: \"create\",\n    mappedTo: null,\n    name: undefined,\n    provider: null,\n    testmoType: null,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"create\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"create\";\n  const mappedTo = toNumber(record.mappedTo);\n  const testmoType = toNumber(record.testmoType ?? record.type);\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    name: typeof record.name === \"string\" ? record.name : base.name,\n    provider: typeof record.provider === \"string\" ? record.provider : base.provider,\n    testmoType: action === \"create\" ? testmoType ?? null : undefined,\n  };\n};\n\nexport const normalizeUserConfig = (\n  value: unknown\n): TestmoUserMappingConfig => {\n  const base: TestmoUserMappingConfig = {\n    action: \"map\",\n    mappedTo: null,\n    name: undefined,\n    email: undefined,\n    password: undefined,\n    access: undefined,\n    roleId: null,\n    isActive: true,\n    isApi: false,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"map\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"map\";\n\n  const mappedTo = typeof record.mappedTo === \"string\" ? record.mappedTo : null;\n  const name = toStringValue(record.name);\n  const email = toStringValue(record.email);\n  const passwordValue = toStringValue(record.password);\n  const password =\n    typeof passwordValue === \"string\" && passwordValue.length > 0\n      ? passwordValue\n      : null;\n  const access = toAccessValue(record.access);\n  const roleId = toNumber(record.roleId);\n  const isActive = toBoolean(record.isActive, true);\n  const isApi = toBoolean(record.isApi, false);\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo : undefined,\n    name: action === \"create\" ? name : undefined,\n    email: action === \"create\" ? email : undefined,\n    password:\n      action === \"create\"\n        ? password ?? generateRandomPassword()\n        : undefined,\n    access: action === \"create\" ? access : undefined,\n    roleId: action === \"create\" ? roleId ?? null : undefined,\n    isActive: action === \"create\" ? isActive : undefined,\n    isApi: action === \"create\" ? isApi : undefined,\n  };\n};\n\nconst normalizeStringArray = (value: unknown): string[] | undefined => {\n  if (!value) {\n    return undefined;\n  }\n\n  if (Array.isArray(value)) {\n    const entries = value\n      .map((entry) => {\n        if (typeof entry === \"string\") {\n          const trimmed = entry.trim();\n          return trimmed.length > 0 ? trimmed : null;\n        }\n        if (typeof entry === \"object\" && entry && \"name\" in entry) {\n          const raw = (entry as Record<string, unknown>).name;\n          if (typeof raw === \"string\") {\n            const trimmed = raw.trim();\n            return trimmed.length > 0 ? trimmed : null;\n          }\n        }\n        return null;\n      })\n      .filter((entry): entry is string => entry !== null);\n    return entries.length > 0 ? entries : undefined;\n  }\n\n  if (typeof value === \"string\") {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return undefined;\n    }\n    const segments = trimmed\n      .split(/[\\n,]+/)\n      .map((segment) => segment.trim())\n      .filter((segment) => segment.length > 0);\n    return segments.length > 0 ? segments : undefined;\n  }\n\n  return undefined;\n};\n\nconst normalizeOptionConfigList = (\n  value: unknown\n): TestmoFieldOptionConfig[] | undefined => {\n  const coerceFromStringArray = (\n    entries: string[]\n  ): TestmoFieldOptionConfig[] | undefined => {\n    if (entries.length === 0) {\n      return undefined;\n    }\n    return entries.map((name, index) => ({\n      name,\n      iconId: null,\n      iconColorId: null,\n      isEnabled: true,\n      isDefault: index === 0,\n      order: index,\n    }));\n  };\n\n  if (!value) {\n    return undefined;\n  }\n\n  if (Array.isArray(value)) {\n    const normalized: TestmoFieldOptionConfig[] = [];\n    let defaultAssigned = false;\n\n    value.forEach((entry, index) => {\n      if (typeof entry === \"string\") {\n        const trimmed = entry.trim();\n        if (trimmed.length === 0) {\n          return;\n        }\n        normalized.push({\n          name: trimmed,\n          iconId: null,\n          iconColorId: null,\n          isEnabled: true,\n          isDefault: !defaultAssigned && index === 0,\n          order: index,\n        });\n        defaultAssigned = defaultAssigned || index === 0;\n        return;\n      }\n\n      if (!entry || typeof entry !== \"object\") {\n        return;\n      }\n\n      const record = entry as Record<string, unknown>;\n      const name =\n        toStringValue(\n          record.name ??\n            record.label ??\n            record.value ??\n            record.displayName ??\n            record.display_name\n        ) ?? null;\n\n      if (!name) {\n        return;\n      }\n\n      const iconId =\n        toNumber(\n          record.iconId ?? record.icon_id ?? record.icon ?? record.iconID\n        ) ?? null;\n      const iconColorId =\n        toNumber(\n          record.iconColorId ??\n            record.icon_color_id ??\n            record.colorId ??\n            record.color_id ??\n            record.color\n        ) ?? null;\n      const isEnabled = toBoolean(\n        record.isEnabled ?? record.enabled ?? record.is_enabled,\n        true\n      );\n      const isDefault = toBoolean(\n        record.isDefault ??\n          record.default ??\n          record.is_default ??\n          record.defaultOption,\n        false\n      );\n      const order =\n        toNumber(\n          record.order ??\n            record.position ??\n            record.ordinal ??\n            record.index ??\n            record.sort\n        ) ?? index;\n\n      if (isDefault && !defaultAssigned) {\n        defaultAssigned = true;\n      }\n\n      normalized.push({\n        name,\n        iconId,\n        iconColorId,\n        isEnabled,\n        isDefault,\n        order,\n      });\n    });\n\n    if (normalized.length === 0) {\n      return undefined;\n    }\n\n    const sorted = normalized\n      .slice()\n      .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));\n\n    let defaultSeen = false;\n    sorted.forEach((entry) => {\n      if (entry.isDefault && !defaultSeen) {\n        defaultSeen = true;\n        return;\n      }\n      if (entry.isDefault && defaultSeen) {\n        entry.isDefault = false;\n      }\n    });\n\n    if (!defaultSeen) {\n      sorted[0].isDefault = true;\n    }\n\n    return sorted.map((entry, index) => ({\n      name: entry.name,\n      iconId: entry.iconId ?? null,\n      iconColorId: entry.iconColorId ?? null,\n      isEnabled: entry.isEnabled ?? true,\n      isDefault: entry.isDefault ?? false,\n      order: entry.order ?? index,\n    }));\n  }\n\n  if (typeof value === \"string\") {\n    const normalizedStrings = normalizeStringArray(value);\n    return normalizedStrings\n      ? coerceFromStringArray(normalizedStrings)\n      : undefined;\n  }\n\n  return undefined;\n};\n\nconst normalizeTemplateFieldTarget = (\n  value: unknown,\n  fallback: \"case\" | \"result\"\n): \"case\" | \"result\" => {\n  if (typeof value === \"string\") {\n    const normalized = value.trim().toLowerCase();\n    if (normalized === \"result\" || normalized === \"results\") {\n      return \"result\";\n    }\n    if (normalized === \"case\" || normalized === \"cases\") {\n      return \"case\";\n    }\n  }\n  return fallback;\n};\n\nexport const normalizeTemplateFieldConfig = (\n  value: unknown\n): TestmoTemplateFieldMappingConfig => {\n  const base: TestmoTemplateFieldMappingConfig = {\n    action: \"create\",\n    targetType: \"case\",\n    mappedTo: null,\n    displayName: undefined,\n    systemName: undefined,\n    typeId: null,\n    typeName: null,\n    hint: undefined,\n    isRequired: false,\n    isRestricted: false,\n    defaultValue: undefined,\n    isChecked: undefined,\n    minValue: undefined,\n    maxValue: undefined,\n    minIntegerValue: undefined,\n    maxIntegerValue: undefined,\n    initialHeight: undefined,\n    dropdownOptions: undefined,\n    templateName: undefined,\n    order: undefined,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : base.action;\n  const action = actionValue === \"map\" ? \"map\" : \"create\";\n\n  const targetSource =\n    record.targetType ??\n    record.target_type ??\n    record.fieldTarget ??\n    record.field_target ??\n    record.scope ??\n    record.assignment ??\n    record.fieldCategory ??\n    record.field_category;\n  const targetType = normalizeTemplateFieldTarget(targetSource, base.targetType);\n\n  const mappedTo = toNumber(record.mappedTo);\n  const typeId = toNumber(record.typeId ?? record.type_id ?? record.fieldTypeId);\n  const typeName =\n    typeof record.typeName === \"string\"\n      ? record.typeName\n      : typeof record.type_name === \"string\"\n      ? record.type_name\n      : typeof record.fieldType === \"string\"\n      ? record.fieldType\n      : typeof record.field_type === \"string\"\n      ? record.field_type\n      : base.typeName;\n\n  const dropdownOptions =\n    normalizeOptionConfigList(\n      record.dropdownOptions ??\n        record.dropdown_options ??\n        record.options ??\n        record.choices\n    ) ?? base.dropdownOptions;\n\n  return {\n    action,\n    targetType,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    displayName:\n      typeof record.displayName === \"string\"\n        ? record.displayName\n        : typeof record.display_name === \"string\"\n        ? record.display_name\n        : typeof record.label === \"string\"\n        ? record.label\n        : base.displayName,\n    systemName:\n      typeof record.systemName === \"string\"\n        ? record.systemName\n        : typeof record.system_name === \"string\"\n        ? record.system_name\n        : typeof record.name === \"string\"\n        ? record.name\n        : base.systemName,\n    typeId: typeId ?? null,\n    typeName: typeName ?? null,\n    hint:\n      typeof record.hint === \"string\"\n        ? record.hint\n        : typeof record.description === \"string\"\n        ? record.description\n        : base.hint,\n    isRequired: toBoolean(record.isRequired ?? record.is_required ?? base.isRequired),\n    isRestricted: toBoolean(record.isRestricted ?? record.is_restricted ?? base.isRestricted),\n    defaultValue:\n      typeof record.defaultValue === \"string\"\n        ? record.defaultValue\n        : typeof record.default_value === \"string\"\n        ? record.default_value\n        : base.defaultValue,\n    isChecked: typeof record.isChecked === \"boolean\" ? record.isChecked : base.isChecked,\n    minValue: toNumber(record.minValue ?? record.min_value) ?? base.minValue,\n    maxValue: toNumber(record.maxValue ?? record.max_value) ?? base.maxValue,\n    minIntegerValue:\n      toNumber(record.minIntegerValue ?? record.min_integer_value) ?? base.minIntegerValue,\n    maxIntegerValue:\n      toNumber(record.maxIntegerValue ?? record.max_integer_value) ?? base.maxIntegerValue,\n    initialHeight:\n      toNumber(record.initialHeight ?? record.initial_height) ?? base.initialHeight,\n    dropdownOptions,\n    templateName:\n      typeof record.templateName === \"string\"\n        ? record.templateName\n        : typeof record.template_name === \"string\"\n        ? record.template_name\n        : base.templateName,\n    order: toNumber(record.order ?? record.position ?? record.ordinal) ?? base.order,\n  };\n};\n\nexport const normalizeTemplateConfig = (\n  value: unknown\n): TestmoTemplateMappingConfig => {\n  const base: TestmoTemplateMappingConfig = {\n    action: \"map\",\n    mappedTo: null,\n    name: undefined,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : base.action;\n  const action = ACTION_MAP.has(actionValue)\n    ? (actionValue as TestmoTemplateAction)\n    : base.action;\n  const mappedTo = toNumber(record.mappedTo);\n  const name = typeof record.name === \"string\" ? record.name : base.name;\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    name: action === \"create\" ? name ?? undefined : undefined,\n  };\n};\n\nconst normalizeRolePermissions = (\n  value: unknown\n): TestmoRolePermissions => {\n  if (!value || typeof value !== \"object\") {\n    return {};\n  }\n\n  const result: TestmoRolePermissions = {};\n\n  const assignPermission = (area: string, source: Record<string, unknown>) => {\n    const perm: TestmoRolePermissionConfig = {\n      canAddEdit: toBoolean(source.canAddEdit ?? false),\n      canDelete: toBoolean(source.canDelete ?? false),\n      canClose: toBoolean(source.canClose ?? false),\n    };\n    result[area] = perm;\n  };\n\n  if (Array.isArray(value)) {\n    value.forEach((entry) => {\n      if (entry && typeof entry === \"object\") {\n        const record = entry as Record<string, unknown>;\n        const area = typeof record.area === \"string\" ? record.area : undefined;\n        if (area) {\n          assignPermission(area, record);\n        }\n      }\n    });\n    return result;\n  }\n\n  for (const [area, entry] of Object.entries(value as Record<string, unknown>)) {\n    if (entry && typeof entry === \"object\") {\n      assignPermission(area, entry as Record<string, unknown>);\n    }\n  }\n\n  return result;\n};\n\nexport const normalizeRoleConfig = (\n  value: unknown\n): TestmoRoleMappingConfig => {\n  const base: TestmoRoleMappingConfig = {\n    action: \"create\",\n    mappedTo: null,\n    name: undefined,\n    isDefault: false,\n    permissions: {},\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"create\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"create\";\n  const mappedTo = toNumber(record.mappedTo);\n\n  const permissions = normalizeRolePermissions(record.permissions);\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    name: typeof record.name === \"string\" ? record.name : base.name,\n    isDefault:\n      action === \"create\" ? toBoolean(record.isDefault ?? false) : undefined,\n    permissions: action === \"create\" ? permissions : undefined,\n  };\n};\n\nexport const normalizeMilestoneTypeConfig = (\n  value: unknown\n): TestmoMilestoneTypeMappingConfig => {\n  const base: TestmoMilestoneTypeMappingConfig = {\n    action: \"create\",\n    mappedTo: null,\n    name: undefined,\n    iconId: null,\n    isDefault: false,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"create\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"create\";\n  const mappedTo = toNumber(record.mappedTo);\n  const iconId = toNumber(record.iconId);\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    name: typeof record.name === \"string\" ? record.name : base.name,\n    iconId: action === \"create\" ? iconId ?? null : undefined,\n    isDefault:\n      action === \"create\" ? toBoolean(record.isDefault ?? false) : undefined,\n  };\n};\n\nconst normalizeConfigVariantConfig = (\n  key: string,\n  value: unknown\n): TestmoConfigVariantMappingConfig => {\n  const base: TestmoConfigVariantMappingConfig = {\n    token: key,\n    action: \"create-category-variant\",\n    mappedVariantId: undefined,\n    categoryId: undefined,\n    categoryName: null,\n    variantName: null,\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : base.action;\n  const action = CONFIG_VARIANT_ACTIONS.has(actionValue)\n    ? (actionValue as TestmoConfigVariantAction)\n    : base.action;\n\n  const token = typeof record.token === \"string\" ? record.token : base.token;\n  const mappedVariantId = toNumber(record.mappedVariantId);\n  const categoryId = toNumber(record.categoryId);\n  const categoryName = typeof record.categoryName === \"string\" ? record.categoryName : base.categoryName;\n  const variantName = typeof record.variantName === \"string\" ? record.variantName : base.variantName;\n\n  return {\n    token,\n    action,\n    mappedVariantId: action === \"map-variant\" ? mappedVariantId ?? null : undefined,\n    categoryId:\n      action === \"create-variant-existing-category\"\n        ? categoryId ?? null\n        : undefined,\n    categoryName: action === \"create-category-variant\" ? categoryName : undefined,\n    variantName:\n      action === \"map-variant\"\n        ? undefined\n        : variantName ?? token,\n  };\n};\n\nexport const normalizeConfigurationConfig = (\n  value: unknown\n): TestmoConfigurationMappingConfig => {\n  const base: TestmoConfigurationMappingConfig = {\n    action: \"create\",\n    mappedTo: null,\n    name: undefined,\n    variants: {},\n  };\n\n  if (!value || typeof value !== \"object\") {\n    return base;\n  }\n\n  const record = value as Record<string, unknown>;\n  const actionValue = typeof record.action === \"string\" ? record.action : \"create\";\n  const action = ACTION_MAP.has(actionValue) ? (actionValue as \"map\" | \"create\") : \"create\";\n  const mappedTo = toNumber(record.mappedTo);\n  const name = typeof record.name === \"string\" ? record.name : base.name;\n\n  const variants: Record<number, TestmoConfigVariantMappingConfig> = {};\n  if (record.variants && typeof record.variants === \"object\") {\n    for (const [variantKey, entry] of Object.entries(\n      record.variants as Record<string, unknown>\n    )) {\n      const index = Number(variantKey);\n      if (!Number.isFinite(index)) {\n        continue;\n      }\n      variants[index] = normalizeConfigVariantConfig(variantKey, entry);\n    }\n  }\n\n  return {\n    action,\n    mappedTo: action === \"map\" ? mappedTo ?? null : undefined,\n    name: action === \"create\" ? name : undefined,\n    variants,\n  };\n};\n\nexport const normalizeMappingConfiguration = (\n  value: unknown\n): TestmoMappingConfiguration => {\n  const configuration = createEmptyMappingConfiguration();\n\n  if (!value || typeof value !== \"object\") {\n    return configuration;\n  }\n\n  const record = value as Record<string, unknown>;\n\n  if (record.workflows && typeof record.workflows === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.workflows as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.workflows[id] = normalizeWorkflowConfig(entry);\n    }\n  }\n\n  if (record.statuses && typeof record.statuses === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.statuses as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.statuses[id] = normalizeStatusConfig(entry);\n    }\n  }\n\n  if (record.groups && typeof record.groups === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.groups as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.groups[id] = normalizeGroupConfig(entry);\n    }\n  }\n\n  if (record.tags && typeof record.tags === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.tags as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.tags[id] = normalizeTagConfig(entry);\n    }\n  }\n\n  if (record.issueTargets && typeof record.issueTargets === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.issueTargets as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.issueTargets[id] = normalizeIssueTargetConfig(entry);\n    }\n  }\n\n  if (record.roles && typeof record.roles === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.roles as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.roles[id] = normalizeRoleConfig(entry);\n    }\n  }\n\n  if (record.users && typeof record.users === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.users as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.users[id] = normalizeUserConfig(entry);\n    }\n  }\n\n  if (record.configurations && typeof record.configurations === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.configurations as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.configurations[id] = normalizeConfigurationConfig(entry);\n    }\n  }\n\n  if (record.templateFields && typeof record.templateFields === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.templateFields as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.templateFields[id] = normalizeTemplateFieldConfig(entry);\n    }\n  }\n\n  if (record.milestoneTypes && typeof record.milestoneTypes === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.milestoneTypes as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.milestoneTypes[id] = normalizeMilestoneTypeConfig(entry);\n    }\n  }\n\n  if (record.templates && typeof record.templates === \"object\") {\n    for (const [key, entry] of Object.entries(\n      record.templates as Record<string, unknown>\n    )) {\n      const id = Number(key);\n      if (!Number.isFinite(id)) {\n        continue;\n      }\n      configuration.templates[id] = normalizeTemplateConfig(entry);\n    }\n  }\n\n  if (record.customFields && typeof record.customFields === \"object\") {\n    configuration.customFields = JSON.parse(\n      JSON.stringify(record.customFields)\n    ) as Record<number, unknown>;\n  }\n\n  return configuration;\n};\n\nexport const serializeMappingConfiguration = (\n  configuration: TestmoMappingConfiguration\n): Record<string, unknown> => JSON.parse(JSON.stringify(configuration));\n", "/**\n * Backend-safe constants that can be used in workers and server-side code\n * This file should NOT import any frontend dependencies like lucide-react\n */\n\nexport const emptyEditorContent = {\n  type: \"doc\",\n  content: [\n    {\n      type: \"paragraph\",\n    },\n  ],\n};\n\nexport const themeColors = [\n  \"#fb7185\",\n  \"#fdba74\",\n  \"#d9f99d\",\n  \"#a7f3d0\",\n  \"#a5f3fc\",\n  \"#a5b4fc\",\n];\n\nexport const MAX_DURATION = 60 * 60 * 24 * 366 - 18 * 60 * 60; // 1 year + 1 day - 18 hours to account for leap years\n", "import { Prisma } from \"@prisma/client\";\nimport type {\n  TestmoMappingConfiguration,\n} from \"../../services/imports/testmo/types\";\n\nexport const toNumberValue = (value: unknown): number | null => {\n  if (typeof value === \"number\" && Number.isFinite(value)) {\n    return value;\n  }\n  if (typeof value === \"bigint\") {\n    return Number(value);\n  }\n  if (typeof value === \"string\") {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const parsed = Number(trimmed);\n    return Number.isFinite(parsed) ? parsed : null;\n  }\n  return null;\n};\n\nexport const toStringValue = (value: unknown): string | null => {\n  if (typeof value === \"string\") {\n    const trimmed = value.trim();\n    return trimmed.length > 0 ? trimmed : null;\n  }\n  if (typeof value === \"number\" || typeof value === \"bigint\") {\n    return String(value);\n  }\n  return null;\n};\n\nexport const toBooleanValue = (value: unknown, fallback = false): boolean => {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value !== 0;\n  }\n  if (typeof value === \"string\") {\n    const normalized = value.trim().toLowerCase();\n    if (!normalized) {\n      return fallback;\n    }\n    return normalized === \"1\" || normalized === \"true\" || normalized === \"yes\";\n  }\n  return fallback;\n};\n\nexport const toDateValue = (value: unknown): Date | null => {\n  if (value instanceof Date && !Number.isNaN(value.getTime())) {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    const trimmed = value.trim();\n    if (!trimmed) {\n      return null;\n    }\n    const normalized = trimmed.includes(\"T\")\n      ? trimmed.endsWith(\"Z\")\n        ? trimmed\n        : `${trimmed}Z`\n      : `${trimmed.replace(\" \", \"T\")}Z`;\n    const parsed = new Date(normalized);\n    return Number.isNaN(parsed.getTime()) ? null : parsed;\n  }\n  if (typeof value === \"number\") {\n    const parsed = new Date(value);\n    return Number.isNaN(parsed.getTime()) ? null : parsed;\n  }\n  return null;\n};\n\nexport const buildNumberIdMap = (\n  entries: Record<number, { mappedTo?: number | null | undefined } | undefined>\n): Map<number, number> => {\n  const map = new Map<number, number>();\n  for (const [key, entry] of Object.entries(entries ?? {})) {\n    if (!entry || entry.mappedTo === null || entry.mappedTo === undefined) {\n      continue;\n    }\n    const sourceId = toNumberValue(key);\n    const targetId = toNumberValue(entry.mappedTo);\n    if (sourceId !== null && targetId !== null) {\n      map.set(sourceId, targetId);\n    }\n  }\n  return map;\n};\n\nexport const buildStringIdMap = (\n  entries: Record<number, { mappedTo?: string | null | undefined } | undefined>\n): Map<number, string> => {\n  const map = new Map<number, string>();\n  for (const [key, entry] of Object.entries(entries ?? {})) {\n    if (!entry || !entry.mappedTo) {\n      continue;\n    }\n    const sourceId = toNumberValue(key);\n    if (sourceId !== null) {\n      map.set(sourceId, entry.mappedTo);\n    }\n  }\n  return map;\n};\n\nexport const buildTemplateFieldMaps = (\n  templateFields: TestmoMappingConfiguration[\"templateFields\"]\n) => {\n  const caseFields = new Map<string, number>();\n  const resultFields = new Map<string, number>();\n\n  for (const [key, entry] of Object.entries(templateFields ?? {})) {\n    if (!entry || entry.mappedTo === null || entry.mappedTo === undefined) {\n      continue;\n    }\n    const systemName = entry.systemName ?? entry.displayName ?? null;\n    if (!systemName) {\n      continue;\n    }\n    if (entry.targetType === \"result\") {\n      resultFields.set(systemName, entry.mappedTo);\n    } else {\n      caseFields.set(systemName, entry.mappedTo);\n    }\n  }\n\n  return { caseFields, resultFields };\n};\n\nexport const resolveUserId = (\n  userIdMap: Map<number, string>,\n  fallbackUserId: string,\n  value: unknown\n): string => {\n  const numeric = toNumberValue(value);\n  if (numeric !== null) {\n    const mapped = userIdMap.get(numeric);\n    if (mapped) {\n      return mapped;\n    }\n  }\n  return fallbackUserId;\n};\n\nexport const toInputJsonValue = (value: unknown): Prisma.InputJsonValue => {\n  const { structuredClone } = globalThis as unknown as {\n    structuredClone?: <T>(input: T) => T;\n  };\n\n  if (typeof structuredClone === \"function\") {\n    return structuredClone(value) as Prisma.InputJsonValue;\n  }\n\n  return JSON.parse(JSON.stringify(value)) as Prisma.InputJsonValue;\n};\n", "import { Prisma, ApplicationArea } from \"@prisma/client\";\nimport type {\n  TestmoMappingConfiguration,\n  TestmoConfigurationMappingConfig,\n  TestmoConfigVariantMappingConfig,\n} from \"../../services/imports/testmo/types\";\nimport { toNumberValue } from \"./helpers\";\nimport type { EntitySummaryResult } from \"./types\";\n\nconst ensureWorkflowType = (value: unknown): \"NOT_STARTED\" | \"IN_PROGRESS\" | \"DONE\" => {\n  if (value === \"NOT_STARTED\" || value === \"IN_PROGRESS\" || value === \"DONE\") {\n    return value;\n  }\n  return \"NOT_STARTED\";\n};\n\nconst ensureWorkflowScope = (\n  value: unknown\n): \"CASES\" | \"RUNS\" | \"SESSIONS\" => {\n  if (value === \"CASES\" || value === \"RUNS\" || value === \"SESSIONS\") {\n    return value;\n  }\n  return \"CASES\";\n};\n\nexport async function importWorkflows(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"workflows\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  for (const [key, config] of Object.entries(configuration.workflows ?? {})) {\n    const workflowId = Number(key);\n    if (!Number.isFinite(workflowId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Workflow ${workflowId} is configured to map but no target workflow was provided.`\n        );\n      }\n\n      const existing = await tx.workflows.findUnique({\n        where: { id: config.mappedTo },\n      });\n\n      if (!existing) {\n        throw new Error(\n          `Workflow ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      config.mappedTo = existing.id;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (config.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(\n        `Workflow ${workflowId} requires a name before it can be created.`\n      );\n    }\n\n    const iconId = config.iconId ?? null;\n    const colorId = config.colorId ?? null;\n\n    if (iconId === null || colorId === null) {\n      throw new Error(\n        `Workflow \"${name}\" must include both an icon and a color before creation.`\n      );\n    }\n\n    const workflowType = ensureWorkflowType(config.workflowType);\n    const scope = ensureWorkflowScope(config.scope);\n\n    const existingByName = await tx.workflows.findFirst({\n      where: {\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (existingByName) {\n      config.action = \"map\";\n      config.mappedTo = existingByName.id;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const created = await tx.workflows.create({\n      data: {\n        name,\n        workflowType,\n        scope,\n        iconId,\n        colorId,\n        isEnabled: true,\n      },\n    });\n\n    config.action = \"map\";\n    config.mappedTo = created.id;\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\nexport async function importGroups(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"groups\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  for (const [key, config] of Object.entries(configuration.groups ?? {})) {\n    const groupId = Number(key);\n    if (!Number.isFinite(groupId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Group ${groupId} is configured to map but no target group was provided.`\n        );\n      }\n\n      const existing = await tx.groups.findUnique({\n        where: { id: config.mappedTo },\n      });\n\n      if (!existing) {\n        throw new Error(\n          `Group ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      config.mappedTo = existing.id;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (config.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(\n        `Group ${groupId} requires a name before it can be created.`\n      );\n    }\n\n    const existing = await tx.groups.findFirst({\n      where: {\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (existing) {\n      config.action = \"map\";\n      config.mappedTo = existing.id;\n      config.name = existing.name;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const created = await tx.groups.create({\n      data: {\n        name,\n        note: (config.note ?? \"\").trim() || null,\n      },\n    });\n\n    config.action = \"map\";\n    config.mappedTo = created.id;\n    config.name = created.name;\n    config.note = created.note ?? null;\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\nexport async function importTags(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"tags\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  for (const [key, config] of Object.entries(configuration.tags ?? {})) {\n    const tagId = Number(key);\n    if (!Number.isFinite(tagId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Tag ${tagId} is configured to map but no target tag was provided.`\n        );\n      }\n\n      const existing = await tx.tags.findUnique({\n        where: { id: config.mappedTo },\n      });\n\n      if (!existing) {\n        throw new Error(\n          `Tag ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      config.mappedTo = existing.id;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (config.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(`Tag ${tagId} requires a name before it can be created.`);\n    }\n\n    const existing = await tx.tags.findFirst({\n      where: {\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (existing) {\n      config.action = \"map\";\n      config.mappedTo = existing.id;\n      config.name = existing.name;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const created = await tx.tags.create({\n      data: {\n        name,\n      },\n    });\n\n    config.action = \"map\";\n    config.mappedTo = created.id;\n    config.name = created.name;\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\nexport async function importRoles(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"roles\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  for (const [key, config] of Object.entries(configuration.roles ?? {})) {\n    const roleId = Number(key);\n    if (!Number.isFinite(roleId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Role ${roleId} is configured to map but no target role was provided.`\n        );\n      }\n\n      const existing = await tx.roles.findUnique({\n        where: { id: config.mappedTo },\n      });\n      if (!existing) {\n        throw new Error(\n          `Role ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      config.mappedTo = existing.id;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (config.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(\n        `Role ${roleId} requires a name before it can be created.`\n      );\n    }\n\n    const existing = await tx.roles.findFirst({\n      where: {\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (existing) {\n      config.action = \"map\";\n      config.mappedTo = existing.id;\n      config.name = existing.name;\n      summary.mapped += 1;\n      continue;\n    }\n\n    if (config.isDefault) {\n      await tx.roles.updateMany({\n        data: { isDefault: false },\n        where: { isDefault: true },\n      });\n    }\n\n    const created = await tx.roles.create({\n      data: {\n        name,\n        isDefault: config.isDefault ?? false,\n      },\n    });\n\n    const permissions = config.permissions ?? {};\n    const permissionEntries = Object.entries(permissions).map(\n      ([area, permission]) => ({\n        roleId: created.id,\n        area: area as ApplicationArea,\n        canAddEdit: permission?.canAddEdit ?? false,\n        canDelete: permission?.canDelete ?? false,\n        canClose: permission?.canClose ?? false,\n      })\n    );\n\n    if (permissionEntries.length > 0) {\n      await tx.rolePermission.createMany({\n        data: permissionEntries,\n        skipDuplicates: true,\n      });\n    }\n\n    config.action = \"map\";\n    config.mappedTo = created.id;\n    config.name = created.name;\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\nexport async function importMilestoneTypes(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"milestoneTypes\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  for (const [key, config] of Object.entries(\n    configuration.milestoneTypes ?? {}\n  )) {\n    const milestoneId = Number(key);\n    if (!Number.isFinite(milestoneId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Milestone type ${milestoneId} is configured to map but no target type was provided.`\n        );\n      }\n\n      const existing = await tx.milestoneTypes.findUnique({\n        where: { id: config.mappedTo },\n      });\n\n      if (!existing) {\n        throw new Error(\n          `Milestone type ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      config.mappedTo = existing.id;\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (config.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(\n        `Milestone type ${milestoneId} requires a name before it can be created.`\n      );\n    }\n\n    const existing = await tx.milestoneTypes.findFirst({\n      where: {\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (existing) {\n      config.action = \"map\";\n      config.mappedTo = existing.id;\n      config.name = existing.name;\n      summary.mapped += 1;\n      continue;\n    }\n\n    if (config.isDefault) {\n      await tx.milestoneTypes.updateMany({\n        data: { isDefault: false },\n        where: { isDefault: true },\n      });\n    }\n\n    if (config.iconId !== null && config.iconId !== undefined) {\n      const iconExists = await tx.fieldIcon.findUnique({\n        where: { id: config.iconId },\n      });\n      if (!iconExists) {\n        throw new Error(\n          `Icon ${config.iconId} configured for milestone type \"${name}\" does not exist.`\n        );\n      }\n    }\n\n    const created = await tx.milestoneTypes.create({\n      data: {\n        name,\n        iconId: config.iconId ?? null,\n        isDefault: config.isDefault ?? false,\n      },\n    });\n\n    config.action = \"map\";\n    config.mappedTo = created.id;\n    config.name = created.name;\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\nconst resolveConfigurationVariants = async (\n  tx: Prisma.TransactionClient,\n  mapping: TestmoConfigurationMappingConfig\n): Promise<{ variantIds: number[]; createdCount: number }> => {\n  const variantIds: number[] = [];\n  let createdCount = 0;\n\n  for (const [tokenIndex, variantConfig] of Object.entries(\n    mapping.variants ?? {}\n  )) {\n    const index = Number(tokenIndex);\n    if (!Number.isFinite(index) || !variantConfig) {\n      continue;\n    }\n\n    const entry = variantConfig as TestmoConfigVariantMappingConfig;\n\n    if (entry.action === \"map-variant\") {\n      if (\n        entry.mappedVariantId === null ||\n        entry.mappedVariantId === undefined\n      ) {\n        throw new Error(\n          `Configuration variant ${entry.token} is configured to map but no variant was selected.`\n        );\n      }\n\n      const existing = await tx.configVariants.findUnique({\n        where: { id: entry.mappedVariantId },\n        include: { category: true },\n      });\n\n      if (!existing) {\n        throw new Error(\n          `Configuration variant ${entry.mappedVariantId} selected for mapping was not found.`\n        );\n      }\n\n      entry.mappedVariantId = existing.id;\n      entry.categoryId = existing.categoryId;\n      entry.categoryName = existing.category.name;\n      entry.variantName = existing.name;\n      variantIds.push(existing.id);\n      continue;\n    }\n\n    if (entry.action === \"create-variant-existing-category\") {\n      if (entry.categoryId === null || entry.categoryId === undefined) {\n        throw new Error(\n          `Configuration variant ${entry.token} requires a category to be selected before creation.`\n        );\n      }\n\n      const category = await tx.configCategories.findUnique({\n        where: { id: entry.categoryId },\n      });\n\n      if (!category) {\n        throw new Error(\n          `Configuration category ${entry.categoryId} associated with variant ${entry.token} was not found.`\n        );\n      }\n\n      const variantName = (entry.variantName ?? entry.token).trim();\n      if (!variantName) {\n        throw new Error(\n          `Configuration variant ${entry.token} requires a name before it can be created.`\n        );\n      }\n\n      const existingVariant = await tx.configVariants.findFirst({\n        where: {\n          categoryId: category.id,\n          name: variantName,\n          isDeleted: false,\n        },\n      });\n\n      if (existingVariant) {\n        entry.action = \"map-variant\";\n        entry.mappedVariantId = existingVariant.id;\n        entry.categoryId = category.id;\n        entry.categoryName = category.name;\n        entry.variantName = existingVariant.name;\n        variantIds.push(existingVariant.id);\n        continue;\n      }\n\n      const createdVariant = await tx.configVariants.create({\n        data: {\n          name: variantName,\n          categoryId: category.id,\n        },\n      });\n\n      entry.action = \"map-variant\";\n      entry.mappedVariantId = createdVariant.id;\n      entry.categoryId = category.id;\n      entry.categoryName = category.name;\n      entry.variantName = createdVariant.name;\n      variantIds.push(createdVariant.id);\n      createdCount += 1;\n      continue;\n    }\n\n    if (entry.action === \"create-category-variant\") {\n      const categoryName = (entry.categoryName ?? entry.token).trim();\n      const variantName = (entry.variantName ?? entry.token).trim();\n\n      if (!categoryName) {\n        throw new Error(\n          `Configuration variant ${entry.token} requires a category name before it can be created.`\n        );\n      }\n      if (!variantName) {\n        throw new Error(\n          `Configuration variant ${entry.token} requires a variant name before it can be created.`\n        );\n      }\n\n      let category = await tx.configCategories.findFirst({\n        where: { name: categoryName, isDeleted: false },\n      });\n\n      if (!category) {\n        category = await tx.configCategories.create({\n          data: { name: categoryName },\n        });\n      }\n\n      let variant = await tx.configVariants.findFirst({\n        where: {\n          categoryId: category.id,\n          name: variantName,\n          isDeleted: false,\n        },\n      });\n\n      if (!variant) {\n        variant = await tx.configVariants.create({\n          data: {\n            name: variantName,\n            categoryId: category.id,\n          },\n        });\n        createdCount += 1;\n      }\n\n      entry.action = \"map-variant\";\n      entry.mappedVariantId = variant.id;\n      entry.categoryId = category.id;\n      entry.categoryName = category.name;\n      entry.variantName = variant.name;\n      variantIds.push(variant.id);\n      continue;\n    }\n\n    throw new Error(\n      `Unsupported configuration variant action \"${entry.action}\" for token ${entry.token}.`\n    );\n  }\n\n  return { variantIds: Array.from(new Set(variantIds)), createdCount };\n};\n\nexport async function importConfigurations(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"configurations\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n    details: {\n      variantsCreated: 0,\n    },\n  };\n\n  for (const [key, configEntry] of Object.entries(\n    configuration.configurations ?? {}\n  )) {\n    const configId = Number(key);\n    if (!Number.isFinite(configId) || !configEntry) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    const entry = configEntry as TestmoConfigurationMappingConfig;\n\n    if (entry.action === \"map\") {\n      if (entry.mappedTo === null || entry.mappedTo === undefined) {\n        throw new Error(\n          `Configuration ${configId} is configured to map but no target configuration was provided.`\n        );\n      }\n\n      const existing = await tx.configurations.findUnique({\n        where: { id: entry.mappedTo },\n      });\n\n      if (!existing) {\n        throw new Error(\n          `Configuration ${entry.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      entry.mappedTo = existing.id;\n      const { variantIds, createdCount } = await resolveConfigurationVariants(\n        tx,\n        entry\n      );\n\n      if (variantIds.length > 0) {\n        await tx.configurationConfigVariant.createMany({\n          data: variantIds.map((variantId) => ({\n            configurationId: existing.id,\n            variantId,\n          })),\n          skipDuplicates: true,\n        });\n      }\n\n      (summary.details as Record<string, unknown>).variantsCreated =\n        ((summary.details as Record<string, unknown>)\n          .variantsCreated as number) + createdCount;\n\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (entry.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(\n        `Configuration ${configId} requires a name before it can be created.`\n      );\n    }\n\n    let configurationRecord = await tx.configurations.findFirst({\n      where: {\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (!configurationRecord) {\n      configurationRecord = await tx.configurations.create({ data: { name } });\n      summary.created += 1;\n    } else {\n      summary.mapped += 1;\n    }\n\n    entry.action = \"map\";\n    entry.mappedTo = configurationRecord.id;\n    entry.name = configurationRecord.name;\n\n    const { variantIds, createdCount } = await resolveConfigurationVariants(\n      tx,\n      entry\n    );\n\n    if (variantIds.length > 0) {\n      await tx.configurationConfigVariant.createMany({\n        data: variantIds.map((variantId) => ({\n          configurationId: configurationRecord.id,\n          variantId,\n        })),\n        skipDuplicates: true,\n      });\n    }\n\n    (summary.details as Record<string, unknown>).variantsCreated =\n      ((summary.details as Record<string, unknown>).variantsCreated as number) +\n      createdCount;\n  }\n\n  return summary;\n}\n\nexport async function importUserGroups(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"userGroups\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const userGroupRows = datasetRows.get(\"user_groups\") ?? [];\n\n  for (const row of userGroupRows) {\n    summary.total += 1;\n\n    const testmoUserId = toNumberValue(row.user_id);\n    const testmoGroupId = toNumberValue(row.group_id);\n\n    if (!testmoUserId || !testmoGroupId) {\n      continue;\n    }\n\n    // Resolve the mapped user ID\n    const userConfig = configuration.users?.[testmoUserId];\n    if (!userConfig || userConfig.action !== \"map\" || !userConfig.mappedTo) {\n      // User wasn't imported/mapped, skip this group assignment\n      continue;\n    }\n\n    // Resolve the mapped group ID\n    const groupConfig = configuration.groups?.[testmoGroupId];\n    if (!groupConfig || groupConfig.action !== \"map\" || !groupConfig.mappedTo) {\n      // Group wasn't imported/mapped, skip this assignment\n      continue;\n    }\n\n    const userId = userConfig.mappedTo;\n    const groupId = groupConfig.mappedTo;\n\n    // Check if assignment already exists\n    const existing = await tx.groupAssignment.findUnique({\n      where: {\n        userId_groupId: {\n          userId,\n          groupId,\n        },\n      },\n    });\n\n    if (existing) {\n      summary.mapped += 1;\n      continue;\n    }\n\n    await tx.groupAssignment.create({\n      data: {\n        userId,\n        groupId,\n      },\n    });\n\n    summary.created += 1;\n  }\n\n  return summary;\n}\n", "import { Prisma, PrismaClient, JUnitResultType } from \"@prisma/client\";\nimport type { TestmoMappingConfiguration } from \"../../services/imports/testmo/types\";\nimport {\n  toNumberValue,\n  toStringValue,\n  toDateValue,\n  toBooleanValue,\n  resolveUserId,\n  buildNumberIdMap,\n} from \"./helpers\";\nimport type {\n  EntitySummaryResult,\n  ImportContext,\n  PersistProgressFn,\n} from \"./types\";\n\ntype AutomationCaseGroup = {\n  name: string;\n  className: string | null;\n  projectId: number;\n  testmoCaseIds: number[];\n  folder: string | null;\n  createdAt: Date | null;\n};\n\nconst projectNameCache = new Map<number, string>();\nconst templateNameCache = new Map<number, string>();\nconst workflowNameCache = new Map<number, string>();\nconst folderNameCache = new Map<number, string>();\nconst userNameCache = new Map<string, string>();\n\ntype StatusResolution = Prisma.StatusGetPayload<{\n  select: {\n    id: true;\n    name: true;\n    systemName: true;\n    aliases: true;\n    isSuccess: true;\n    isFailure: true;\n    isCompleted: true;\n  };\n}>;\n\nconst chunkArray = <T>(items: T[], chunkSize: number): T[][] => {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n\n  const chunks: T[][] = [];\n  for (let i = 0; i < items.length; i += chunkSize) {\n    chunks.push(items.slice(i, i + chunkSize));\n  }\n  return chunks;\n};\n\nasync function getProjectName(\n  tx: Prisma.TransactionClient,\n  projectId: number\n): Promise<string> {\n  if (projectNameCache.has(projectId)) {\n    return projectNameCache.get(projectId)!;\n  }\n\n  const project = await tx.projects.findUnique({\n    where: { id: projectId },\n    select: { name: true },\n  });\n\n  const name = project?.name ?? `Project ${projectId}`;\n  projectNameCache.set(projectId, name);\n  return name;\n}\n\nasync function getTemplateName(\n  tx: Prisma.TransactionClient,\n  templateId: number\n): Promise<string> {\n  if (templateNameCache.has(templateId)) {\n    return templateNameCache.get(templateId)!;\n  }\n\n  const template = await tx.templates.findUnique({\n    where: { id: templateId },\n    select: { templateName: true },\n  });\n\n  const name = template?.templateName ?? `Template ${templateId}`;\n  templateNameCache.set(templateId, name);\n  return name;\n}\n\nasync function getWorkflowName(\n  tx: Prisma.TransactionClient,\n  workflowId: number\n): Promise<string> {\n  if (workflowNameCache.has(workflowId)) {\n    return workflowNameCache.get(workflowId)!;\n  }\n\n  const workflow = await tx.workflows.findUnique({\n    where: { id: workflowId },\n    select: { name: true },\n  });\n\n  const name = workflow?.name ?? `Workflow ${workflowId}`;\n  workflowNameCache.set(workflowId, name);\n  return name;\n}\n\nasync function getFolderName(\n  tx: Prisma.TransactionClient,\n  folderId: number\n): Promise<string> {\n  if (folderNameCache.has(folderId)) {\n    return folderNameCache.get(folderId)!;\n  }\n\n  const folder = await tx.repositoryFolders.findUnique({\n    where: { id: folderId },\n    select: { name: true },\n  });\n\n  const name = folder?.name ?? \"\";\n  folderNameCache.set(folderId, name);\n  return name;\n}\n\nasync function getUserName(\n  tx: Prisma.TransactionClient,\n  userId: string | null | undefined\n): Promise<string> {\n  if (!userId) {\n    return \"Automation Import\";\n  }\n\n  if (userNameCache.has(userId)) {\n    return userNameCache.get(userId)!;\n  }\n\n  const user = await tx.user.findUnique({\n    where: { id: userId },\n    select: { name: true },\n  });\n\n  const name = user?.name ?? userId;\n  userNameCache.set(userId, name);\n  return name;\n}\n\nconst looksLikeGeneratedIdentifier = (segment: string): boolean => {\n  const lower = segment.toLowerCase();\n  if (/^[0-9a-f-]{8,}$/i.test(segment)) {\n    return true;\n  }\n  if (/^\\d{6,}$/.test(segment)) {\n    return true;\n  }\n  if (segment.includes(\":\")) {\n    return true;\n  }\n  if (segment.startsWith(\"@\")) {\n    return true;\n  }\n  if (\n    segment === lower &&\n    /[0-9]/.test(segment) &&\n    /^[a-z0-9_-]{6,}$/.test(segment)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nconst normalizeAutomationClassName = (folder: string | null): string | null => {\n  if (!folder) {\n    return null;\n  }\n\n  const segments = folder\n    .split(\".\")\n    .map((segment) => segment.trim())\n    .filter((segment) => segment.length > 0);\n\n  if (segments.length === 0) {\n    return null;\n  }\n\n  const filteredSegments = segments.filter((segment, index) => {\n    if (index === 0) {\n      // Keep the platform root segment (e.g., ios/android)\n      return true;\n    }\n    return !looksLikeGeneratedIdentifier(segment);\n  });\n\n  if (filteredSegments.length === 0) {\n    return segments[segments.length - 1] ?? null;\n  }\n\n  return filteredSegments.join(\".\");\n};\n\n/**\n * Import automation cases as repository cases with automated=true.\n * Processes data in smaller transactions to provide better progress feedback.\n */\nexport const importAutomationCases = async (\n  prisma: PrismaClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  repositoryIdMap: Map<number, number>,\n  _folderIdMap: Map<number, number>,\n  templateIdMap: Map<number, number>,\n  projectDefaultTemplateMap: Map<number, number | null>,\n  workflowIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<{\n  summary: EntitySummaryResult;\n  automationCaseIdMap: Map<number, number>;\n  automationCaseProjectMap: Map<number, Map<number, number>>;\n}> => {\n  const summary: EntitySummaryResult = {\n    entity: \"automationCases\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const automationCaseIdMap = new Map<number, number>();\n  const automationCaseProjectMap = new Map<number, Map<number, number>>();\n  const automationCaseRows = datasetRows.get(\"automation_cases\") ?? [];\n  const globalFallbackTemplateId =\n    Array.from(templateIdMap.values())[0] ?? null;\n\n  summary.total = automationCaseRows.length;\n\n  const entityName = \"automationCases\";\n  const progressEntry =\n    context.entityProgress[entityName] ??\n    (context.entityProgress[entityName] = {\n      total: summary.total,\n      created: 0,\n      mapped: 0,\n    });\n  progressEntry.total = summary.total;\n\n  let processedAutomationCases = 0;\n  let lastReportedCount = 0;\n  let lastReportAt = context.lastProgressUpdate;\n  const minProgressDelta = Math.max(1, Math.floor(summary.total / 50));\n  const minProgressIntervalMs = 2000;\n\n  const chunkSize = Math.max(1, options?.chunkSize ?? 250);\n\n  const reportProgress = async (force = false) => {\n    if (summary.total === 0) {\n      return;\n    }\n    const now = Date.now();\n    const deltaCount = processedAutomationCases - lastReportedCount;\n    if (\n      !force &&\n      deltaCount < minProgressDelta &&\n      now - lastReportAt < minProgressIntervalMs\n    ) {\n      return;\n    }\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(\n      processedAutomationCases,\n      progressEntry.total\n    );\n\n    lastReportedCount = processedAutomationCases;\n    lastReportAt = now;\n\n    const statusMessage = `Processing automation case imports (${processedAutomationCases.toLocaleString()} / ${summary.total.toLocaleString()} cases processed)`;\n    await persistProgress(entityName, statusMessage);\n  };\n\n  const repositoryCaseGroupMap = new Map<string, AutomationCaseGroup>();\n\n  for (const row of automationCaseRows) {\n    const testmoCaseId = toNumberValue(row.id);\n    const testmoProjectId = toNumberValue(row.project_id);\n\n    if (!testmoCaseId || !testmoProjectId) {\n      continue;\n    }\n\n    const projectId = projectIdMap.get(testmoProjectId);\n    if (!projectId) {\n      continue;\n    }\n\n    const name = toStringValue(row.name) || `Automation Case ${testmoCaseId}`;\n    const folder = toStringValue(row.folder);\n    const createdAt = toDateValue(row.created_at);\n\n    const className = normalizeAutomationClassName(folder);\n\n    const repoKey = `${projectId}|${name}|${className ?? \"null\"}`;\n\n    if (!repositoryCaseGroupMap.has(repoKey)) {\n      repositoryCaseGroupMap.set(repoKey, {\n        name,\n        className,\n        projectId,\n        testmoCaseIds: [],\n        folder,\n        createdAt,\n      });\n    }\n\n    const group = repositoryCaseGroupMap.get(repoKey)!;\n    group.testmoCaseIds.push(testmoCaseId);\n\n    // DEBUG: Log when multiple cases are grouped together\n    if (group.testmoCaseIds.length === 2) {\n      console.log(\n        `[CASE_GROUPING] Multiple Testmo cases mapping to same repo case:`\n      );\n      console.log(`  Key: ${repoKey}`);\n      console.log(`  TestPlanIt projectId: ${projectId}`);\n      console.log(`  Name: ${name}`);\n      console.log(`  ClassName: ${className}`);\n      console.log(`  Testmo case IDs: ${group.testmoCaseIds.join(\", \")}`);\n    } else if (group.testmoCaseIds.length > 2) {\n      console.log(\n        `[CASE_GROUPING] Adding case ${testmoCaseId} to group (now ${group.testmoCaseIds.length} cases): ${group.testmoCaseIds.join(\", \")}`\n      );\n    }\n  }\n\n  const repositoryCaseGroups = Array.from(repositoryCaseGroupMap.values());\n\n  if (repositoryCaseGroups.length === 0) {\n    await reportProgress(true);\n    return { summary, automationCaseIdMap, automationCaseProjectMap };\n  }\n\n  await prisma.$executeRawUnsafe(`\n    SELECT setval(\n      pg_get_serial_sequence('\"RepositoryCases\"', 'id'),\n      COALESCE((SELECT MAX(id) FROM \"RepositoryCases\"), 1),\n      true\n    );\n  `);\n\n  for (let index = 0; index < repositoryCaseGroups.length; index += chunkSize) {\n    const chunk = repositoryCaseGroups.slice(index, index + chunkSize);\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const group of chunk) {\n          const {\n            name,\n            className,\n            projectId,\n            testmoCaseIds,\n            folder,\n            createdAt,\n          } = group;\n          const processedForGroup = testmoCaseIds.length;\n\n          let repositoryId: number | undefined;\n          for (const [, mappedRepoId] of repositoryIdMap.entries()) {\n            const repoCheck = await tx.repositories.findFirst({\n              where: { id: mappedRepoId, projectId },\n            });\n            if (repoCheck) {\n              repositoryId = mappedRepoId;\n              break;\n            }\n          }\n\n          if (!repositoryId) {\n            let repository = await tx.repositories.findFirst({\n              where: {\n                projectId,\n                isActive: true,\n                isDeleted: false,\n                isArchived: false,\n              },\n              orderBy: { id: \"asc\" },\n            });\n\n            if (!repository) {\n              repository = await tx.repositories.create({\n                data: {\n                  projectId,\n                  isActive: true,\n                  isDeleted: false,\n                  isArchived: false,\n                },\n              });\n            }\n            repositoryId = repository.id;\n          }\n\n          let folderId: number | undefined;\n          let folderNameForVersion: string | null = null;\n\n          // First, ensure the top-level \"Automation\" folder exists\n          let automationRootFolder = await tx.repositoryFolders.findFirst({\n            where: {\n              projectId,\n              repositoryId,\n              parentId: null,\n              name: \"Automation\",\n              isDeleted: false,\n            },\n          });\n\n          if (!automationRootFolder) {\n            automationRootFolder = await tx.repositoryFolders.create({\n              data: {\n                projectId,\n                repositoryId,\n                parentId: null,\n                name: \"Automation\",\n                creatorId: configuration.users?.[1]?.mappedTo || \"unknown\",\n              },\n            });\n          }\n\n          // Start folder hierarchy under the \"Automation\" root folder\n          let currentParentId: number | null = automationRootFolder.id;\n\n          if (folder) {\n            const folderParts = folder.split(\".\");\n\n            for (const folderName of folderParts) {\n              if (!folderName) continue;\n\n              const existing: any = await tx.repositoryFolders.findFirst({\n                where: {\n                  projectId,\n                  repositoryId,\n                  parentId: currentParentId,\n                  name: folderName,\n                  isDeleted: false,\n                },\n              });\n\n              const current: any =\n                existing ||\n                (await tx.repositoryFolders.create({\n                  data: {\n                    projectId,\n                    repositoryId,\n                    parentId: currentParentId,\n                    name: folderName,\n                    creatorId: configuration.users?.[1]?.mappedTo || \"unknown\",\n                  },\n                }));\n\n              currentParentId = current.id;\n              folderId = current.id;\n            }\n\n            if (folderParts.length > 0) {\n              folderNameForVersion =\n                folderParts[folderParts.length - 1] || null;\n            }\n          }\n\n          // If no folder was specified or the hierarchy is empty, use the root \"Automation\" folder\n          if (!folderId) {\n            folderId = automationRootFolder.id;\n            folderNameForVersion = \"Automation\";\n          }\n\n          let defaultTemplateId =\n            projectDefaultTemplateMap.get(projectId) ?? null;\n          if (!defaultTemplateId) {\n            const fallbackAssignment =\n              await tx.templateProjectAssignment.findFirst({\n                where: { projectId },\n                select: { templateId: true },\n                orderBy: { templateId: \"asc\" },\n              });\n            defaultTemplateId = fallbackAssignment?.templateId ?? null;\n          }\n          if (!defaultTemplateId) {\n            defaultTemplateId = globalFallbackTemplateId;\n          }\n          if (!defaultTemplateId) {\n            // Unable to resolve a template for this project; skip importing these cases\n            processedAutomationCases += processedForGroup;\n            context.processedCount += processedForGroup;\n            continue;\n          }\n\n          const resolvedTemplateId = defaultTemplateId;\n\n          const defaultWorkflowId =\n            Array.from(workflowIdMap.values()).find((id) => id !== undefined) ||\n            1;\n          const normalizedClassName = className || null;\n\n          let repositoryCase = await tx.repositoryCases.findFirst({\n            where: {\n              projectId,\n              name,\n              className: normalizedClassName,\n              source: \"JUNIT\",\n              isDeleted: false,\n            },\n          });\n\n          if (!repositoryCase && normalizedClassName) {\n            repositoryCase = await tx.repositoryCases.findFirst({\n              where: {\n                projectId,\n                name,\n                source: \"JUNIT\",\n                isDeleted: false,\n              },\n            });\n          }\n\n          if (repositoryCase) {\n            if (\n              normalizedClassName &&\n              repositoryCase.className !== normalizedClassName\n            ) {\n              repositoryCase = await tx.repositoryCases.update({\n                where: { id: repositoryCase.id },\n                data: {\n                  className: normalizedClassName,\n                },\n              });\n            }\n\n            repositoryCase = await tx.repositoryCases.update({\n              where: { id: repositoryCase.id },\n              data: {\n                automated: true,\n                isDeleted: false,\n                isArchived: false,\n                stateId: defaultWorkflowId,\n                templateId: resolvedTemplateId,\n                folderId,\n                repositoryId,\n              },\n            });\n            for (const testmoCaseId of testmoCaseIds) {\n              automationCaseIdMap.set(testmoCaseId, repositoryCase.id);\n              let projectMap = automationCaseProjectMap.get(projectId);\n              if (!projectMap) {\n                projectMap = new Map<number, number>();\n                automationCaseProjectMap.set(projectId, projectMap);\n              }\n              projectMap.set(testmoCaseId, repositoryCase.id);\n            }\n            summary.mapped += testmoCaseIds.length;\n          } else {\n            repositoryCase = await tx.repositoryCases.create({\n              data: {\n                projectId,\n                repositoryId,\n                folderId,\n                name,\n                className: normalizedClassName,\n                source: \"JUNIT\",\n                automated: true,\n                stateId: defaultWorkflowId,\n                templateId: resolvedTemplateId,\n                creatorId: configuration.users?.[1]?.mappedTo || \"unknown\",\n                createdAt: createdAt || new Date(),\n              },\n            });\n            for (const testmoCaseId of testmoCaseIds) {\n              automationCaseIdMap.set(testmoCaseId, repositoryCase.id);\n              let projectMap = automationCaseProjectMap.get(projectId);\n              if (!projectMap) {\n                projectMap = new Map<number, number>();\n                automationCaseProjectMap.set(projectId, projectMap);\n              }\n              projectMap.set(testmoCaseId, repositoryCase.id);\n            }\n            summary.created += 1;\n\n            const projectName = await getProjectName(tx, projectId);\n            const templateName = await getTemplateName(tx, resolvedTemplateId);\n            const workflowName = await getWorkflowName(tx, defaultWorkflowId);\n            const resolvedFolderName =\n              folderNameForVersion ?? (await getFolderName(tx, folderId));\n            const creatorName = await getUserName(tx, repositoryCase.creatorId);\n\n            const caseVersion = await tx.repositoryCaseVersions.create({\n              data: {\n                repositoryCase: { connect: { id: repositoryCase.id } },\n                project: { connect: { id: projectId } },\n                staticProjectId: projectId,\n                staticProjectName: projectName,\n                repositoryId,\n                folderId,\n                folderName: resolvedFolderName ?? \"\",\n                templateId: resolvedTemplateId,\n                templateName,\n                name,\n                stateId: defaultWorkflowId,\n                stateName: workflowName,\n                estimate: repositoryCase.estimate ?? null,\n                forecastManual: null,\n                forecastAutomated: null,\n                order: repositoryCase.order ?? 0,\n                createdAt: repositoryCase.createdAt ?? new Date(),\n                creatorId: repositoryCase.creatorId,\n                creatorName,\n                automated: true,\n                isArchived: repositoryCase.isArchived,\n                isDeleted: repositoryCase.isDeleted,\n                version: repositoryCase.currentVersion,\n                steps: Prisma.JsonNull,\n                tags: [],\n                issues: [],\n                links: [],\n                attachments: [],\n              },\n            });\n\n            const caseFieldValues = await tx.caseFieldValues.findMany({\n              where: { testCaseId: repositoryCase.id },\n              include: {\n                field: {\n                  select: {\n                    displayName: true,\n                    systemName: true,\n                  },\n                },\n              },\n            });\n\n            if (caseFieldValues.length > 0) {\n              await tx.caseFieldVersionValues.createMany({\n                data: caseFieldValues.map((fieldValue) => ({\n                  versionId: caseVersion.id,\n                  field:\n                    fieldValue.field.displayName || fieldValue.field.systemName,\n                  value: fieldValue.value ?? Prisma.JsonNull,\n                })),\n              });\n            }\n          }\n\n          processedAutomationCases += processedForGroup;\n          context.processedCount += processedForGroup;\n\n          progressEntry.created = summary.created;\n          progressEntry.mapped = Math.min(\n            processedAutomationCases,\n            progressEntry.total\n          );\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    await reportProgress(true);\n  }\n\n  progressEntry.created = summary.created;\n  progressEntry.mapped = summary.mapped;\n\n  return { summary, automationCaseIdMap, automationCaseProjectMap };\n};\n\n/**\n * Import automation runs as test runs with testRunType='JUNIT'\n * Similar to JUnit XML import which creates test runs\n *\n * Maps Testmo automation_runs to TestPlanIt TestRuns:\n * - Sets testRunType=\"JUNIT\"\n * - Maps configuration and milestone\n */\nexport const importAutomationRuns = async (\n  prisma: PrismaClient,\n  _configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  configurationIdMap: Map<number, number>,\n  milestoneIdMap: Map<number, number>,\n  workflowIdMap: Map<number, number>,\n  userIdMap: Map<number, string>,\n  defaultUserId: string,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<{\n  summary: EntitySummaryResult;\n  testRunIdMap: Map<number, number>;\n  testSuiteIdMap: Map<number, number>;\n  testRunTimestampMap: Map<number, Date>;\n  testRunProjectIdMap: Map<number, number>;\n  testRunTestmoProjectIdMap: Map<number, number>;\n}> => {\n  const summary: EntitySummaryResult = {\n    entity: \"automationRuns\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const testRunIdMap = new Map<number, number>();\n  const testSuiteIdMap = new Map<number, number>();\n  const testRunTimestampMap = new Map<number, Date>(); // Map testmoRunId to executedAt timestamp\n  const testRunProjectIdMap = new Map<number, number>(); // Map testmoRunId to TestPlanIt projectId\n  const testRunTestmoProjectIdMap = new Map<number, number>(); // Map testmoRunId to Testmo projectId\n  const automationRunRows = datasetRows.get(\"automation_runs\") ?? [];\n\n  summary.total = automationRunRows.length;\n\n  const entityName = \"automationRuns\";\n  const progressEntry =\n    context.entityProgress[entityName] ??\n    (context.entityProgress[entityName] = {\n      total: summary.total,\n      created: 0,\n      mapped: 0,\n    });\n  progressEntry.total = summary.total;\n\n  let processedRuns = 0;\n  let lastReportedCount = 0;\n  let lastReportAt = context.lastProgressUpdate;\n  const minProgressDelta = Math.max(1, Math.floor(summary.total / 50));\n  const minProgressIntervalMs = 2000;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 250);\n\n  const reportProgress = async (force = false) => {\n    if (summary.total === 0) {\n      return;\n    }\n    const now = Date.now();\n    const deltaCount = processedRuns - lastReportedCount;\n    if (\n      !force &&\n      deltaCount < minProgressDelta &&\n      now - lastReportAt < minProgressIntervalMs\n    ) {\n      return;\n    }\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedRuns, progressEntry.total);\n\n    lastReportedCount = processedRuns;\n    lastReportAt = now;\n\n    const statusMessage = `Processing automation run imports (${processedRuns.toLocaleString()} / ${summary.total.toLocaleString()} runs processed)`;\n    await persistProgress(entityName, statusMessage);\n  };\n\n  if (automationRunRows.length === 0) {\n    await reportProgress(true);\n    return {\n      summary,\n      testRunIdMap,\n      testSuiteIdMap,\n      testRunTimestampMap,\n      testRunProjectIdMap,\n      testRunTestmoProjectIdMap,\n    };\n  }\n\n  const defaultWorkflowId =\n    Array.from(workflowIdMap.values()).find((id) => id !== undefined) || 1;\n\n  for (let index = 0; index < automationRunRows.length; index += chunkSize) {\n    const chunk = automationRunRows.slice(index, index + chunkSize);\n    let processedInChunk = 0;\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          const testmoRunId = toNumberValue(row.id);\n          const testmoProjectId = toNumberValue(row.project_id);\n          const testmoConfigId = toNumberValue(row.config_id);\n          const testmoMilestoneId = toNumberValue(row.milestone_id);\n          const testmoCreatedBy = toNumberValue(row.created_by);\n\n          processedInChunk += 1;\n\n          if (!testmoRunId || !testmoProjectId) {\n            continue;\n          }\n\n          const projectId = projectIdMap.get(testmoProjectId);\n          if (!projectId) {\n            continue;\n          }\n\n          const name =\n            toStringValue(row.name) || `Automation Run ${testmoRunId}`;\n          const configId = testmoConfigId\n            ? configurationIdMap.get(testmoConfigId)\n            : undefined;\n          const milestoneId = testmoMilestoneId\n            ? milestoneIdMap.get(testmoMilestoneId)\n            : undefined;\n          const createdById = resolveUserId(\n            userIdMap,\n            defaultUserId,\n            testmoCreatedBy\n          );\n          const createdAt = toDateValue(row.created_at);\n          const completedAt = toDateValue(row.completed_at);\n          const elapsedMicroseconds = toNumberValue(row.elapsed);\n          const totalCount = toNumberValue(row.total_count) || 0;\n          const testmoIsCompleted =\n            row.is_completed !== undefined\n              ? toBooleanValue(row.is_completed)\n              : true;\n\n          const elapsed = elapsedMicroseconds\n            ? Math.round(elapsedMicroseconds / 1_000_000)\n            : null;\n          const resolvedCompletedAt =\n            completedAt || (testmoIsCompleted ? createdAt || new Date() : null);\n\n          const testRun = await tx.testRuns.create({\n            data: {\n              name,\n              projectId,\n              stateId: defaultWorkflowId,\n              configId: configId || null,\n              milestoneId: milestoneId || null,\n              testRunType: \"JUNIT\",\n              createdById,\n              createdAt: createdAt || new Date(),\n              completedAt: resolvedCompletedAt || null,\n              isCompleted: testmoIsCompleted,\n              elapsed: elapsed,\n            },\n          });\n\n          const testSuite = await tx.jUnitTestSuite.create({\n            data: {\n              name,\n              time: elapsed || 0,\n              tests: totalCount,\n              testRunId: testRun.id,\n              createdById,\n              timestamp: createdAt || new Date(),\n            },\n          });\n\n          testRunIdMap.set(testmoRunId, testRun.id);\n          testSuiteIdMap.set(testmoRunId, testSuite.id);\n          testRunTimestampMap.set(\n            testmoRunId,\n            resolvedCompletedAt || createdAt || new Date()\n          );\n          testRunProjectIdMap.set(testmoRunId, projectId);\n          testRunTestmoProjectIdMap.set(testmoRunId, testmoProjectId);\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    processedRuns += processedInChunk;\n    context.processedCount += processedInChunk;\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedRuns, progressEntry.total);\n\n    await reportProgress(true);\n  }\n\n  await reportProgress(true);\n\n  progressEntry.created = summary.created;\n  progressEntry.mapped = Math.min(processedRuns, progressEntry.total);\n\n  return {\n    summary,\n    testRunIdMap,\n    testSuiteIdMap,\n    testRunTimestampMap,\n    testRunProjectIdMap,\n    testRunTestmoProjectIdMap,\n  };\n};\n\n/**\n * Import automation_run_tests as TestRunCases and JUnitTestResults\n * Similar to JUnit XML import which creates test run cases and results\n *\n * Maps Testmo automation_run_tests to TestPlanIt:\n * - Creates TestRunCases (links test run to repository case)\n * - Creates JUnitTestResult records with status mapping\n * - Handles status mapping via Automation scope statuses\n */\nexport const importAutomationRunTests = async (\n  prisma: PrismaClient,\n  _configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  testRunIdMap: Map<number, number>,\n  testSuiteIdMap: Map<number, number>,\n  testRunTimestampMap: Map<number, Date>,\n  testRunProjectIdMap: Map<number, number>,\n  testRunTestmoProjectIdMap: Map<number, number>,\n  automationCaseProjectMap: Map<number, Map<number, number>>,\n  statusIdMap: Map<number, number>,\n  _userIdMap: Map<number, string>,\n  defaultUserId: string,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<{\n  summary: EntitySummaryResult;\n  testRunCaseIdMap: Map<number, number>;\n  junitResultIdMap: Map<number, number>;\n}> => {\n  const summary: EntitySummaryResult = {\n    entity: \"automationRunTests\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const testRunCaseIdMap = new Map<number, number>();\n  const junitResultIdMap = new Map<number, number>();\n  const automationRunTestRows = datasetRows.get(\"automation_run_tests\") ?? [];\n\n  summary.total = automationRunTestRows.length;\n\n  const statusCache = new Map<number, StatusResolution>();\n\n  const fetchStatusById = async (\n    tx: Prisma.TransactionClient,\n    statusId: number\n  ): Promise<StatusResolution | null> => {\n    if (statusCache.has(statusId)) {\n      return statusCache.get(statusId)!;\n    }\n\n    const status = await tx.status.findUnique({\n      where: { id: statusId },\n      select: {\n        id: true,\n        name: true,\n        systemName: true,\n        aliases: true,\n        isSuccess: true,\n        isFailure: true,\n        isCompleted: true,\n      },\n    });\n\n    if (status) {\n      statusCache.set(statusId, status);\n    }\n\n    return status ?? null;\n  };\n\n  const determineJUnitResultType = (\n    resolvedStatus: StatusResolution | null,\n    rawStatusName: string | null\n  ): JUnitResultType => {\n    const candidates = new Set<string>();\n    const pushCandidate = (value: string | null | undefined) => {\n      if (!value) {\n        return;\n      }\n      const normalized = value.trim().toLowerCase();\n      if (normalized.length > 0) {\n        candidates.add(normalized);\n      }\n    };\n\n    pushCandidate(rawStatusName);\n    pushCandidate(resolvedStatus?.systemName);\n    pushCandidate(resolvedStatus?.name);\n\n    if (resolvedStatus?.aliases) {\n      resolvedStatus.aliases\n        .split(\",\")\n        .map((alias) => alias.trim())\n        .forEach((alias) => pushCandidate(alias));\n    }\n\n    const hasCandidateIncluding = (...needles: string[]): boolean => {\n      for (const candidate of candidates) {\n        for (const needle of needles) {\n          if (candidate.includes(needle)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    if (hasCandidateIncluding(\"skip\", \"skipped\", \"block\", \"blocked\", \"omit\")) {\n      return JUnitResultType.SKIPPED;\n    }\n\n    if (hasCandidateIncluding(\"error\", \"exception\")) {\n      return JUnitResultType.ERROR;\n    }\n\n    if (resolvedStatus?.isFailure || hasCandidateIncluding(\"fail\", \"failed\")) {\n      return JUnitResultType.FAILURE;\n    }\n\n    if (resolvedStatus?.isSuccess) {\n      return JUnitResultType.PASSED;\n    }\n\n    return JUnitResultType.PASSED;\n  };\n\n  const entityName = \"automationRunTests\";\n  const progressEntry =\n    context.entityProgress[entityName] ??\n    (context.entityProgress[entityName] = {\n      total: summary.total,\n      created: 0,\n      mapped: 0,\n    });\n  progressEntry.total = summary.total;\n\n  let processedTests = 0;\n  let lastReportedCount = 0;\n  let lastReportAt = context.lastProgressUpdate;\n  const minProgressDelta = Math.max(1, Math.floor(summary.total / 50));\n  const minProgressIntervalMs = 2000;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 250);\n\n  const reportProgress = async (force = false) => {\n    if (summary.total === 0) {\n      return;\n    }\n    const now = Date.now();\n    const deltaCount = processedTests - lastReportedCount;\n    if (\n      !force &&\n      deltaCount < minProgressDelta &&\n      now - lastReportAt < minProgressIntervalMs\n    ) {\n      return;\n    }\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedTests, progressEntry.total);\n\n    lastReportedCount = processedTests;\n    lastReportAt = now;\n\n    const statusMessage = `Processing automation run test imports (${processedTests.toLocaleString()} / ${summary.total.toLocaleString()} tests processed)`;\n    await persistProgress(entityName, statusMessage);\n  };\n\n  if (automationRunTestRows.length === 0) {\n    await reportProgress(true);\n    return { summary, testRunCaseIdMap, junitResultIdMap };\n  }\n\n  const findAutomationStatus = async (\n    tx: Prisma.TransactionClient,\n    testmoStatusId: number | null,\n    projectId: number,\n    statusName: string | null\n  ): Promise<StatusResolution | null> => {\n    if (testmoStatusId && statusIdMap.has(testmoStatusId)) {\n      const mappedStatusId = statusIdMap.get(testmoStatusId);\n      if (mappedStatusId) {\n        const mappedStatus = await fetchStatusById(tx, mappedStatusId);\n        if (mappedStatus) {\n          return mappedStatus;\n        }\n      }\n    }\n\n    const select = {\n      id: true,\n      name: true,\n      systemName: true,\n      aliases: true,\n      isSuccess: true,\n      isFailure: true,\n      isCompleted: true,\n    } as const;\n\n    if (statusName) {\n      const normalizedStatus = statusName.toLowerCase();\n      const status = await tx.status.findFirst({\n        select,\n        where: {\n          isEnabled: true,\n          isDeleted: false,\n          projects: { some: { projectId } },\n          scope: { some: { scope: { name: \"Automation\" } } },\n          OR: [\n            {\n              systemName: {\n                equals: normalizedStatus,\n                mode: \"insensitive\",\n              },\n            },\n            { aliases: { contains: normalizedStatus } },\n          ],\n        },\n      });\n      if (status) {\n        statusCache.set(status.id, status);\n        return status;\n      }\n    }\n\n    const untestedStatus = await tx.status.findFirst({\n      select,\n      where: {\n        isEnabled: true,\n        isDeleted: false,\n        systemName: { equals: \"untested\", mode: \"insensitive\" },\n        projects: { some: { projectId } },\n        scope: { some: { scope: { name: \"Automation\" } } },\n      },\n    });\n\n    if (untestedStatus) {\n      statusCache.set(untestedStatus.id, untestedStatus);\n    }\n\n    return untestedStatus ?? null;\n  };\n\n  for (\n    let index = 0;\n    index < automationRunTestRows.length;\n    index += chunkSize\n  ) {\n    const chunk = automationRunTestRows.slice(index, index + chunkSize);\n    let processedInChunk = 0;\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          const testmoRunTestId = toNumberValue(row.id);\n          const testmoRunId = toNumberValue(row.run_id);\n          const testmoProjectId = toNumberValue(row.project_id);\n          const testmoCaseId = toNumberValue(row.case_id);\n          const testmoStatusId = toNumberValue(row.status_id);\n\n          processedInChunk += 1;\n\n          if (!testmoRunTestId || !testmoRunId || !testmoProjectId) {\n            continue;\n          }\n\n          // Skip duplicate tests (same testmoRunTestId already processed)\n          if (junitResultIdMap.has(testmoRunTestId)) {\n            continue;\n          }\n\n          const testRunId = testRunIdMap.get(testmoRunId);\n          const testSuiteId = testSuiteIdMap.get(testmoRunId);\n          const testRunProjectId = testRunProjectIdMap.get(testmoRunId);\n          const testRunTestmoProjectId =\n            testRunTestmoProjectIdMap.get(testmoRunId);\n\n          // For incremental imports, testRunProjectId might not be in the map (run already existed).\n          // In that case, look it up from the database.\n          let actualTestRunProjectId = testRunProjectId;\n          if (!actualTestRunProjectId && testRunId) {\n            const existingRun = await tx.testRuns.findUnique({\n              where: { id: testRunId },\n              select: { projectId: true },\n            });\n            actualTestRunProjectId = existingRun?.projectId;\n          }\n\n          // Look up the case across ALL projects in the map\n          // We need to find which project this Testmo case was imported into\n          let repositoryCaseId: number | undefined;\n          let actualCaseProjectId: number | undefined;\n\n          if (testmoCaseId) {\n            // Search through all projects in the map to find this case\n            for (const [\n              projectId,\n              caseMap,\n            ] of automationCaseProjectMap.entries()) {\n              if (typeof (caseMap as any).get === \"function\") {\n                const caseId = (caseMap as Map<number, number>).get(\n                  testmoCaseId\n                );\n                if (caseId) {\n                  repositoryCaseId = caseId;\n                  actualCaseProjectId = projectId;\n                  if (summary.created < 5) {\n                    console.log(\n                      `[FOUND_IN_MAP] testmoCaseId=${testmoCaseId} \u2192 caseId=${caseId}, project=${projectId}, runProject=${actualTestRunProjectId}`\n                    );\n                  }\n                  break;\n                }\n              }\n            }\n          }\n\n          // For incremental imports, if case not in map, look it up from database\n          // IMPORTANT: Must search within the SAME project as the test run to avoid cross-project linking\n          if (!repositoryCaseId && testmoCaseId && actualTestRunProjectId) {\n            const testName = toStringValue(row.name);\n            if (testName) {\n              // Search for cases with matching name in the SAME project as the test run\n              const existingCase = await tx.repositoryCases.findFirst({\n                where: {\n                  projectId: actualTestRunProjectId, // CRITICAL: Only search in run's project\n                  name: testName,\n                  source: \"JUNIT\",\n                },\n                select: { id: true, projectId: true },\n              });\n              if (existingCase) {\n                repositoryCaseId = existingCase.id;\n                actualCaseProjectId = existingCase.projectId;\n                if (summary.created < 5) {\n                  console.log(\n                    `[FALLBACK] testmoCaseId=${testmoCaseId}, name=${testName.substring(0, 50)} \u2192 caseId=${repositoryCaseId}, project=${actualCaseProjectId}, runProject=${actualTestRunProjectId}`\n                  );\n                }\n              }\n            }\n          }\n\n          // Comprehensive logging for debugging\n          if (summary.created < 20) {\n            console.log(\n              `[DEBUG #${summary.created}] testmoRunId=${testmoRunId}, testmoCaseId=${testmoCaseId}`\n            );\n            console.log(\n              `  testRunId=${testRunId}, testSuiteId=${testSuiteId}, repositoryCaseId=${repositoryCaseId}`\n            );\n            console.log(\n              `  actualTestRunProjectId=${actualTestRunProjectId}, actualCaseProjectId=${actualCaseProjectId}`\n            );\n            console.log(\n              `  testRunProjectId from map=${testRunProjectIdMap.get(testmoRunId)}`\n            );\n          }\n\n          if (\n            !testRunId ||\n            !testSuiteId ||\n            !repositoryCaseId ||\n            !actualTestRunProjectId ||\n            !actualCaseProjectId\n          ) {\n            // Skip if we don't have all required IDs including the case's project\n            if (summary.created < 10) {\n              console.log(\n                `[SKIP-MISSING] Missing IDs: testRunId=${testRunId}, testSuiteId=${testSuiteId}, repositoryCaseId=${repositoryCaseId}, actualTestRunProjectId=${actualTestRunProjectId}, actualCaseProjectId=${actualCaseProjectId}`\n              );\n            }\n            continue;\n          }\n\n          // CRITICAL: Validate that the case's project matches the test run's project\n          // This prevents cross-project contamination\n          // Use strict equality with explicit type checking\n          const caseProjectNum = Number(actualCaseProjectId);\n          const runProjectNum = Number(actualTestRunProjectId);\n\n          if (caseProjectNum !== runProjectNum) {\n            // Skip this result - case belongs to a different project than the test run\n            console.log(\n              `[SKIP] Cross-project test #${summary.created}: testmoCaseId=${testmoCaseId}, testmoRunId=${testmoRunId}, caseProject=${caseProjectNum} (type: ${typeof actualCaseProjectId}), runProject=${runProjectNum} (type: ${typeof actualTestRunProjectId})`\n            );\n            continue;\n          }\n\n          // At this point, we've validated that actualCaseProjectId === actualTestRunProjectId\n          // so we can safely create the result\n\n          const statusName = toStringValue(row.status);\n          const elapsedMicroseconds = toNumberValue(row.elapsed);\n          const file = toStringValue(row.file);\n          const line = toStringValue(row.line);\n          const assertions = toNumberValue(row.assertions);\n\n          const elapsed = elapsedMicroseconds\n            ? Math.round(elapsedMicroseconds / 1_000_000)\n            : null;\n\n          const resolvedStatus = await findAutomationStatus(\n            tx,\n            testmoStatusId,\n            actualTestRunProjectId,\n            statusName\n          );\n          const statusId = resolvedStatus?.id ?? null;\n\n          const testRunCase = await tx.testRunCases.upsert({\n            where: {\n              testRunId_repositoryCaseId: {\n                testRunId,\n                repositoryCaseId,\n              },\n            },\n            update: {\n              statusId: statusId ?? undefined,\n              elapsed: elapsed,\n              isCompleted: !!statusId,\n              completedAt: statusId ? new Date() : null,\n            },\n            create: {\n              testRunId,\n              repositoryCaseId,\n              statusId: statusId ?? undefined,\n              elapsed: elapsed,\n              order: summary.created + 1,\n              isCompleted: !!statusId,\n              completedAt: statusId ? new Date() : null,\n            },\n          });\n\n          testRunCaseIdMap.set(testmoRunTestId, testRunCase.id);\n\n          const resultType = determineJUnitResultType(resolvedStatus, statusName);\n\n          const executedAt = testRunTimestampMap.get(testmoRunId) || new Date();\n\n          // Log first few result creations for debugging\n          if (summary.created < 10) {\n            console.log(\n              `[CREATE] Result #${summary.created + 1}: testmoCaseId=${testmoCaseId}, testmoRunId=${testmoRunId}, caseId=${repositoryCaseId}, caseProject=${actualCaseProjectId}, runId=${testRunId}, runProject=${actualTestRunProjectId}, suiteId=${testSuiteId}`\n            );\n          }\n\n          // Special logging for case 69305 to debug cross-project issue\n          if (repositoryCaseId === 69305) {\n            console.log(\n              `[CASE_69305] Creating result: testmoCaseId=${testmoCaseId}, testmoRunId=${testmoRunId}, testmoProjectId=${testmoProjectId}, testRunTestmoProjectId=${testRunTestmoProjectId}, caseId=${repositoryCaseId}, caseProject=${actualCaseProjectId}, runId=${testRunId}, runProject=${actualTestRunProjectId}, suiteId=${testSuiteId}`\n            );\n          }\n\n          const junitResult = await tx.jUnitTestResult.create({\n            data: {\n              repositoryCaseId,\n              testSuiteId,\n              type: resultType,\n              statusId: statusId ?? undefined,\n              time: elapsed || undefined,\n              assertions: assertions || undefined,\n              file: file || undefined,\n              line: line ? parseInt(line) : undefined,\n              createdById: defaultUserId,\n              executedAt,\n            },\n          });\n\n          junitResultIdMap.set(testmoRunTestId, junitResult.id);\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    processedTests += processedInChunk;\n    context.processedCount += processedInChunk;\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedTests, progressEntry.total);\n\n    await reportProgress(true);\n  }\n\n  await reportProgress(true);\n\n  const suiteIdsToUpdate = Array.from(testSuiteIdMap.values());\n  if (suiteIdsToUpdate.length > 0) {\n    await prisma.$transaction(\n      async (tx) => {\n        await reconcileLegacyJUnitSuiteLinks(tx, suiteIdsToUpdate);\n        await recomputeJUnitSuiteStats(tx, suiteIdsToUpdate);\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n  }\n\n  progressEntry.created = summary.created;\n  progressEntry.mapped = Math.min(processedTests, progressEntry.total);\n\n  return { summary, testRunCaseIdMap, junitResultIdMap };\n};\n\n/**\n * Import automation_run_fields as custom fields stored in TestRuns.note (JSON)\n * Stores key-value metadata like Version, Build info, etc.\n */\nexport const importAutomationRunFields = async (\n  prisma: PrismaClient,\n  _configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  testRunIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"automationRunFields\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const automationRunFieldRows = datasetRows.get(\"automation_run_fields\") ?? [];\n  summary.total = automationRunFieldRows.length;\n\n  const entityName = \"automationRunFields\";\n  const progressEntry =\n    context.entityProgress[entityName] ??\n    (context.entityProgress[entityName] = {\n      total: summary.total,\n      created: 0,\n      mapped: 0,\n    });\n  progressEntry.total = summary.total;\n\n  const chunkSize = Math.max(1, options?.chunkSize ?? 250);\n  const updateChunkSize = Math.max(1, Math.floor(chunkSize / 2) || 1);\n  let processedRows = 0;\n  let lastReportedCount = 0;\n  let lastReportAt = context.lastProgressUpdate;\n  const minProgressDelta = Math.max(1, Math.floor(summary.total / 50));\n  const minProgressIntervalMs = 2000;\n\n  const reportProgress = async (force = false) => {\n    if (summary.total === 0) {\n      return;\n    }\n    const now = Date.now();\n    const deltaCount = processedRows - lastReportedCount;\n    if (\n      !force &&\n      deltaCount < minProgressDelta &&\n      now - lastReportAt < minProgressIntervalMs\n    ) {\n      return;\n    }\n\n    progressEntry.mapped = Math.min(processedRows, progressEntry.total);\n\n    lastReportedCount = processedRows;\n    lastReportAt = now;\n\n    const statusMessage = `Processing automation run fields (${processedRows.toLocaleString()} / ${summary.total.toLocaleString()} records processed)`;\n    await persistProgress(entityName, statusMessage);\n  };\n\n  const fieldsByRunId = new Map<number, Record<string, any>>();\n  for (const row of automationRunFieldRows) {\n    const testmoRunId = toNumberValue(row.run_id);\n    const testmoProjectId = toNumberValue(row.project_id);\n    const name = toStringValue(row.name);\n    const fieldType = toNumberValue(row.type);\n    const value = toStringValue(row.value);\n\n    processedRows += 1;\n\n    if (!testmoRunId || !testmoProjectId || !name) {\n      context.processedCount += 1;\n      await reportProgress();\n      continue;\n    }\n\n    const projectId = projectIdMap.get(testmoProjectId);\n    const testRunId = testRunIdMap.get(testmoRunId);\n\n    if (!projectId || !testRunId) {\n      context.processedCount += 1;\n      await reportProgress();\n      continue;\n    }\n\n    if (!fieldsByRunId.has(testRunId)) {\n      fieldsByRunId.set(testRunId, {});\n    }\n    const fields = fieldsByRunId.get(testRunId)!;\n    fields[name] = { type: fieldType, value };\n\n    context.processedCount += 1;\n    if (processedRows % chunkSize === 0) {\n      await reportProgress();\n    }\n  }\n\n  await reportProgress(true);\n\n  const runEntries = Array.from(fieldsByRunId.entries());\n  const totalRuns = runEntries.length;\n  let runsProcessed = 0;\n\n  const updateChunks = chunkArray(runEntries, updateChunkSize);\n\n  for (const chunk of updateChunks) {\n    const results = await Promise.allSettled(\n      chunk.map(([testRunId, fields]) =>\n        prisma.testRuns.update({\n          where: { id: testRunId },\n          data: { note: fields },\n        })\n      )\n    );\n\n    results.forEach((result, idx) => {\n      if (result.status === \"fulfilled\") {\n        summary.created += 1;\n      } else {\n        const runId = chunk[idx]?.[0];\n        console.error(\"Failed to update automation run fields\", {\n          runId,\n          error: result.reason,\n        });\n      }\n    });\n\n    runsProcessed += chunk.length;\n    const statusMessage = `Applying automation run field updates (${runsProcessed.toLocaleString()} / ${totalRuns.toLocaleString()} runs updated)`;\n    await persistProgress(entityName, statusMessage);\n  }\n\n  progressEntry.created = summary.created;\n  progressEntry.mapped = Math.min(processedRows, progressEntry.total);\n\n  return summary;\n};\n\nconst reconcileLegacyJUnitSuiteLinks = async (\n  tx: Prisma.TransactionClient,\n  suiteIds: number[]\n) => {\n  if (suiteIds.length === 0) {\n    return;\n  }\n\n  const chunkSize = 2000;\n  for (const chunk of chunkArray(suiteIds, chunkSize)) {\n    // Only update results where testSuiteId points to a TestRun (legacy data)\n    // Don't update results that already correctly point to a JUnitTestSuite\n    // CRITICAL: Also check that testSuiteId is NOT already a valid JUnitTestSuite\n    await tx.$executeRaw`\n      UPDATE \"JUnitTestResult\" AS r\n      SET \"testSuiteId\" = s.\"id\"\n      FROM \"JUnitTestSuite\" AS s\n      WHERE s.\"id\" IN (${Prisma.join(chunk)})\n        AND r.\"testSuiteId\" = s.\"testRunId\"\n        AND r.\"testSuiteId\" IN (SELECT id FROM \"TestRuns\")\n        AND r.\"testSuiteId\" NOT IN (SELECT id FROM \"JUnitTestSuite\");\n    `;\n  }\n};\n\nconst recomputeJUnitSuiteStats = async (\n  tx: Prisma.TransactionClient,\n  suiteIds: number[]\n) => {\n  if (suiteIds.length === 0) {\n    return;\n  }\n\n  const groupedAll: Array<{\n    testSuiteId: number;\n    type: JUnitResultType | null;\n    _count: { _all: number };\n    _sum: { time: number | null };\n  }> = [];\n\n  const chunkSize = 2000;\n  for (const chunk of chunkArray(suiteIds, chunkSize)) {\n    const grouped = await tx.jUnitTestResult.groupBy({\n      by: [\"testSuiteId\", \"type\"],\n      where: {\n        testSuiteId: {\n          in: chunk,\n        },\n      },\n      _count: {\n        _all: true,\n      },\n      _sum: {\n        time: true,\n      },\n    });\n\n    groupedAll.push(...grouped);\n  }\n\n  const statsBySuite = new Map<\n    number,\n    {\n      total: number;\n      failures: number;\n      errors: number;\n      skipped: number;\n      time: number;\n    }\n  >();\n\n  suiteIds.forEach((id) => {\n    statsBySuite.set(id, {\n      total: 0,\n      failures: 0,\n      errors: 0,\n      skipped: 0,\n      time: 0,\n    });\n  });\n\n  groupedAll.forEach((entry) => {\n    const suiteStats = statsBySuite.get(entry.testSuiteId);\n    if (!suiteStats) {\n      return;\n    }\n\n    const count = entry._count?._all ?? 0;\n    const timeSum = entry._sum?.time ?? 0;\n\n    suiteStats.total += count;\n    suiteStats.time += timeSum;\n\n    switch (entry.type) {\n      case JUnitResultType.FAILURE:\n        suiteStats.failures += count;\n        break;\n      case JUnitResultType.ERROR:\n        suiteStats.errors += count;\n        break;\n      case JUnitResultType.SKIPPED:\n        suiteStats.skipped += count;\n        break;\n      default:\n        break;\n    }\n  });\n\n  await Promise.all(\n    Array.from(statsBySuite.entries()).map(([suiteId, data]) =>\n      tx.jUnitTestSuite.update({\n        where: { id: suiteId },\n        data: {\n          tests: data.total,\n          failures: data.failures,\n          errors: data.errors,\n          skipped: data.skipped,\n          time: data.time,\n        },\n      })\n    )\n  );\n};\n\n/**\n * Import automation_run_links as Attachments linked to TestRuns\n * Stores CI/CD job URLs, build links, etc.\n */\nexport const importAutomationRunLinks = async (\n  prisma: PrismaClient,\n  _configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  testRunIdMap: Map<number, number>,\n  userIdMap: Map<number, string>,\n  defaultUserId: string,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"automationRunLinks\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const automationRunLinkRows = datasetRows.get(\"automation_run_links\") ?? [];\n  summary.total = automationRunLinkRows.length;\n\n  const entityName = \"automationRunLinks\";\n  const progressEntry =\n    context.entityProgress[entityName] ??\n    (context.entityProgress[entityName] = {\n      total: summary.total,\n      created: 0,\n      mapped: 0,\n    });\n  progressEntry.total = summary.total;\n\n  let processedLinks = 0;\n  let lastReportedCount = 0;\n  let lastReportAt = context.lastProgressUpdate;\n  const minProgressDelta = Math.max(1, Math.floor(summary.total / 50));\n  const minProgressIntervalMs = 2000;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 250);\n\n  const reportProgress = async (force = false) => {\n    if (summary.total === 0) {\n      return;\n    }\n    const now = Date.now();\n    const deltaCount = processedLinks - lastReportedCount;\n    if (\n      !force &&\n      deltaCount < minProgressDelta &&\n      now - lastReportAt < minProgressIntervalMs\n    ) {\n      return;\n    }\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedLinks, progressEntry.total);\n\n    lastReportedCount = processedLinks;\n    lastReportAt = now;\n\n    const statusMessage = `Processing automation run links (${processedLinks.toLocaleString()} / ${summary.total.toLocaleString()} links processed)`;\n    await persistProgress(entityName, statusMessage);\n  };\n\n  if (automationRunLinkRows.length === 0) {\n    await reportProgress(true);\n    return summary;\n  }\n\n  for (\n    let index = 0;\n    index < automationRunLinkRows.length;\n    index += chunkSize\n  ) {\n    const chunk = automationRunLinkRows.slice(index, index + chunkSize);\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          const testmoRunId = toNumberValue(row.run_id);\n          const testmoProjectId = toNumberValue(row.project_id);\n          const name = toStringValue(row.name);\n          const note = toStringValue(row.note);\n          const url = toStringValue(row.url);\n\n          processedLinks += 1;\n          context.processedCount += 1;\n\n          if (!testmoRunId || !testmoProjectId || !url || !name) {\n            continue;\n          }\n\n          const projectId = projectIdMap.get(testmoProjectId);\n          const testRunId = testRunIdMap.get(testmoRunId);\n\n          if (!projectId || !testRunId) {\n            continue;\n          }\n\n          await tx.attachments.create({\n            data: {\n              testRunsId: testRunId,\n              url,\n              name,\n              note: note || undefined,\n              mimeType: \"text/uri-list\",\n              size: BigInt(url.length),\n              createdById: defaultUserId,\n            },\n          });\n\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedLinks, progressEntry.total);\n    await reportProgress(true);\n  }\n\n  await reportProgress(true);\n\n  progressEntry.created = summary.created;\n  progressEntry.mapped = Math.min(processedLinks, progressEntry.total);\n\n  return summary;\n};\n\n/**\n * Import automation_run_test_fields as JUnitTestResult system output/error\n * Stores test execution logs, error traces, output, etc.\n */\nexport const importAutomationRunTestFields = async (\n  prisma: PrismaClient,\n  _configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  testRunIdMap: Map<number, number>,\n  _testRunCaseIdMap: Map<number, number>,\n  junitResultIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"automationRunTestFields\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const entityName = \"automationRunTestFields\";\n\n  const automationRunTestFieldRows =\n    datasetRows.get(\"automation_run_test_fields\") ?? [];\n  const existingProgress = context.entityProgress[entityName];\n  summary.total =\n    automationRunTestFieldRows.length > 0\n      ? automationRunTestFieldRows.length\n      : (existingProgress?.total ?? 0);\n\n  const progressEntry =\n    context.entityProgress[entityName] ??\n    (context.entityProgress[entityName] = {\n      total: summary.total,\n      created: 0,\n      mapped: 0,\n    });\n  progressEntry.total = summary.total;\n  if (summary.total === 0 && context.jobId) {\n    summary.total = await prisma.testmoImportStaging.count({\n      where: {\n        jobId: context.jobId,\n        datasetName: \"automation_run_test_fields\",\n      },\n    });\n    progressEntry.total = summary.total;\n  }\n\n  let processedRows = 0;\n  let lastReportedCount = 0;\n  let lastReportAt = context.lastProgressUpdate;\n  const minProgressDelta = Math.max(\n    1,\n    Math.min(Math.floor(summary.total / 50), 5000)\n  );\n  const minProgressIntervalMs = 2000;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 250);\n\n  const reportProgress = async (force = false) => {\n    if (summary.total === 0) {\n      return;\n    }\n    const now = Date.now();\n    const deltaCount = processedRows - lastReportedCount;\n    if (\n      !force &&\n      deltaCount < minProgressDelta &&\n      now - lastReportAt < minProgressIntervalMs\n    ) {\n      return;\n    }\n\n    progressEntry.mapped = Math.min(processedRows, progressEntry.total);\n\n    lastReportedCount = processedRows;\n    lastReportAt = now;\n\n    const statusMessage = `Processing automation run test fields (${processedRows.toLocaleString()} / ${summary.total.toLocaleString()} records processed)`;\n    await persistProgress(entityName, statusMessage);\n  };\n\n  type PendingFieldUpdate = {\n    junitResultId: number | undefined;\n    systemOut: string[];\n    systemErr: string[];\n  };\n\n  const pendingByTestId = new Map<number, PendingFieldUpdate>();\n  let rowsSinceFlush = 0;\n  const shouldStream =\n    automationRunTestFieldRows.length === 0 && summary.total > 0;\n  const fetchBatchSize = Math.min(Math.max(chunkSize * 4, chunkSize), 5000);\n\n  const cloneRowData = (\n    data: unknown,\n    fieldName?: string | null,\n    fieldValue?: string | null,\n    text1?: string | null,\n    text2?: string | null,\n    text3?: string | null,\n    text4?: string | null\n  ) => {\n    const cloned =\n      typeof data === \"object\" && data !== null\n        ? JSON.parse(JSON.stringify(data))\n        : data;\n\n    if (cloned && typeof cloned === \"object\") {\n      const record = cloned as Record<string, unknown>;\n      if (\n        fieldValue !== null &&\n        fieldValue !== undefined &&\n        record.value === undefined\n      ) {\n        record.value = fieldValue;\n      }\n      if (fieldName && (record.name === undefined || record.name === null)) {\n        record.name = fieldName;\n      }\n      const textEntries: Array<[string, string | null | undefined]> = [\n        [\"text1\", text1],\n        [\"text2\", text2],\n        [\"text3\", text3],\n        [\"text4\", text4],\n      ];\n      for (const [key, value] of textEntries) {\n        if (\n          value !== null &&\n          value !== undefined &&\n          record[key] === undefined\n        ) {\n          record[key] = value;\n        }\n      }\n    }\n\n    return cloned;\n  };\n\n  const streamStagingRows = async function* (): AsyncGenerator<any> {\n    if (!context.jobId) {\n      throw new Error(\n        \"importAutomationRunTestFields requires context.jobId for streaming\"\n      );\n    }\n\n    let nextRowIndex = 0;\n    while (true) {\n      const stagedRows = await prisma.testmoImportStaging.findMany({\n        where: {\n          jobId: context.jobId,\n          datasetName: \"automation_run_test_fields\",\n          rowIndex: {\n            gte: nextRowIndex,\n            lt: nextRowIndex + fetchBatchSize,\n          },\n        },\n        orderBy: {\n          rowIndex: \"asc\",\n        },\n        select: {\n          rowIndex: true,\n          rowData: true,\n          fieldName: true,\n          fieldValue: true,\n          text1: true,\n          text2: true,\n          text3: true,\n          text4: true,\n        },\n      });\n\n      if (stagedRows.length === 0) {\n        break;\n      }\n\n      nextRowIndex = stagedRows[stagedRows.length - 1].rowIndex + 1;\n\n      for (const staged of stagedRows) {\n        yield cloneRowData(\n          staged.rowData,\n          staged.fieldName,\n          staged.fieldValue,\n          staged.text1,\n          staged.text2,\n          staged.text3,\n          staged.text4\n        );\n      }\n    }\n  };\n\n  const mergeValues = (\n    current: string | null | undefined,\n    additions: string[]\n  ): string | null => {\n    const filtered = additions\n      .map((value) => value.trim())\n      .filter((value) => value.length > 0);\n    if (filtered.length === 0) {\n      return current ?? null;\n    }\n\n    const addition = filtered.join(\"\\n\\n\");\n    if (!addition) {\n      return current ?? null;\n    }\n\n    if (!current || current.trim().length === 0) {\n      return addition;\n    }\n\n    return `${current}\\n\\n${addition}`;\n  };\n\n  const flushPendingUpdates = async (force = false) => {\n    const shouldFlushByRows = rowsSinceFlush >= chunkSize;\n    if (!force && pendingByTestId.size < chunkSize && !shouldFlushByRows) {\n      return;\n    }\n    if (pendingByTestId.size === 0) {\n      return;\n    }\n\n    const entries = Array.from(pendingByTestId.entries());\n    pendingByTestId.clear();\n\n    const resultIds = entries\n      .map(([, update]) => update.junitResultId)\n      .filter((id): id is number => typeof id === \"number\");\n\n    const existingResults =\n      resultIds.length > 0\n        ? await prisma.jUnitTestResult.findMany({\n            where: { id: { in: resultIds } },\n            select: { id: true, systemOut: true, systemErr: true },\n          })\n        : [];\n    const existingById = new Map(\n      existingResults.map((result) => [result.id, result])\n    );\n\n    let updatesApplied = 0;\n\n    if (entries.length > 0) {\n      await prisma.$transaction(\n        async (tx: Prisma.TransactionClient) => {\n          for (const [, update] of entries) {\n            const junitResultId = update.junitResultId;\n            if (!junitResultId) {\n              continue;\n            }\n\n            const existing = existingById.get(junitResultId);\n            const nextSystemOut = mergeValues(\n              existing?.systemOut,\n              update.systemOut\n            );\n            const nextSystemErr = mergeValues(\n              existing?.systemErr,\n              update.systemErr\n            );\n\n            if (\n              nextSystemOut === (existing?.systemOut ?? null) &&\n              nextSystemErr === (existing?.systemErr ?? null)\n            ) {\n              continue;\n            }\n\n            await tx.jUnitTestResult.update({\n              where: { id: junitResultId },\n              data: {\n                systemOut: nextSystemOut,\n                systemErr: nextSystemErr,\n              },\n            });\n\n            summary.created += 1;\n            updatesApplied += 1;\n          }\n        },\n        {\n          timeout: options?.transactionTimeoutMs,\n        }\n      );\n    }\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedRows, summary.total);\n\n    if (\n      updatesApplied > 0 &&\n      (processedRows % 50000 === 0 || processedRows === summary.total)\n    ) {\n      console.log(\n        `[importAutomationRunTestFields] Applied ${updatesApplied} updates (processed ${processedRows}/${summary.total} rows)`\n      );\n    }\n\n    const statusMessage = `Applying automation run test field updates (${processedRows.toLocaleString()} / ${summary.total.toLocaleString()} rows processed)`;\n    await persistProgress(entityName, statusMessage);\n\n    rowsSinceFlush = 0;\n  };\n\n  const rowIterator = shouldStream\n    ? streamStagingRows()\n    : (async function* () {\n        for (const row of automationRunTestFieldRows) {\n          yield row;\n        }\n      })();\n\n  for await (const row of rowIterator) {\n    const testmoTestId = toNumberValue(row.test_id);\n    const testmoRunId = toNumberValue(row.run_id);\n    const testmoProjectId = toNumberValue(row.project_id);\n    const name = toStringValue(row.name);\n    let value = toStringValue(row.value);\n\n    processedRows += 1;\n    context.processedCount += 1;\n\n    if (!testmoTestId || !testmoRunId || !testmoProjectId || !name || !value) {\n      await reportProgress();\n      continue;\n    }\n\n    const projectId = projectIdMap.get(testmoProjectId);\n    const testRunId = testRunIdMap.get(testmoRunId);\n    const junitResultId = junitResultIdMap.get(testmoTestId);\n\n    if (!projectId || !testRunId || !junitResultId) {\n      await reportProgress();\n      continue;\n    }\n\n    const MAX_VALUE_LENGTH = 500000; // 500KB limit\n    if (value.length > MAX_VALUE_LENGTH) {\n      value =\n        value.substring(0, MAX_VALUE_LENGTH) +\n        \"\\n\\n... (truncated, original length: \" +\n        value.length +\n        \" characters)\";\n    }\n\n    const lowerName = name.toLowerCase();\n    const pending =\n      pendingByTestId.get(testmoTestId) ??\n      ({ junitResultId, systemOut: [], systemErr: [] } as PendingFieldUpdate);\n\n    if (lowerName.includes(\"error\") || lowerName.includes(\"errors\")) {\n      pending.systemErr.push(value);\n    } else if (lowerName.includes(\"output\")) {\n      pending.systemOut.push(value);\n    } else {\n      pending.systemOut.push(`${name}: ${value}`);\n    }\n\n    pending.junitResultId = junitResultId;\n    pendingByTestId.set(testmoTestId, pending);\n\n    await reportProgress();\n\n    rowsSinceFlush += 1;\n    if (pendingByTestId.size >= chunkSize) {\n      await flushPendingUpdates();\n      continue;\n    }\n\n    if (rowsSinceFlush >= chunkSize) {\n      await flushPendingUpdates();\n    }\n  }\n\n  await reportProgress(true);\n  await flushPendingUpdates(true);\n\n  progressEntry.created = summary.created;\n  progressEntry.mapped = Math.min(processedRows, summary.total);\n\n  return summary;\n};\nexport const importAutomationRunTags = async (\n  prisma: PrismaClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  testRunIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"automationRunTags\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const automationRunTagRows = datasetRows.get(\"automation_run_tags\") ?? [];\n  summary.total = automationRunTagRows.length;\n\n  const entityName = \"automationRunTags\";\n  const progressEntry =\n    context.entityProgress[entityName] ??\n    (context.entityProgress[entityName] = {\n      total: summary.total,\n      created: 0,\n      mapped: 0,\n    });\n  progressEntry.total = summary.total;\n\n  let processedRows = 0;\n  let lastReportedCount = 0;\n  let lastReportAt = context.lastProgressUpdate;\n  const minProgressDelta = Math.max(1, Math.floor(summary.total / 50));\n  const minProgressIntervalMs = 2000;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 250);\n\n  const reportProgress = async (force = false) => {\n    if (summary.total === 0) {\n      return;\n    }\n    const now = Date.now();\n    const deltaCount = processedRows - lastReportedCount;\n    if (\n      !force &&\n      deltaCount < minProgressDelta &&\n      now - lastReportAt < minProgressIntervalMs\n    ) {\n      return;\n    }\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedRows, progressEntry.total);\n\n    lastReportedCount = processedRows;\n    lastReportAt = now;\n\n    const statusMessage = `Processing automation run tags (${processedRows.toLocaleString()} / ${summary.total.toLocaleString()} assignments processed)`;\n    await persistProgress(entityName, statusMessage);\n  };\n\n  if (automationRunTagRows.length === 0) {\n    await reportProgress(true);\n    return summary;\n  }\n\n  for (let index = 0; index < automationRunTagRows.length; index += chunkSize) {\n    const chunk = automationRunTagRows.slice(index, index + chunkSize);\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          processedRows += 1;\n          context.processedCount += 1;\n\n          const testmoRunId = toNumberValue(row.run_id);\n          const testmoTagId = toNumberValue(row.tag_id);\n\n          if (!testmoRunId || !testmoTagId) {\n            continue;\n          }\n\n          const runId = testRunIdMap.get(testmoRunId);\n          if (!runId) {\n            continue;\n          }\n\n          const tagConfig = configuration.tags?.[testmoTagId];\n          if (!tagConfig || tagConfig.action !== \"map\" || !tagConfig.mappedTo) {\n            continue;\n          }\n\n          const tagId = tagConfig.mappedTo;\n\n          const existing = await tx.testRuns.findFirst({\n            where: {\n              id: runId,\n              tags: {\n                some: {\n                  id: tagId,\n                },\n              },\n            },\n            select: { id: true },\n          });\n\n          if (existing) {\n            summary.mapped += 1;\n            continue;\n          }\n\n          await tx.testRuns.update({\n            where: { id: runId },\n            data: {\n              tags: {\n                connect: { id: tagId },\n              },\n            },\n          });\n\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    progressEntry.created = summary.created;\n    progressEntry.mapped = Math.min(processedRows, progressEntry.total);\n    await reportProgress(true);\n  }\n\n  await reportProgress(true);\n\n  progressEntry.created = summary.created;\n  progressEntry.mapped = Math.min(processedRows, progressEntry.total);\n\n  return summary;\n};\n", "import { Prisma } from \"@prisma/client\";\nimport type { TestmoMappingConfiguration } from \"../../services/imports/testmo/types\";\nimport { toNumberValue } from \"./helpers\";\nimport type { EntitySummaryResult } from \"./types\";\n\nexport async function importRepositoryCaseTags(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  caseIdMap: Map<number, number>\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"repositoryCaseTags\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const repositoryCaseTagRows = datasetRows.get(\"repository_case_tags\") ?? [];\n\n  for (const row of repositoryCaseTagRows) {\n    summary.total += 1;\n\n    const testmoCaseId = toNumberValue(row.case_id);\n    const testmoTagId = toNumberValue(row.tag_id);\n\n    if (!testmoCaseId || !testmoTagId) {\n      continue;\n    }\n\n    // Resolve the mapped case ID\n    const caseId = caseIdMap.get(testmoCaseId);\n    if (!caseId) {\n      // Case wasn't imported, skip this tag assignment\n      continue;\n    }\n\n    // Resolve the mapped tag ID\n    const tagConfig = configuration.tags?.[testmoTagId];\n    if (!tagConfig || tagConfig.action !== \"map\" || !tagConfig.mappedTo) {\n      // Tag wasn't imported/mapped, skip this assignment\n      continue;\n    }\n\n    const tagId = tagConfig.mappedTo;\n\n    // Check if assignment already exists\n    const existing = await tx.repositoryCases.findFirst({\n      where: {\n        id: caseId,\n        tags: {\n          some: {\n            id: tagId,\n          },\n        },\n      },\n    });\n\n    if (existing) {\n      summary.mapped += 1;\n      continue;\n    }\n\n    // Create the tag assignment by connecting the tag to the case\n    await tx.repositoryCases.update({\n      where: { id: caseId },\n      data: {\n        tags: {\n          connect: { id: tagId },\n        },\n      },\n    });\n\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\nexport async function importRunTags(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  testRunIdMap: Map<number, number>\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"runTags\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const runTagRows = datasetRows.get(\"run_tags\") ?? [];\n\n  for (const row of runTagRows) {\n    summary.total += 1;\n\n    const testmoRunId = toNumberValue(row.run_id);\n    const testmoTagId = toNumberValue(row.tag_id);\n\n    if (!testmoRunId || !testmoTagId) {\n      continue;\n    }\n\n    // Resolve the mapped run ID\n    const runId = testRunIdMap.get(testmoRunId);\n    if (!runId) {\n      // Run wasn't imported, skip this tag assignment\n      continue;\n    }\n\n    // Resolve the mapped tag ID\n    const tagConfig = configuration.tags?.[testmoTagId];\n    if (!tagConfig || tagConfig.action !== \"map\" || !tagConfig.mappedTo) {\n      // Tag wasn't imported/mapped, skip this assignment\n      continue;\n    }\n\n    const tagId = tagConfig.mappedTo;\n\n    // Check if assignment already exists\n    const existing = await tx.testRuns.findFirst({\n      where: {\n        id: runId,\n        tags: {\n          some: {\n            id: tagId,\n          },\n        },\n      },\n    });\n\n    if (existing) {\n      summary.mapped += 1;\n      continue;\n    }\n\n    // Create the tag assignment by connecting the tag to the run\n    await tx.testRuns.update({\n      where: { id: runId },\n      data: {\n        tags: {\n          connect: { id: tagId },\n        },\n      },\n    });\n\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\nexport async function importSessionTags(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  sessionIdMap: Map<number, number>\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"sessionTags\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const sessionTagRows = datasetRows.get(\"session_tags\") ?? [];\n\n  for (const row of sessionTagRows) {\n    summary.total += 1;\n\n    const testmoSessionId = toNumberValue(row.session_id);\n    const testmoTagId = toNumberValue(row.tag_id);\n\n    if (!testmoSessionId || !testmoTagId) {\n      continue;\n    }\n\n    // Resolve the mapped session ID\n    const sessionId = sessionIdMap.get(testmoSessionId);\n    if (!sessionId) {\n      // Session wasn't imported, skip this tag assignment\n      continue;\n    }\n\n    // Resolve the mapped tag ID\n    const tagConfig = configuration.tags?.[testmoTagId];\n    if (!tagConfig || tagConfig.action !== \"map\" || !tagConfig.mappedTo) {\n      // Tag wasn't imported/mapped, skip this assignment\n      continue;\n    }\n\n    const tagId = tagConfig.mappedTo;\n\n    // Check if assignment already exists\n    const existing = await tx.sessions.findFirst({\n      where: {\n        id: sessionId,\n        tags: {\n          some: {\n            id: tagId,\n          },\n        },\n      },\n    });\n\n    if (existing) {\n      summary.mapped += 1;\n      continue;\n    }\n\n    // Create the tag assignment by connecting the tag to the session\n    await tx.sessions.update({\n      where: { id: sessionId },\n      data: {\n        tags: {\n          connect: { id: tagId },\n        },\n      },\n    });\n\n    summary.created += 1;\n  }\n\n  return summary;\n}\n\n// NOTE: importMilestoneAutomationTags cannot be implemented because the Milestones model\n// does not have a tags relation in the schema. This would require a schema change first.\n// The Testmo dataset \"milestone_automation_tags\" exists but cannot be imported.\n", "import { Prisma } from \"@prisma/client\";\nimport { getSchema } from \"@tiptap/core\";\nimport { DOMParser as PMDOMParser } from \"@tiptap/pm/model\";\nimport StarterKit from \"@tiptap/starter-kit\";\nimport { Window as HappyDOMWindow } from \"happy-dom\";\nimport type { TestmoMappingConfiguration } from \"../../services/imports/testmo/types\";\nimport { toInputJsonValue, toNumberValue, toStringValue } from \"./helpers\";\nimport type { EntitySummaryResult, ImportContext } from \"./types\";\n\n/**\n * Convert link data to TipTap JSON format\n */\nconst TIPTAP_EXTENSIONS = [\n  StarterKit.configure({\n    dropcursor: false,\n    gapcursor: false,\n    undoRedo: false,\n    trailingNode: false,\n    heading: {\n      levels: [1, 2, 3, 4],\n    },\n  }),\n];\n\nconst TIPTAP_SCHEMA = getSchema(TIPTAP_EXTENSIONS);\n\nlet sharedHappyDOMWindow: HappyDOMWindow | null = null;\nlet sharedDOMParser: any = null; // Happy-DOM parser has a custom type\n\nconst getSharedHappyDOM = () => {\n  if (!sharedHappyDOMWindow || !sharedDOMParser) {\n    if (sharedHappyDOMWindow) {\n      try {\n        sharedHappyDOMWindow.close();\n      } catch (error) {\n        // Ignore cleanup errors\n      }\n    }\n    sharedHappyDOMWindow = new HappyDOMWindow();\n    sharedDOMParser = new sharedHappyDOMWindow.DOMParser();\n  }\n\n  return { window: sharedHappyDOMWindow!, parser: sharedDOMParser! };\n};\n\nconst escapeHtml = (value: string): string =>\n  value.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n\nconst escapeAttribute = (value: string): string =>\n  escapeHtml(value).replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\");\n\nconst buildLinkHtml = (\n  name: string,\n  url: string,\n  note?: string | null\n): string => {\n  const safeLabel = escapeHtml(name);\n  const safeUrl = escapeAttribute(url);\n  const noteFragment = note ? ` (${escapeHtml(note)})` : \"\";\n  return `<p><a href=\"${safeUrl}\" target=\"_blank\" rel=\"noopener noreferrer\">${safeLabel}</a>${noteFragment}</p>`;\n};\n\nconst convertHtmlToTipTapDoc = (html: string): Record<string, unknown> => {\n  const { parser } = getSharedHappyDOM();\n  if (!parser) {\n    throw new Error(\"Failed to initialize DOM parser\");\n  }\n  const htmlString = `<!DOCTYPE html><html><body>${html}</body></html>`;\n  const document = parser.parseFromString(htmlString, \"text/html\");\n  if (!document?.body) {\n    throw new Error(\"Failed to parse HTML content for TipTap conversion\");\n  }\n\n  return PMDOMParser.fromSchema(TIPTAP_SCHEMA).parse(document.body).toJSON();\n};\n\nconst sanitizeLinkMarks = (node: Record<string, any>) => {\n  if (Array.isArray(node.marks)) {\n    for (const mark of node.marks) {\n      if (mark?.type === \"link\" && mark.attrs) {\n        const { href, target } = mark.attrs;\n        mark.attrs = {\n          href,\n          ...(target ? { target } : {}),\n        };\n      }\n    }\n  }\n  if (Array.isArray(node.content)) {\n    for (const child of node.content) {\n      if (child && typeof child === \"object\") {\n        sanitizeLinkMarks(child as Record<string, any>);\n      }\n    }\n  }\n};\n\nfunction createTipTapLink(\n  name: string,\n  url: string,\n  note?: string | null\n): Record<string, unknown> {\n  try {\n    const html = buildLinkHtml(name, url, note);\n    const doc = convertHtmlToTipTapDoc(html);\n    if (doc && Array.isArray(doc.content) && doc.content.length > 0) {\n      for (const node of doc.content) {\n        if (node && typeof node === \"object\") {\n          sanitizeLinkMarks(node as Record<string, any>);\n        }\n      }\n      // Each html snippet is wrapped in a doc node. Return the paragraph node.\n      return doc.content[0];\n    }\n  } catch (error) {\n    // Fallback to direct JSON construction if HTML conversion fails\n  }\n\n  const linkContent: any[] = [\n    {\n      type: \"text\",\n      marks: [\n        {\n          type: \"link\",\n          attrs: {\n            href: url,\n            target: \"_blank\",\n          },\n        },\n      ],\n      text: name,\n    },\n  ];\n\n  if (note) {\n    linkContent.push({\n      type: \"text\",\n      text: ` (${note})`,\n    });\n  }\n\n  return {\n    type: \"paragraph\",\n    content: linkContent,\n  };\n}\n\n/**\n * Parse existing TipTap JSON docs, or create a new document structure\n */\nfunction parseExistingDocs(existingDocs: any): Record<string, unknown> {\n  if (!existingDocs) {\n    return {\n      type: \"doc\",\n      content: [],\n    };\n  }\n\n  // If it's already an object (JsonValue), use it directly\n  if (typeof existingDocs === \"object\" && existingDocs.type === \"doc\") {\n    return existingDocs;\n  }\n\n  // If it's a string, try to parse it\n  if (typeof existingDocs === \"string\") {\n    try {\n      const parsed = JSON.parse(existingDocs);\n      if (parsed && typeof parsed === \"object\" && parsed.type === \"doc\") {\n        return parsed;\n      }\n    } catch (e) {\n      // If parsing fails, start fresh\n    }\n  }\n\n  return {\n    type: \"doc\",\n    content: [],\n  };\n}\n\n/**\n * Append links to existing TipTap document\n */\nfunction appendLinksToDoc(\n  doc: Record<string, any>,\n  links: Record<string, unknown>[]\n): Record<string, unknown> {\n  if (!Array.isArray(doc.content)) {\n    doc.content = [];\n  }\n\n  // Add each link as a new paragraph\n  for (const link of links) {\n    doc.content.push(link);\n  }\n\n  return doc;\n}\n\nconst prepareDocsForUpdate = (\n  existingDocs: unknown,\n  updatedDocs: Record<string, unknown>\n): string | Prisma.InputJsonValue => {\n  if (typeof existingDocs === \"string\") {\n    return JSON.stringify(updatedDocs);\n  }\n  return toInputJsonValue(updatedDocs);\n};\n\n/**\n * Import project_links as links in Projects.docs field\n * Converts links to TipTap JSON format and appends to existing docs\n */\nexport const importProjectLinks = async (\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  context: ImportContext\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"projectLinks\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const projectLinkRows = datasetRows.get(\"project_links\") ?? [];\n  summary.total = projectLinkRows.length;\n\n  // Group links by project\n  const linksByProjectId = new Map<number, Record<string, unknown>[]>();\n\n  for (const row of projectLinkRows) {\n    const testmoProjectId = toNumberValue(row.project_id);\n    const name = toStringValue(row.name);\n    const url = toStringValue(row.url);\n    const note = toStringValue(row.note);\n\n    if (!testmoProjectId || !name || !url) {\n      continue;\n    }\n\n    const projectId = projectIdMap.get(testmoProjectId);\n    if (!projectId) {\n      continue;\n    }\n\n    const linkJson = createTipTapLink(name, url, note);\n\n    if (!linksByProjectId.has(projectId)) {\n      linksByProjectId.set(projectId, []);\n    }\n    linksByProjectId.get(projectId)!.push(linkJson);\n  }\n\n  // Update each project with appended links\n  for (const [projectId, links] of linksByProjectId.entries()) {\n    const project = await tx.projects.findUnique({\n      where: { id: projectId },\n      select: { docs: true },\n    });\n\n    if (!project) {\n      continue;\n    }\n\n    const doc = parseExistingDocs(project.docs);\n    const updatedDocs = appendLinksToDoc(doc, links);\n    const docsValue = JSON.stringify(updatedDocs);\n\n    await tx.projects.update({\n      where: { id: projectId },\n      data: { docs: docsValue },\n    });\n\n    summary.created += links.length;\n  }\n\n  return summary;\n};\n\n/**\n * Import milestone_links as links in Milestones.docs field\n * Converts links to TipTap JSON format and appends to existing docs\n */\nexport const importMilestoneLinks = async (\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  milestoneIdMap: Map<number, number>,\n  context: ImportContext\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"milestoneLinks\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const milestoneLinkRows = datasetRows.get(\"milestone_links\") ?? [];\n  summary.total = milestoneLinkRows.length;\n\n  // Group links by milestone\n  const linksByMilestoneId = new Map<number, Record<string, unknown>[]>();\n\n  for (const row of milestoneLinkRows) {\n    const testmoMilestoneId = toNumberValue(row.milestone_id);\n    const name = toStringValue(row.name);\n    const url = toStringValue(row.url);\n    const note = toStringValue(row.note);\n\n    if (!testmoMilestoneId || !name || !url) {\n      continue;\n    }\n\n    const milestoneId = milestoneIdMap.get(testmoMilestoneId);\n    if (!milestoneId) {\n      continue;\n    }\n\n    const linkJson = createTipTapLink(name, url, note);\n\n    if (!linksByMilestoneId.has(milestoneId)) {\n      linksByMilestoneId.set(milestoneId, []);\n    }\n    linksByMilestoneId.get(milestoneId)!.push(linkJson);\n  }\n\n  // Update each milestone with appended links\n  for (const [milestoneId, links] of linksByMilestoneId.entries()) {\n    const milestone = await tx.milestones.findUnique({\n      where: { id: milestoneId },\n      select: { docs: true },\n    });\n\n    if (!milestone) {\n      continue;\n    }\n\n    const doc = parseExistingDocs(milestone.docs);\n    const updatedDocs = appendLinksToDoc(doc, links);\n    const docsValue = prepareDocsForUpdate(milestone.docs, updatedDocs);\n\n    await tx.milestones.update({\n      where: { id: milestoneId },\n      data: { docs: docsValue },\n    });\n\n    summary.created += links.length;\n  }\n\n  return summary;\n};\n\n/**\n * Import run_links as links in TestRuns.docs field\n * Converts links to TipTap JSON format and appends to existing docs\n */\nexport const importRunLinks = async (\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  datasetRows: Map<string, any[]>,\n  testRunIdMap: Map<number, number>,\n  context: ImportContext\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"runLinks\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const runLinkRows = datasetRows.get(\"run_links\") ?? [];\n  summary.total = runLinkRows.length;\n\n  // Group links by run\n  const linksByRunId = new Map<number, Record<string, unknown>[]>();\n\n  for (const row of runLinkRows) {\n    const testmoRunId = toNumberValue(row.run_id);\n    const name = toStringValue(row.name);\n    const url = toStringValue(row.url);\n    const note = toStringValue(row.note);\n\n    if (!testmoRunId || !name || !url) {\n      continue;\n    }\n\n    const runId = testRunIdMap.get(testmoRunId);\n    if (!runId) {\n      continue;\n    }\n\n    const linkJson = createTipTapLink(name, url, note);\n\n    if (!linksByRunId.has(runId)) {\n      linksByRunId.set(runId, []);\n    }\n    linksByRunId.get(runId)!.push(linkJson);\n  }\n\n  // Update each run with appended links\n  for (const [runId, links] of linksByRunId.entries()) {\n    const run = await tx.testRuns.findUnique({\n      where: { id: runId },\n      select: { docs: true },\n    });\n\n    if (!run) {\n      continue;\n    }\n\n    const doc = parseExistingDocs(run.docs);\n    const updatedDocs = appendLinksToDoc(doc, links);\n    const docsValue = prepareDocsForUpdate(run.docs, updatedDocs);\n\n    await tx.testRuns.update({\n      where: { id: runId },\n      data: { docs: docsValue },\n    });\n\n    summary.created += links.length;\n  }\n\n  return summary;\n};\n", "import { Prisma } from \"@prisma/client\";\nimport type {\n  TestmoMappingConfiguration,\n  TestmoTemplateFieldTargetType,\n  TestmoFieldOptionConfig,\n} from \"../../services/imports/testmo/types\";\nimport { toNumberValue, toStringValue, toBooleanValue } from \"./helpers\";\nimport type { EntitySummaryResult } from \"./types\";\n\nconst SYSTEM_NAME_REGEX = /^[A-Za-z][A-Za-z0-9_]*$/;\n\nconst generateSystemName = (value: string): string => {\n  const normalized = value\n    .toLowerCase()\n    .replace(/\\s+/g, \"_\")\n    .replace(/[^a-z0-9_]/g, \"\")\n    .replace(/^[^a-z]+/, \"\");\n  return normalized || \"status\";\n};\n\nexport async function importTemplates(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration\n): Promise<{ summary: EntitySummaryResult; templateMap: Map<string, number> }> {\n  const summary: EntitySummaryResult = {\n    entity: \"templates\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const templateMap = new Map<string, number>();\n\n  for (const [key, config] of Object.entries(configuration.templates ?? {})) {\n    const templateKey = Number(key);\n    if (!Number.isFinite(templateKey) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Template ${templateKey} is configured to map but no target template was provided.`\n        );\n      }\n\n      const existing = await tx.templates.findUnique({\n        where: { id: config.mappedTo },\n      });\n\n      if (!existing) {\n        throw new Error(\n          `Template ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      config.mappedTo = existing.id;\n      config.name = config.name ?? existing.templateName;\n      templateMap.set(existing.templateName, existing.id);\n      summary.mapped += 1;\n      continue;\n    }\n\n    const name = (config.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(\n        `Template ${templateKey} requires a name before it can be created.`\n      );\n    }\n\n    const existing = await tx.templates.findFirst({\n      where: {\n        templateName: name,\n        isDeleted: false,\n      },\n    });\n\n    if (existing) {\n      config.action = \"map\";\n      config.mappedTo = existing.id;\n      config.name = existing.templateName;\n      templateMap.set(existing.templateName, existing.id);\n      summary.mapped += 1;\n      continue;\n    }\n\n    const created = await tx.templates.create({\n      data: {\n        templateName: name,\n        isEnabled: true,\n        isDefault: false,\n      },\n    });\n\n    config.action = \"map\";\n    config.mappedTo = created.id;\n    config.name = created.templateName;\n    templateMap.set(created.templateName, created.id);\n    summary.created += 1;\n  }\n\n  const processedNames = new Set<string>(templateMap.keys());\n  for (const entry of Object.values(configuration.templateFields ?? {})) {\n    if (!entry) {\n      continue;\n    }\n    const rawName =\n      typeof entry.templateName === \"string\" ? entry.templateName : null;\n    const templateName = rawName?.trim();\n    if (!templateName || processedNames.has(templateName)) {\n      continue;\n    }\n    processedNames.add(templateName);\n\n    summary.total += 1;\n\n    const existing = await tx.templates.findFirst({\n      where: { templateName, isDeleted: false },\n    });\n\n    if (existing) {\n      templateMap.set(templateName, existing.id);\n      summary.mapped += 1;\n      continue;\n    }\n\n    const created = await tx.templates.create({\n      data: {\n        templateName,\n        isEnabled: true,\n        isDefault: false,\n      },\n    });\n\n    templateMap.set(templateName, created.id);\n    summary.created += 1;\n  }\n\n  return { summary, templateMap };\n}\n\nexport async function importTemplateFields(\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  templateMap: Map<string, number>,\n  datasetRows: Map<string, any[]>\n): Promise<EntitySummaryResult> {\n  const summary: EntitySummaryResult = {\n    entity: \"templateFields\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n    details: {\n      optionsCreated: 0,\n      assignmentsCreated: 0,\n    },\n  };\n\n  const details = summary.details as Record<string, number>;\n\n  const ensureFieldTypeExists = async (typeId: number) => {\n    try {\n      const existing = await tx.caseFieldTypes.findUnique({\n        where: { id: typeId },\n      });\n      if (!existing) {\n        console.error(\n          `[ERROR] Field type ${typeId} referenced by a template field was not found.`\n        );\n        const availableTypes = await tx.caseFieldTypes.findMany({\n          select: { id: true, type: true },\n        });\n        console.error(`[ERROR] Available field types:`, availableTypes);\n        throw new Error(\n          `Field type ${typeId} referenced by a template field was not found. Available types: ${availableTypes.map((t) => `${t.id}:${t.type}`).join(\", \")}`\n        );\n      }\n    } catch (error) {\n      console.error(`[ERROR] Failed to check field type ${typeId}:`, error);\n      throw error;\n    }\n  };\n\n  const toNumberOrNull = (value: unknown): number | null => {\n    if (typeof value === \"number\" && Number.isFinite(value)) {\n      return value;\n    }\n    return null;\n  };\n\n  const normalizeOptionConfigs = (\n    input: unknown\n  ): TestmoFieldOptionConfig[] => {\n    if (!Array.isArray(input)) {\n      return [];\n    }\n\n    const normalized: TestmoFieldOptionConfig[] = [];\n\n    input.forEach((entry, index) => {\n      if (typeof entry === \"string\") {\n        const trimmed = entry.trim();\n        if (!trimmed) {\n          return;\n        }\n        normalized.push({\n          name: trimmed,\n          iconId: null,\n          iconColorId: null,\n          isEnabled: true,\n          isDefault: index === 0,\n          order: index,\n        });\n        return;\n      }\n\n      if (!entry || typeof entry !== \"object\") {\n        return;\n      }\n\n      const record = entry as Record<string, unknown>;\n      const rawName =\n        typeof record.name === \"string\"\n          ? record.name\n          : typeof record.label === \"string\"\n            ? record.label\n            : typeof record.value === \"string\"\n              ? record.value\n              : typeof record.displayName === \"string\"\n                ? record.displayName\n                : typeof record.display_name === \"string\"\n                  ? record.display_name\n                  : null;\n      const name = rawName?.trim();\n      if (!name) {\n        return;\n      }\n\n      const iconId =\n        toNumberOrNull(\n          record.iconId ?? record.icon_id ?? record.icon ?? record.iconID\n        ) ?? null;\n      const iconColorId =\n        toNumberOrNull(\n          record.iconColorId ??\n            record.icon_color_id ??\n            record.colorId ??\n            record.color_id ??\n            record.color\n        ) ?? null;\n      const isEnabled = toBooleanValue(\n        record.isEnabled ?? record.enabled ?? record.is_enabled,\n        true\n      );\n      const isDefault = toBooleanValue(\n        record.isDefault ??\n          record.is_default ??\n          record.default ??\n          record.defaultOption,\n        false\n      );\n      const order =\n        toNumberOrNull(\n          record.order ??\n            record.position ??\n            record.ordinal ??\n            record.index ??\n            record.sort\n        ) ?? index;\n\n      normalized.push({\n        name,\n        iconId,\n        iconColorId,\n        isEnabled,\n        isDefault,\n        order,\n      });\n    });\n\n    if (normalized.length === 0) {\n      return [];\n    }\n\n    const sorted = normalized\n      .slice()\n      .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));\n\n    let defaultSeen = false;\n    sorted.forEach((entry) => {\n      if (entry.isDefault) {\n        if (!defaultSeen) {\n          defaultSeen = true;\n        } else {\n          entry.isDefault = false;\n        }\n      }\n    });\n\n    if (!defaultSeen) {\n      sorted[0].isDefault = true;\n    }\n\n    return sorted.map((entry, index) => ({\n      name: entry.name,\n      iconId: entry.iconId ?? null,\n      iconColorId: entry.iconColorId ?? null,\n      isEnabled: entry.isEnabled ?? true,\n      isDefault: entry.isDefault ?? false,\n      order: index,\n    }));\n  };\n\n  const templateIdBySourceId = new Map<number, number>();\n  for (const [templateKey, templateConfig] of Object.entries(\n    configuration.templates ?? {}\n  )) {\n    const sourceId = Number(templateKey);\n    if (\n      Number.isFinite(sourceId) &&\n      templateConfig &&\n      templateConfig.mappedTo !== null &&\n      templateConfig.mappedTo !== undefined\n    ) {\n      templateIdBySourceId.set(sourceId, templateConfig.mappedTo);\n    }\n  }\n\n  const fieldIdBySourceId = new Map<number, number>();\n  const fieldTargetTypeBySourceId = new Map<\n    number,\n    TestmoTemplateFieldTargetType\n  >();\n\n  const templateSourceNameById = new Map<number, string>();\n  const templateDatasetRows = datasetRows.get(\"templates\") ?? [];\n  for (const row of templateDatasetRows) {\n    const record = row as Record<string, unknown>;\n    const sourceId = toNumberValue(record.id);\n    const name = toStringValue(record.name);\n    if (sourceId !== null && name) {\n      templateSourceNameById.set(sourceId, name);\n    }\n  }\n\n  const appliedAssignments = new Set<string>();\n  const makeAssignmentKey = (\n    fieldId: number,\n    templateId: number,\n    targetType: TestmoTemplateFieldTargetType\n  ) => `${targetType}:${templateId}:${fieldId}`;\n\n  const resolveTemplateIdForName = async (\n    templateName: string\n  ): Promise<number | null> => {\n    const trimmed = templateName.trim();\n    if (!trimmed) {\n      return null;\n    }\n\n    const templateId = templateMap.get(trimmed);\n    if (templateId) {\n      return templateId;\n    }\n\n    const existing = await tx.templates.findFirst({\n      where: { templateName: trimmed, isDeleted: false },\n    });\n\n    if (existing) {\n      templateMap.set(existing.templateName, existing.id);\n      return existing.id;\n    }\n\n    const created = await tx.templates.create({\n      data: {\n        templateName: trimmed,\n        isEnabled: true,\n        isDefault: false,\n      },\n    });\n\n    templateMap.set(created.templateName, created.id);\n    return created.id;\n  };\n\n  const assignFieldToTemplate = async (\n    fieldId: number,\n    templateId: number,\n    targetType: TestmoTemplateFieldTargetType,\n    order: number | undefined\n  ): Promise<void> => {\n    const assignmentKey = makeAssignmentKey(fieldId, templateId, targetType);\n    if (appliedAssignments.has(assignmentKey)) {\n      return;\n    }\n    try {\n      if (targetType === \"case\") {\n        await tx.templateCaseAssignment.create({\n          data: {\n            caseFieldId: fieldId,\n            templateId,\n            order: order ?? 0,\n          },\n        });\n      } else {\n        await tx.templateResultAssignment.create({\n          data: {\n            resultFieldId: fieldId,\n            templateId,\n            order: order ?? 0,\n          },\n        });\n      }\n      appliedAssignments.add(assignmentKey);\n      details.assignmentsCreated += 1;\n    } catch (error) {\n      if (\n        !(\n          error instanceof Prisma.PrismaClientKnownRequestError &&\n          error.code === \"P2002\"\n        )\n      ) {\n        throw error;\n      }\n      appliedAssignments.add(assignmentKey);\n    }\n  };\n\n  for (const [key, config] of Object.entries(\n    configuration.templateFields ?? {}\n  )) {\n    const fieldId = Number(key);\n    if (!Number.isFinite(fieldId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    const targetType: TestmoTemplateFieldTargetType =\n      config.targetType === \"result\" ? \"result\" : \"case\";\n    config.targetType = targetType;\n    fieldTargetTypeBySourceId.set(fieldId, targetType);\n\n    const templateName = (config.templateName ?? \"\").trim();\n\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Template field ${fieldId} is configured to map but no target field was provided.`\n        );\n      }\n\n      if (targetType === \"case\") {\n        const existing = await tx.caseFields.findUnique({\n          where: { id: config.mappedTo },\n        });\n        if (!existing) {\n          throw new Error(\n            `Case field ${config.mappedTo} selected for mapping was not found.`\n          );\n        }\n      } else {\n        const existing = await tx.resultFields.findUnique({\n          where: { id: config.mappedTo },\n        });\n        if (!existing) {\n          throw new Error(\n            `Result field ${config.mappedTo} selected for mapping was not found.`\n          );\n        }\n      }\n\n      summary.mapped += 1;\n      fieldIdBySourceId.set(fieldId, config.mappedTo);\n\n      if (templateName) {\n        const templateId = await resolveTemplateIdForName(templateName);\n        if (templateId) {\n          await assignFieldToTemplate(\n            config.mappedTo,\n            templateId,\n            targetType,\n            config.order ?? 0\n          );\n        }\n      }\n      continue;\n    }\n\n    const displayName = (\n      config.displayName ??\n      config.systemName ??\n      `Field ${fieldId}`\n    ).trim();\n    let systemName = (config.systemName ?? \"\").trim();\n\n    if (!systemName) {\n      systemName = generateSystemName(displayName);\n    }\n\n    if (!SYSTEM_NAME_REGEX.test(systemName)) {\n      throw new Error(\n        `Template field \"${displayName}\" requires a valid system name (letters, numbers, underscore, starting with a letter).`\n      );\n    }\n\n    const typeId = config.typeId ?? null;\n    if (typeId === null) {\n      throw new Error(\n        `Template field \"${displayName}\" requires a field type before it can be created.`\n      );\n    }\n\n    console.log(\n      `[DEBUG] Processing field \"${displayName}\" (${systemName}) with typeId ${typeId}, action: ${config.action}`\n    );\n    await ensureFieldTypeExists(typeId);\n\n    if (targetType === \"case\") {\n      const existing = await tx.caseFields.findFirst({\n        where: {\n          systemName,\n          isDeleted: false,\n        },\n      });\n\n      if (existing) {\n        config.action = \"map\";\n        config.mappedTo = existing.id;\n        config.systemName = existing.systemName;\n        config.displayName = existing.displayName;\n        summary.mapped += 1;\n        continue;\n      }\n    } else {\n      const existing = await tx.resultFields.findFirst({\n        where: {\n          systemName,\n          isDeleted: false,\n        },\n      });\n\n      if (existing) {\n        config.action = \"map\";\n        config.mappedTo = existing.id;\n        config.systemName = existing.systemName;\n        config.displayName = existing.displayName;\n        summary.mapped += 1;\n        continue;\n      }\n    }\n\n    const fieldData = {\n      displayName,\n      systemName,\n      hint: (config.hint ?? \"\").trim() || null,\n      typeId,\n      isRequired: config.isRequired ?? false,\n      isRestricted: config.isRestricted ?? false,\n      defaultValue: config.defaultValue ?? null,\n      isChecked: config.isChecked ?? null,\n      minValue:\n        toNumberOrNull(config.minValue ?? config.minIntegerValue) ?? null,\n      maxValue:\n        toNumberOrNull(config.maxValue ?? config.maxIntegerValue) ?? null,\n      initialHeight: toNumberOrNull(config.initialHeight) ?? null,\n      isEnabled: true,\n    };\n\n    const createdField =\n      targetType === \"case\"\n        ? await tx.caseFields.create({ data: fieldData })\n        : await tx.resultFields.create({ data: fieldData });\n\n    config.action = \"map\";\n    config.mappedTo = createdField.id;\n    config.displayName = createdField.displayName;\n    config.systemName = createdField.systemName;\n    config.typeId = createdField.typeId;\n    fieldIdBySourceId.set(fieldId, createdField.id);\n\n    const dropdownOptionConfigs = normalizeOptionConfigs(\n      config.dropdownOptions ?? []\n    );\n\n    if (dropdownOptionConfigs.length > 0) {\n      // Fetch default icon and color to ensure all field options have valid values\n      // Use the first available icon and color from the database\n      const defaultIcon = await tx.fieldIcon.findFirst({\n        orderBy: { id: \"asc\" },\n        select: { id: true },\n      });\n      const defaultColor = await tx.color.findFirst({\n        orderBy: { id: \"asc\" },\n        select: { id: true },\n      });\n\n      if (!defaultIcon || !defaultColor) {\n        throw new Error(\n          \"Default icon or color not found. Please ensure the database is properly seeded with FieldIcon and Color records.\"\n        );\n      }\n\n      const createdOptions = [] as { id: number; order: number }[];\n      for (const optionConfig of dropdownOptionConfigs) {\n        const option = await tx.fieldOptions.create({\n          data: {\n            name: optionConfig.name,\n            iconId: optionConfig.iconId ?? defaultIcon.id,\n            iconColorId: optionConfig.iconColorId ?? defaultColor.id,\n            isEnabled: optionConfig.isEnabled ?? true,\n            isDefault: optionConfig.isDefault ?? false,\n            isDeleted: false,\n            order: optionConfig.order ?? 0,\n          },\n        });\n        createdOptions.push({\n          id: option.id,\n          order: optionConfig.order ?? 0,\n        });\n      }\n\n      if (targetType === \"case\") {\n        await tx.caseFieldAssignment.createMany({\n          data: createdOptions.map((option) => ({\n            fieldOptionId: option.id,\n            caseFieldId: createdField.id,\n          })),\n          skipDuplicates: true,\n        });\n      } else {\n        await tx.resultFieldAssignment.createMany({\n          data: createdOptions.map((option) => ({\n            fieldOptionId: option.id,\n            resultFieldId: createdField.id,\n            order: option.order,\n          })),\n          skipDuplicates: true,\n        });\n      }\n\n      details.optionsCreated += createdOptions.length;\n      config.dropdownOptions = dropdownOptionConfigs;\n    } else {\n      config.dropdownOptions = undefined;\n    }\n\n    if (templateName) {\n      const templateId = await resolveTemplateIdForName(templateName);\n      if (templateId) {\n        await assignFieldToTemplate(\n          createdField.id,\n          templateId,\n          targetType,\n          config.order ?? 0\n        );\n      }\n    }\n\n    summary.created += 1;\n  }\n\n  const templateFieldRows = datasetRows.get(\"template_fields\") ?? [];\n  for (const row of templateFieldRows) {\n    const record = row as Record<string, unknown>;\n    const templateSourceId = toNumberValue(record.template_id);\n    const fieldSourceId = toNumberValue(record.field_id);\n    if (templateSourceId === null || fieldSourceId === null) {\n      continue;\n    }\n\n    let templateId = templateIdBySourceId.get(templateSourceId);\n    const fieldId = fieldIdBySourceId.get(fieldSourceId);\n    const targetType = fieldTargetTypeBySourceId.get(fieldSourceId);\n\n    if (!fieldId || !targetType) {\n      continue;\n    }\n\n    if (!templateId) {\n      const templateName = templateSourceNameById.get(templateSourceId);\n      if (!templateName) {\n        continue;\n      }\n      const resolvedTemplateId = await resolveTemplateIdForName(templateName);\n      if (!resolvedTemplateId) {\n        continue;\n      }\n      templateIdBySourceId.set(templateSourceId, resolvedTemplateId);\n      templateId = resolvedTemplateId;\n    }\n\n    await assignFieldToTemplate(fieldId, templateId, targetType, undefined);\n  }\n\n  templateDatasetRows.length = 0;\n  templateFieldRows.length = 0;\n  templateSourceNameById.clear();\n  templateIdBySourceId.clear();\n  fieldIdBySourceId.clear();\n  fieldTargetTypeBySourceId.clear();\n  appliedAssignments.clear();\n\n  return summary;\n}\n", "import { PrismaClient, Prisma, IntegrationProvider, IntegrationAuthType, IntegrationStatus } from \"@prisma/client\";\nimport type { TestmoMappingConfiguration } from \"../../services/imports/testmo/types\";\nimport { toNumberValue, toStringValue } from \"./helpers\";\nimport type { EntitySummaryResult, ImportContext, PersistProgressFn } from \"./types\";\n\nconst PROGRESS_UPDATE_INTERVAL = 500;\n\n/**\n * Map Testmo issue target type to TestPlanIt IntegrationProvider\n */\nconst mapIssueTargetType = (testmoType: number): IntegrationProvider => {\n  // Based on Testmo documentation:\n  // 1 = Jira Cloud\n  // 2 = GitHub Issues\n  // 3 = Azure DevOps\n  // 4 = Jira Server/Data Center\n  // For now, we'll map both Jira types to JIRA\n  switch (testmoType) {\n    case 1:\n    case 4:\n      return IntegrationProvider.JIRA;\n    case 2:\n      return IntegrationProvider.GITHUB;\n    case 3:\n      return IntegrationProvider.AZURE_DEVOPS;\n    default:\n      // Default to SIMPLE_URL for unknown types\n      return IntegrationProvider.SIMPLE_URL;\n  }\n};\n\n/**\n * Import issue_targets as Integration records\n * Testmo issue_targets represent external issue tracking systems (Jira, GitHub, etc.)\n * This function uses the user's configuration to map or create integrations.\n */\nexport const importIssueTargets = async (\n  tx: Prisma.TransactionClient,\n  configuration: TestmoMappingConfiguration,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<{ summary: EntitySummaryResult; integrationIdMap: Map<number, number> }> => {\n  const summary: EntitySummaryResult = {\n    entity: \"issueTargets\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const integrationIdMap = new Map<number, number>();\n  let processedSinceLastPersist = 0;\n\n  for (const [key, config] of Object.entries(configuration.issueTargets ?? {})) {\n    const sourceId = Number(key);\n    if (!Number.isFinite(sourceId) || !config) {\n      continue;\n    }\n\n    summary.total += 1;\n\n    // Handle \"map\" action - map to existing integration\n    if (config.action === \"map\") {\n      if (config.mappedTo === null || config.mappedTo === undefined) {\n        throw new Error(\n          `Issue target ${sourceId} is configured to map but no target integration was provided.`\n        );\n      }\n\n      const existing = await tx.integration.findUnique({\n        where: { id: config.mappedTo },\n      });\n      if (!existing) {\n        throw new Error(\n          `Integration ${config.mappedTo} selected for mapping was not found.`\n        );\n      }\n\n      integrationIdMap.set(sourceId, existing.id);\n      config.mappedTo = existing.id;\n      summary.mapped += 1;\n\n      processedSinceLastPersist += 1;\n      if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n        await persistProgress(\"issueTargets\");\n        processedSinceLastPersist = 0;\n      }\n      continue;\n    }\n\n    // Handle \"create\" action - create new integration or map to existing by name\n    const name = (config.name ?? \"\").trim();\n    if (!name) {\n      throw new Error(\n        `Issue target ${sourceId} requires a name before it can be created.`\n      );\n    }\n\n    const provider = config.provider\n      ? (config.provider as IntegrationProvider)\n      : config.testmoType\n        ? mapIssueTargetType(config.testmoType)\n        : IntegrationProvider.SIMPLE_URL;\n\n    // Check if an integration with this name already exists\n    const existing = await tx.integration.findFirst({\n      where: {\n        name,\n        isDeleted: false,\n      },\n    });\n\n    if (existing) {\n      integrationIdMap.set(sourceId, existing.id);\n      config.action = \"map\";\n      config.mappedTo = existing.id;\n      config.name = existing.name;\n      summary.mapped += 1;\n    } else {\n      // Create new integration\n      const integration = await tx.integration.create({\n        data: {\n          name,\n          provider,\n          authType: IntegrationAuthType.NONE,\n          status: IntegrationStatus.INACTIVE,\n          credentials: {}, // Empty credentials for now\n          settings: {\n            testmoSourceId: sourceId,\n            testmoType: config.testmoType,\n            importedFrom: \"testmo\",\n          },\n        },\n      });\n\n      integrationIdMap.set(sourceId, integration.id);\n      config.action = \"map\";\n      config.mappedTo = integration.id;\n      config.name = integration.name;\n      summary.created += 1;\n    }\n\n    processedSinceLastPersist += 1;\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      await persistProgress(\"issueTargets\");\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    await persistProgress(\"issueTargets\");\n  }\n\n  return { summary, integrationIdMap };\n};\n\n/**\n * Construct the external URL for an issue based on the integration provider and settings\n */\nconst constructExternalUrl = (\n  provider: IntegrationProvider,\n  baseUrl: string | undefined,\n  externalKey: string\n): string | null => {\n  if (!baseUrl) {\n    return null;\n  }\n\n  // Remove trailing slash from baseUrl\n  const cleanBaseUrl = baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\n\n  switch (provider) {\n    case IntegrationProvider.JIRA:\n      // JIRA: baseUrl/browse/KEY\n      return `${cleanBaseUrl}/browse/${externalKey}`;\n    case IntegrationProvider.GITHUB:\n      // GitHub: baseUrl/issues/NUMBER (externalKey should be just the number)\n      return `${cleanBaseUrl}/issues/${externalKey}`;\n    case IntegrationProvider.AZURE_DEVOPS:\n      // Azure DevOps: baseUrl/_workitems/edit/ID\n      return `${cleanBaseUrl}/_workitems/edit/${externalKey}`;\n    case IntegrationProvider.SIMPLE_URL:\n      // For simple URL, use the baseUrl as a template if it contains {issueId}\n      if (baseUrl.includes(\"{issueId}\")) {\n        return baseUrl.replace(\"{issueId}\", externalKey);\n      }\n      return `${cleanBaseUrl}/${externalKey}`;\n    default:\n      return null;\n  }\n};\n\n/**\n * Import issues dataset as Issue records\n */\nexport const importIssues = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  integrationIdMap: Map<number, number>,\n  projectIdMap: Map<number, number>,\n  createdById: string,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<{ summary: EntitySummaryResult; issueIdMap: Map<number, number> }> => {\n  const summary: EntitySummaryResult = {\n    entity: \"issues\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const issueIdMap = new Map<number, number>();\n  const issueRows = datasetRows.get(\"issues\") ?? [];\n\n  if (issueRows.length === 0) {\n    return { summary, issueIdMap };\n  }\n\n  summary.total = issueRows.length;\n  let processedSinceLastPersist = 0;\n\n  // Cache integrations to avoid repeated queries\n  const integrationCache = new Map<number, { provider: IntegrationProvider; baseUrl?: string }>();\n\n  for (const row of issueRows) {\n    const record = row as Record<string, unknown>;\n    const sourceId = toNumberValue(record.id);\n    const targetSourceId = toNumberValue(record.target_id);\n    const projectSourceId = toNumberValue(record.project_id);\n    const displayId = toStringValue(record.display_id);\n\n    if (sourceId === null || targetSourceId === null || !displayId) {\n      continue;\n    }\n\n    const integrationId = integrationIdMap.get(targetSourceId);\n    if (!integrationId) {\n      // Skip if target integration doesn't exist\n      continue;\n    }\n\n    const projectId = projectSourceId !== null ? projectIdMap.get(projectSourceId) : null;\n\n    // Check if issue already exists with this external ID and integration\n    const existing = await tx.issue.findFirst({\n      where: {\n        externalId: displayId,\n        integrationId,\n      },\n    });\n\n    if (existing) {\n      issueIdMap.set(sourceId, existing.id);\n      summary.mapped += 1;\n    } else {\n      // Fetch integration details if not in cache\n      if (!integrationCache.has(integrationId)) {\n        const integration = await tx.integration.findUnique({\n          where: { id: integrationId },\n          select: { provider: true, settings: true },\n        });\n        if (integration) {\n          const settings = integration.settings as Record<string, any> | null;\n          integrationCache.set(integrationId, {\n            provider: integration.provider,\n            baseUrl: settings?.baseUrl,\n          });\n        }\n      }\n\n      const integrationInfo = integrationCache.get(integrationId);\n      const externalUrl = integrationInfo\n        ? constructExternalUrl(integrationInfo.provider, integrationInfo.baseUrl, displayId)\n        : null;\n\n      // Create new issue\n      const issue = await tx.issue.create({\n        data: {\n          name: displayId,\n          title: displayId,\n          externalId: displayId,\n          externalKey: displayId,\n          externalUrl,\n          integrationId,\n          projectId: projectId ?? undefined,\n          createdById,\n          data: {\n            testmoSourceId: sourceId,\n            importedFrom: \"testmo\",\n          },\n        },\n      });\n\n      issueIdMap.set(sourceId, issue.id);\n      summary.created += 1;\n    }\n\n    processedSinceLastPersist += 1;\n    if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n      await persistProgress(\"issues\");\n      processedSinceLastPersist = 0;\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    await persistProgress(\"issues\");\n  }\n\n  return { summary, issueIdMap };\n};\n\n/**\n * Import milestone_issues relationships\n * NOTE: Currently not implemented - Milestones model does not have an issues relation in the schema.\n * This would need to be added to the schema before milestone-issue relationships can be imported.\n * Connects issues to milestones via the implicit many-to-many join table\n */\nexport const importMilestoneIssues = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  milestoneIdMap: Map<number, number>,\n  issueIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"milestoneIssues\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const milestoneIssueRows = datasetRows.get(\"milestone_issues\") ?? [];\n  summary.total = milestoneIssueRows.length;\n\n  // Skip import - schema doesn't support milestone-issue relationship yet\n  // TODO: Add issues relation to Milestones model in schema.zmodel to enable this import\n  if (milestoneIssueRows.length > 0) {\n    console.warn(\n      `Skipping import of ${milestoneIssueRows.length} milestone-issue relationships - ` +\n      `Milestones model does not have an issues relation. ` +\n      `Add 'issues Issue[]' to the Milestones model in schema.zmodel to enable this feature.`\n    );\n  }\n\n  return summary;\n};\n\n/**\n * Import repository_case_issues relationships\n * Connects issues to repository cases\n */\nexport const importRepositoryCaseIssues = async (\n  prisma: PrismaClient,\n  datasetRows: Map<string, any[]>,\n  caseIdMap: Map<number, number>,\n  issueIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"repositoryCaseIssues\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const repositoryCaseIssueRows = datasetRows.get(\"repository_case_issues\") ?? [];\n\n  if (repositoryCaseIssueRows.length === 0) {\n    return summary;\n  }\n\n  summary.total = repositoryCaseIssueRows.length;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 1000);\n  let processedCount = 0;\n\n  for (let index = 0; index < repositoryCaseIssueRows.length; index += chunkSize) {\n    const chunk = repositoryCaseIssueRows.slice(index, index + chunkSize);\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          const record = row as Record<string, unknown>;\n          const caseSourceId = toNumberValue(record.case_id);\n          const issueSourceId = toNumberValue(record.issue_id);\n\n          processedCount += 1;\n          context.processedCount += 1;\n\n          if (caseSourceId === null || issueSourceId === null) {\n            continue;\n          }\n\n          const caseId = caseIdMap.get(caseSourceId);\n          const issueId = issueIdMap.get(issueSourceId);\n\n          if (!caseId || !issueId) {\n            continue;\n          }\n\n          // Connect issue to repository case\n          await tx.repositoryCases.update({\n            where: { id: caseId },\n            data: {\n              issues: {\n                connect: { id: issueId },\n              },\n            },\n          });\n\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    const statusMessage = `Processing repository case issues (${processedCount.toLocaleString()} / ${summary.total.toLocaleString()} processed)`;\n    await persistProgress(\"repositoryCaseIssues\", statusMessage);\n  }\n\n  return summary;\n};\n\n/**\n * Import run_issues relationships\n * Connects issues to test runs\n */\nexport const importRunIssues = async (\n  prisma: PrismaClient,\n  datasetRows: Map<string, any[]>,\n  testRunIdMap: Map<number, number>,\n  issueIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"runIssues\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const runIssueRows = datasetRows.get(\"run_issues\") ?? [];\n\n  if (runIssueRows.length === 0) {\n    return summary;\n  }\n\n  summary.total = runIssueRows.length;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 1000);\n  let processedCount = 0;\n\n  for (let index = 0; index < runIssueRows.length; index += chunkSize) {\n    const chunk = runIssueRows.slice(index, index + chunkSize);\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          const record = row as Record<string, unknown>;\n          const runSourceId = toNumberValue(record.run_id);\n          const issueSourceId = toNumberValue(record.issue_id);\n\n          processedCount += 1;\n          context.processedCount += 1;\n\n          if (runSourceId === null || issueSourceId === null) {\n            continue;\n          }\n\n          const runId = testRunIdMap.get(runSourceId);\n          const issueId = issueIdMap.get(issueSourceId);\n\n          if (!runId || !issueId) {\n            continue;\n          }\n\n          // Connect issue to test run\n          await tx.testRuns.update({\n            where: { id: runId },\n            data: {\n              issues: {\n                connect: { id: issueId },\n              },\n            },\n          });\n\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    const statusMessage = `Processing test run issues (${processedCount.toLocaleString()} / ${summary.total.toLocaleString()} processed)`;\n    await persistProgress(\"runIssues\", statusMessage);\n  }\n\n  return summary;\n};\n\n/**\n * Import run_result_issues relationships\n * Connects issues to test run results\n */\nexport const importRunResultIssues = async (\n  prisma: PrismaClient,\n  datasetRows: Map<string, any[]>,\n  testRunResultIdMap: Map<number, number>,\n  issueIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"runResultIssues\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const runResultIssueRows = datasetRows.get(\"run_result_issues\") ?? [];\n\n  if (runResultIssueRows.length === 0) {\n    return summary;\n  }\n\n  summary.total = runResultIssueRows.length;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 1000);\n  let processedCount = 0;\n\n  for (let index = 0; index < runResultIssueRows.length; index += chunkSize) {\n    const chunk = runResultIssueRows.slice(index, index + chunkSize);\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          const record = row as Record<string, unknown>;\n          const resultSourceId = toNumberValue(record.result_id);\n          const issueSourceId = toNumberValue(record.issue_id);\n\n          processedCount += 1;\n          context.processedCount += 1;\n\n          if (resultSourceId === null || issueSourceId === null) {\n            continue;\n          }\n\n          const resultId = testRunResultIdMap.get(resultSourceId);\n          const issueId = issueIdMap.get(issueSourceId);\n\n          if (!resultId || !issueId) {\n            continue;\n          }\n\n          // Connect issue to test run result\n          await tx.testRunResults.update({\n            where: { id: resultId },\n            data: {\n              issues: {\n                connect: { id: issueId },\n              },\n            },\n          });\n\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    const statusMessage = `Processing test run result issues (${processedCount.toLocaleString()} / ${summary.total.toLocaleString()} processed)`;\n    await persistProgress(\"runResultIssues\", statusMessage);\n  }\n\n  return summary;\n};\n\n/**\n * Import session_issues relationships\n * Connects issues to sessions\n */\nexport const importSessionIssues = async (\n  prisma: PrismaClient,\n  datasetRows: Map<string, any[]>,\n  sessionIdMap: Map<number, number>,\n  issueIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"sessionIssues\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const sessionIssueRows = datasetRows.get(\"session_issues\") ?? [];\n\n  if (sessionIssueRows.length === 0) {\n    return summary;\n  }\n\n  summary.total = sessionIssueRows.length;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 1000);\n  let processedCount = 0;\n\n  for (let index = 0; index < sessionIssueRows.length; index += chunkSize) {\n    const chunk = sessionIssueRows.slice(index, index + chunkSize);\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          const record = row as Record<string, unknown>;\n          const sessionSourceId = toNumberValue(record.session_id);\n          const issueSourceId = toNumberValue(record.issue_id);\n\n          processedCount += 1;\n          context.processedCount += 1;\n\n          if (sessionSourceId === null || issueSourceId === null) {\n            continue;\n          }\n\n          const sessionId = sessionIdMap.get(sessionSourceId);\n          const issueId = issueIdMap.get(issueSourceId);\n\n          if (!sessionId || !issueId) {\n            continue;\n          }\n\n          // Connect issue to session\n          await tx.sessions.update({\n            where: { id: sessionId },\n            data: {\n              issues: {\n                connect: { id: issueId },\n              },\n            },\n          });\n\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    const statusMessage = `Processing session issues (${processedCount.toLocaleString()} / ${summary.total.toLocaleString()} processed)`;\n    await persistProgress(\"sessionIssues\", statusMessage);\n  }\n\n  return summary;\n};\n\n/**\n * Import session_result_issues relationships\n * Connects issues to session results\n */\nexport const importSessionResultIssues = async (\n  prisma: PrismaClient,\n  datasetRows: Map<string, any[]>,\n  sessionResultIdMap: Map<number, number>,\n  issueIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn,\n  options?: {\n    chunkSize?: number;\n    transactionTimeoutMs?: number;\n  }\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"sessionResultIssues\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const sessionResultIssueRows = datasetRows.get(\"session_result_issues\") ?? [];\n\n  if (sessionResultIssueRows.length === 0) {\n    return summary;\n  }\n\n  summary.total = sessionResultIssueRows.length;\n  const chunkSize = Math.max(1, options?.chunkSize ?? 1000);\n  let processedCount = 0;\n\n  for (let index = 0; index < sessionResultIssueRows.length; index += chunkSize) {\n    const chunk = sessionResultIssueRows.slice(index, index + chunkSize);\n\n    await prisma.$transaction(\n      async (tx: Prisma.TransactionClient) => {\n        for (const row of chunk) {\n          const record = row as Record<string, unknown>;\n          const resultSourceId = toNumberValue(record.result_id);\n          const issueSourceId = toNumberValue(record.issue_id);\n\n          processedCount += 1;\n          context.processedCount += 1;\n\n          if (resultSourceId === null || issueSourceId === null) {\n            continue;\n          }\n\n          const resultId = sessionResultIdMap.get(resultSourceId);\n          const issueId = issueIdMap.get(issueSourceId);\n\n          if (!resultId || !issueId) {\n            continue;\n          }\n\n          // Connect issue to session result\n          await tx.sessionResults.update({\n            where: { id: resultId },\n            data: {\n              issues: {\n                connect: { id: issueId },\n              },\n            },\n          });\n\n          summary.created += 1;\n        }\n      },\n      {\n        timeout: options?.transactionTimeoutMs,\n      }\n    );\n\n    const statusMessage = `Processing session result issues (${processedCount.toLocaleString()} / ${summary.total.toLocaleString()} processed)`;\n    await persistProgress(\"sessionResultIssues\", statusMessage);\n  }\n\n  return summary;\n};\n\n/**\n * Create ProjectIntegration records to connect projects to their integrations\n * This is needed so that projects can access issues from the configured integrations\n */\nexport const createProjectIntegrations = async (\n  tx: Prisma.TransactionClient,\n  datasetRows: Map<string, any[]>,\n  projectIdMap: Map<number, number>,\n  integrationIdMap: Map<number, number>,\n  context: ImportContext,\n  persistProgress: PersistProgressFn\n): Promise<EntitySummaryResult> => {\n  const summary: EntitySummaryResult = {\n    entity: \"projectIntegrations\",\n    total: 0,\n    created: 0,\n    mapped: 0,\n  };\n\n  const issueRows = datasetRows.get(\"issues\") ?? [];\n  if (issueRows.length === 0) {\n    return summary;\n  }\n\n  // Build a map of project ID -> Set of integration IDs\n  const projectIntegrationsMap = new Map<number, Set<number>>();\n\n  for (const row of issueRows) {\n    const record = row as Record<string, unknown>;\n    const targetSourceId = toNumberValue(record.target_id);\n    const projectSourceId = toNumberValue(record.project_id);\n\n    if (targetSourceId === null || projectSourceId === null) {\n      continue;\n    }\n\n    const integrationId = integrationIdMap.get(targetSourceId);\n    const projectId = projectIdMap.get(projectSourceId);\n\n    if (!integrationId || !projectId) {\n      continue;\n    }\n\n    if (!projectIntegrationsMap.has(projectId)) {\n      projectIntegrationsMap.set(projectId, new Set());\n    }\n    projectIntegrationsMap.get(projectId)!.add(integrationId);\n  }\n\n  summary.total = projectIntegrationsMap.size;\n  let processedSinceLastPersist = 0;\n\n  // Create ProjectIntegration records\n  for (const [projectId, integrationIds] of projectIntegrationsMap) {\n    for (const integrationId of integrationIds) {\n      // Check if connection already exists\n      const existing = await tx.projectIntegration.findFirst({\n        where: {\n          projectId,\n          integrationId,\n        },\n      });\n\n      if (!existing) {\n        await tx.projectIntegration.create({\n          data: {\n            projectId,\n            integrationId,\n            isActive: true,\n          },\n        });\n        summary.created += 1;\n      } else {\n        summary.mapped += 1;\n      }\n\n      processedSinceLastPersist += 1;\n      if (processedSinceLastPersist >= PROGRESS_UPDATE_INTERVAL) {\n        await persistProgress(\"projectIntegrations\");\n        processedSinceLastPersist = 0;\n      }\n    }\n  }\n\n  if (processedSinceLastPersist > 0) {\n    await persistProgress(\"projectIntegrations\");\n  }\n\n  return summary;\n};\n"],
  "mappings": "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",
  "names": ["import_bullmq", "import_client", "import_core", "import_model", "import_happy_dom", "import_starter_kit", "import_node_url", "IORedis", "prisma", "data", "processor", "Assembler", "prisma", "value", "toStringValue", "existing", "variantIds", "createdCount", "import_client", "prisma", "toStringValue", "StarterKit", "HappyDOMWindow", "parser", "PMDOMParser", "toStringValue", "import_client", "existing", "toStringValue", "import_client", "existing", "toStringValue", "prisma", "projectNameCache", "templateNameCache", "workflowNameCache", "userNameCache", "folderNameCache", "getProjectName", "getTemplateName", "getWorkflowName", "getUserName", "getFolderName", "SYSTEM_NAME_REGEX", "PROGRESS_UPDATE_INTERVAL", "generateSystemName", "TIPTAP_EXTENSIONS", "StarterKit", "sharedHappyDOMWindow", "sharedDOMParser", "getSharedHappyDOM", "HappyDOMWindow", "parser", "PMDOMParser", "result", "bcrypt", "toStringValue", "templateName", "createResult", "persistedPairs", "createReadStream"]
}
