{
  "version": 3,
  "sources": ["../../lib/prismaBase.ts", "../../workers/elasticsearchReindexWorker.ts", "../../lib/valkey.ts", "../../lib/queueNames.ts", "../../services/elasticsearchService.ts", "../../env.js", "../../services/elasticsearchIndexing.ts", "../../utils/extractTextFromJson.ts", "../../services/unifiedElasticsearchService.ts", "../../services/repositoryCaseSync.ts", "../../services/sharedStepSearch.ts", "../../services/testRunSearch.ts", "../../services/sessionSearch.ts", "../../services/issueSearch.ts", "../../services/milestoneSearch.ts", "../../services/projectSearch.ts", "../../lib/multiTenantPrisma.ts"],
  "sourcesContent": ["// lib/prismaBase.ts\n// Base Prisma client without Elasticsearch sync extensions\n// Use this for workers and services that don't need auto-ES sync\n\nimport { PrismaClient } from \"@prisma/client\";\n\n// Declare global types\ndeclare global {\n  var prismaBase: PrismaClient | undefined;\n}\n\nlet prismaClient: PrismaClient;\n\n// Create a simple PrismaClient without extensions\nif (process.env.NODE_ENV === \"production\") {\n  prismaClient = new PrismaClient({ errorFormat: \"pretty\" });\n} else {\n  // Reuse global instance in development to prevent hot-reload issues\n  if (!global.prismaBase) {\n    global.prismaBase = new PrismaClient({ errorFormat: \"colorless\" });\n  }\n  prismaClient = global.prismaBase;\n}\n\nexport const prisma = prismaClient;\n", "import { Worker, Job } from \"bullmq\";\nimport valkeyConnection from \"../lib/valkey\";\nimport { ELASTICSEARCH_REINDEX_QUEUE_NAME } from \"../lib/queueNames\";\nimport {\n  syncProjectCasesToElasticsearch,\n  initializeElasticsearchIndexes,\n} from \"~/services/repositoryCaseSync\";\nimport { syncProjectSharedStepsToElasticsearch } from \"~/services/sharedStepSearch\";\nimport { syncProjectTestRunsToElasticsearch } from \"~/services/testRunSearch\";\nimport { syncProjectSessionsToElasticsearch } from \"~/services/sessionSearch\";\nimport { syncProjectIssuesToElasticsearch } from \"~/services/issueSearch\";\nimport { syncProjectMilestonesToElasticsearch } from \"~/services/milestoneSearch\";\nimport { syncAllProjectsToElasticsearch } from \"~/services/projectSearch\";\nimport { getElasticsearchClient } from \"~/services/elasticsearchService\";\nimport { pathToFileURL } from \"node:url\";\nimport {\n  getPrismaClientForJob,\n  isMultiTenantMode,\n  MultiTenantJobData,\n  disconnectAllTenantClients,\n  validateMultiTenantJobData,\n} from \"../lib/multiTenantPrisma\";\n\nexport interface ReindexJobData extends MultiTenantJobData {\n  entityType: \"all\" | \"repositoryCases\" | \"testRuns\" | \"sessions\" | \"sharedSteps\" | \"issues\" | \"milestones\" | \"projects\";\n  projectId?: number;\n  userId: string; // User who initiated the reindex\n}\n\nconst processor = async (job: Job<ReindexJobData>) => {\n  console.log(`Processing Elasticsearch reindex job ${job.id}${job.data.tenantId ? ` for tenant ${job.data.tenantId}` : \"\"}`);\n\n  // Validate multi-tenant job data if in multi-tenant mode\n  validateMultiTenantJobData(job.data);\n\n  // Get the appropriate Prisma client (tenant-specific or default)\n  const prisma = getPrismaClientForJob(job.data);\n\n  const { entityType, projectId, tenantId } = job.data;\n\n  try {\n    // Check Elasticsearch connection\n    const esClient = getElasticsearchClient();\n    if (!esClient) {\n      throw new Error(\"Elasticsearch is not configured or unavailable\");\n    }\n\n    await job.updateProgress(0);\n    await job.log(\"Starting reindex operation...\");\n\n    // Initialize indexes if needed\n    if (entityType === \"all\" || entityType === \"repositoryCases\") {\n      await job.updateProgress(5);\n      await job.log(\"Initializing Elasticsearch indexes...\");\n      await initializeElasticsearchIndexes(prisma, tenantId);\n    }\n\n    const projects = projectId\n      ? await prisma.projects.findMany({\n          where: { id: projectId, isDeleted: false }\n        })\n      : await prisma.projects.findMany({\n          where: { isDeleted: false }\n        });\n\n    await job.updateProgress(10);\n    await job.log(`Found ${projects.length} projects to process`);\n\n    const results = {\n      projects: 0,\n      repositoryCases: 0,\n      sharedSteps: 0,\n      testRuns: 0,\n      sessions: 0,\n      issues: 0,\n      milestones: 0,\n    };\n\n    // Count total documents for accurate progress tracking\n    const totalCounts: Record<string, number> = {};\n    for (const project of projects) {\n      if (entityType === \"all\" || entityType === \"repositoryCases\") {\n        totalCounts.repositoryCases = (totalCounts.repositoryCases || 0) + await prisma.repositoryCases.count({\n          where: { projectId: project.id, isDeleted: false, isArchived: false }\n        });\n      }\n      if (entityType === \"all\" || entityType === \"sharedSteps\") {\n        totalCounts.sharedSteps = (totalCounts.sharedSteps || 0) + await prisma.sharedStepGroup.count({\n          where: { projectId: project.id, isDeleted: false }\n        });\n      }\n      if (entityType === \"all\" || entityType === \"testRuns\") {\n        totalCounts.testRuns = (totalCounts.testRuns || 0) + await prisma.testRuns.count({\n          where: { projectId: project.id, isDeleted: false }\n        });\n      }\n      if (entityType === \"all\" || entityType === \"sessions\") {\n        totalCounts.sessions = (totalCounts.sessions || 0) + await prisma.sessions.count({\n          where: { projectId: project.id, isDeleted: false }\n        });\n      }\n      if (entityType === \"all\" || entityType === \"issues\") {\n        totalCounts.issues = (totalCounts.issues || 0) + await prisma.issue.count({\n          where: { isDeleted: false, testRuns: { some: { projectId: project.id } } }\n        });\n      }\n      if (entityType === \"all\" || entityType === \"milestones\") {\n        totalCounts.milestones = (totalCounts.milestones || 0) + await prisma.milestones.count({\n          where: { projectId: project.id, isDeleted: false }\n        });\n      }\n    }\n\n    const totalDocuments = Object.values(totalCounts).reduce((a, b) => a + b, 0);\n    let processedDocuments = 0;\n\n    let currentProgress = 10;\n    const progressPerProject = 80 / projects.length;\n\n    // Reindex based on entity type\n    if (entityType === \"all\" || entityType === \"projects\") {\n      await job.updateProgress(currentProgress);\n      await job.log(\"Indexing projects...\");\n      await syncAllProjectsToElasticsearch(prisma, tenantId);\n      results.projects = await prisma.projects.count({\n        where: { isDeleted: false }\n      });\n    }\n\n    for (const project of projects) {\n      const projectStart = currentProgress;\n\n      await job.updateProgress(currentProgress);\n      await job.log(`Processing project: ${project.name}`);\n\n      if (entityType === \"all\" || entityType === \"repositoryCases\") {\n        const count = await prisma.repositoryCases.count({\n          where: {\n            projectId: project.id,\n            isDeleted: false,\n            isArchived: false,\n          },\n        });\n        if (count > 0) {\n          await job.log(`Syncing ${count} repository cases for project ${project.name}`);\n\n          // Create progress callback that updates job progress\n          const progressCallback = async (processed: number, total: number, message: string) => {\n            processedDocuments = results.repositoryCases + processed;\n            const overallProgress = 10 + ((processedDocuments / totalDocuments) * 80);\n            await job.updateProgress(Math.min(overallProgress, 90));\n            await job.log(message);\n          };\n\n          await syncProjectCasesToElasticsearch(project.id, 100, progressCallback, prisma, tenantId);\n          results.repositoryCases += count;\n          processedDocuments = results.repositoryCases;\n        }\n      }\n\n      if (entityType === \"all\" || entityType === \"sharedSteps\") {\n        const count = await prisma.sharedStepGroup.count({\n          where: {\n            projectId: project.id,\n            isDeleted: false,\n          },\n        });\n        if (count > 0) {\n          await job.log(`Syncing ${count} shared steps for project ${project.name}`);\n          await syncProjectSharedStepsToElasticsearch(project.id, 100, prisma, tenantId);\n          results.sharedSteps += count;\n        }\n      }\n\n      if (entityType === \"all\" || entityType === \"testRuns\") {\n        const count = await prisma.testRuns.count({\n          where: {\n            projectId: project.id,\n            isDeleted: false,\n          },\n        });\n        if (count > 0) {\n          await job.log(`Syncing ${count} test runs for project ${project.name}`);\n          await syncProjectTestRunsToElasticsearch(project.id, prisma, tenantId);\n          results.testRuns += count;\n        }\n      }\n\n      if (entityType === \"all\" || entityType === \"sessions\") {\n        const count = await prisma.sessions.count({\n          where: {\n            projectId: project.id,\n            isDeleted: false,\n          },\n        });\n        if (count > 0) {\n          await job.log(`Syncing ${count} sessions for project ${project.name}`);\n          await syncProjectSessionsToElasticsearch(project.id, prisma, tenantId);\n          results.sessions += count;\n        }\n      }\n\n      if (entityType === \"all\" || entityType === \"issues\") {\n        const count = await prisma.issue.count({\n          where: {\n            isDeleted: false,\n            testRuns: {\n              some: {\n                projectId: project.id,\n              },\n            },\n          },\n        });\n        if (count > 0) {\n          await job.log(`Syncing ${count} issues for project ${project.name}`);\n          await syncProjectIssuesToElasticsearch(project.id, prisma, tenantId);\n          results.issues += count;\n        }\n      }\n\n      if (entityType === \"all\" || entityType === \"milestones\") {\n        const count = await prisma.milestones.count({\n          where: {\n            projectId: project.id,\n            isDeleted: false,\n          },\n        });\n        if (count > 0) {\n          await job.log(`Syncing ${count} milestones for project ${project.name}`);\n          await syncProjectMilestonesToElasticsearch(project.id, prisma, tenantId);\n          results.milestones += count;\n        }\n      }\n\n      currentProgress = projectStart + progressPerProject;\n      await job.updateProgress(Math.min(currentProgress, 90));\n      await job.log(`Completed project: ${project.name}`);\n    }\n\n    // Final completion\n    await job.updateProgress(100);\n    await job.log(\"Reindex completed successfully!\");\n\n    const finalTotalDocuments = Object.values(results).reduce((a, b) => a + b, 0);\n    console.log(`Reindex job ${job.id} completed. Indexed ${finalTotalDocuments} documents.`);\n\n    return {\n      success: true,\n      results,\n      totalDocuments: finalTotalDocuments,\n    };\n  } catch (error: any) {\n    console.error(`Reindex job ${job.id} failed:`, error);\n    await job.log(`Error: ${error.message}`);\n    throw error;\n  }\n};\n\nlet worker: Worker | null = null;\n\n// Function to start the worker\nconst startWorker = async () => {\n  // Log multi-tenant mode status\n  if (isMultiTenantMode()) {\n    console.log(\"Elasticsearch reindex worker starting in MULTI-TENANT mode\");\n  } else {\n    console.log(\"Elasticsearch reindex worker starting in SINGLE-TENANT mode\");\n  }\n\n  if (valkeyConnection) {\n    worker = new Worker(ELASTICSEARCH_REINDEX_QUEUE_NAME, processor, {\n      connection: valkeyConnection,\n      concurrency: 2, // Process 2 reindex jobs at a time\n      lockDuration: 3600000, // 1 hour - allows for very large reindex operations\n      maxStalledCount: 1, // Reduce automatic stalled job retries\n      stalledInterval: 300000, // Check for stalled jobs every 5 minutes\n    });\n\n    worker.on(\"completed\", (job) => {\n      console.log(`Elasticsearch reindex job ${job.id} completed successfully.`);\n    });\n\n    worker.on(\"failed\", (job, err) => {\n      console.error(`Elasticsearch reindex job ${job?.id} failed:`, err);\n    });\n\n    worker.on(\"error\", (err) => {\n      console.error(\"Elasticsearch reindex worker error:\", err);\n    });\n\n    console.log(`Elasticsearch reindex worker started for queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\".`);\n  } else {\n    console.warn(\"Valkey connection not available. Elasticsearch reindex worker not started.\");\n  }\n\n  // Allow graceful shutdown\n  process.on(\"SIGINT\", async () => {\n    console.log(\"Shutting down Elasticsearch reindex worker...\");\n    if (worker) {\n      await worker.close();\n    }\n    // Disconnect all tenant Prisma clients in multi-tenant mode\n    if (isMultiTenantMode()) {\n      await disconnectAllTenantClients();\n    }\n    process.exit(0);\n  });\n};\n\n// Run the worker if this file is executed directly (works with both ESM and CommonJS)\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  (typeof import.meta === \"undefined\" ||\n    (import.meta as any).url === undefined)\n) {\n  console.log(\"Elasticsearch reindex worker running...\");\n  startWorker().catch((err) => {\n    console.error(\"Failed to start Elasticsearch reindex worker:\", err);\n    process.exit(1);\n  });\n}\n\nexport default worker;\n", "import IORedis from \"ioredis\";\n\n// Check if we should skip Valkey connection (useful during build)\nconst skipConnection = process.env.SKIP_VALKEY_CONNECTION === \"true\";\n\n// Get Valkey URL from environment\nconst valkeyUrl = process.env.VALKEY_URL;\n\nif (!valkeyUrl && !skipConnection) {\n  // Log an error, but maybe don't throw immediately\n  // depending on whether Valkey is strictly required at startup\n  console.error(\n    \"VALKEY_URL environment variable is not set. Background jobs may fail.\"\n  );\n  // Optional: throw new Error('VALKEY_URL environment variable is not set.');\n}\n\n// Configure the connection options\nconst connectionOptions = {\n  maxRetriesPerRequest: null, // Required by BullMQ\n  enableReadyCheck: false, // Optional: Sometimes helps with startup race conditions\n};\n\nlet valkeyConnection: IORedis | null = null;\n\nif (valkeyUrl && !skipConnection) {\n  // Convert valkey:// to redis:// for ioredis compatibility\n  // ioredis expects redis:// protocol but we're connecting to Valkey\n  const connectionUrl = valkeyUrl.replace(/^valkey:\\/\\//, 'redis://');\n  \n  // Create and export the connection instance only if URL is provided\n  valkeyConnection = new IORedis(connectionUrl, connectionOptions);\n\n  valkeyConnection.on(\"connect\", () => {\n    console.log(\"Successfully connected to Valkey.\");\n  });\n\n  valkeyConnection.on(\"error\", (err) => {\n    console.error(\"Valkey connection error:\", err);\n  });\n} else {\n  console.warn(\"Valkey URL not provided. Valkey connection not established.\");\n}\n\nexport default valkeyConnection;", "// Queue name constants - no initialization, just names\nexport const FORECAST_QUEUE_NAME = \"forecast-updates\";\nexport const NOTIFICATION_QUEUE_NAME = \"notifications\";\nexport const EMAIL_QUEUE_NAME = \"emails\";\nexport const SYNC_QUEUE_NAME = \"issue-sync\";\nexport const TESTMO_IMPORT_QUEUE_NAME = \"testmo-imports\";\nexport const ELASTICSEARCH_REINDEX_QUEUE_NAME = \"elasticsearch-reindex\";\n", "import { Client } from \"@elastic/elasticsearch\";\nimport { env } from \"../env.js\";\nimport { prisma as defaultPrisma } from \"../lib/prismaBase\";\n\ntype PrismaClientType = typeof defaultPrisma;\n\n// Create singleton instance\nlet esClient: Client | null = null;\n\n/**\n * Get or create Elasticsearch client instance\n */\nexport function getElasticsearchClient(): Client | null {\n  if (!env.ELASTICSEARCH_NODE) {\n    console.warn(\n      \"ELASTICSEARCH_NODE environment variable not set. Elasticsearch integration disabled.\"\n    );\n    return null;\n  }\n\n  if (!esClient) {\n    try {\n      esClient = new Client({\n        node: env.ELASTICSEARCH_NODE,\n        // Add additional configuration as needed\n        maxRetries: 3,\n        requestTimeout: 30000,\n        sniffOnStart: false, // Disable sniffing for custom ports\n      });\n\n    } catch (error) {\n      console.error(\"Failed to initialize Elasticsearch client:\", error);\n      return null;\n    }\n  }\n\n  return esClient;\n}\n\n/**\n * Test Elasticsearch connection\n */\nexport async function testElasticsearchConnection(): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  try {\n    const response = await client.ping();\n    return true;\n  } catch (error) {\n    console.error(\"Elasticsearch connection failed:\", error);\n    return false;\n  }\n}\n\n/**\n * Repository Case index configuration\n */\nexport const REPOSITORY_CASE_INDEX = \"testplanit-repository-cases\";\n\n/**\n * Get the repository case index name, optionally prefixed with tenant ID\n * In multi-tenant mode: testplanit-{tenantId}-repository-cases\n * In single-tenant mode: testplanit-repository-cases\n */\nexport function getRepositoryCaseIndexName(tenantId?: string): string {\n  if (tenantId) {\n    return `testplanit-${tenantId}-repository-cases`;\n  }\n  return REPOSITORY_CASE_INDEX;\n}\n\n/**\n * Repository Case mapping for Elasticsearch\n */\nexport const repositoryCaseMapping = {\n  properties: {\n    id: { type: \"integer\" as const },\n    projectId: { type: \"integer\" as const },\n    projectName: { type: \"keyword\" as const },\n    projectIconUrl: { type: \"keyword\" as const },\n    repositoryId: { type: \"integer\" as const },\n    folderId: { type: \"integer\" as const },\n    folderPath: { type: \"keyword\" as const },\n    templateId: { type: \"integer\" as const },\n    templateName: { type: \"keyword\" as const },\n    name: {\n      type: \"text\" as const,\n      analyzer: \"standard\",\n      fields: {\n        keyword: { type: \"keyword\" as const },\n        suggest: { type: \"completion\" as const },\n      },\n    },\n    className: { type: \"keyword\" as const },\n    source: { type: \"keyword\" as const },\n    stateId: { type: \"integer\" as const },\n    stateName: { type: \"keyword\" as const },\n    stateIcon: { type: \"keyword\" as const },\n    stateColor: { type: \"keyword\" as const },\n    estimate: { type: \"integer\" as const },\n    forecastManual: { type: \"integer\" as const },\n    forecastAutomated: { type: \"float\" as const },\n    automated: { type: \"boolean\" as const },\n    isArchived: { type: \"boolean\" as const },\n    isDeleted: { type: \"boolean\" as const },\n    createdAt: { type: \"date\" as const },\n    creatorId: { type: \"keyword\" as const },\n    creatorName: { type: \"text\" as const },\n    tags: {\n      type: \"nested\" as const,\n      properties: {\n        id: { type: \"integer\" as const },\n        name: { type: \"keyword\" as const },\n      },\n    },\n    customFields: {\n      type: \"nested\" as const,\n      properties: {\n        fieldId: { type: \"integer\" as const },\n        fieldName: { type: \"keyword\" as const },\n        fieldType: { type: \"keyword\" as const },\n        value: { type: \"text\" as const },\n      },\n    },\n    steps: {\n      type: \"nested\" as const,\n      properties: {\n        id: { type: \"integer\" as const },\n        order: { type: \"integer\" as const },\n        step: { type: \"text\" as const },\n        expectedResult: { type: \"text\" as const },\n        isSharedStep: { type: \"boolean\" as const },\n        sharedStepGroupId: { type: \"integer\" as const },\n        sharedStepGroupName: { type: \"text\" as const },\n      },\n    },\n    // Full-text search field combining multiple fields\n    searchableContent: { type: \"text\" as const },\n  },\n};\n\n/**\n * Get Elasticsearch replica settings from database\n */\nasync function getElasticsearchSettings(prismaClient?: PrismaClientType) {\n  const prisma = prismaClient || defaultPrisma;\n  try {\n    const config = await prisma.appConfig.findUnique({\n      where: { key: \"elasticsearch_replicas\" }\n    });\n\n    // Default to 0 for single-node clusters\n    return {\n      numberOfReplicas: config?.value ? (config.value as number) : 0\n    };\n  } catch (error) {\n    console.warn(\"Failed to get Elasticsearch settings from database, using defaults:\", error);\n    return { numberOfReplicas: 0 };\n  }\n}\n\n/**\n * Create or update the repository cases index\n * @param prismaClient - Optional Prisma client for getting settings\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function createRepositoryCaseIndex(\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = getRepositoryCaseIndexName(tenantId);\n\n  try {\n    // Get settings from database\n    const settings = await getElasticsearchSettings(prismaClient);\n\n    // Check if index exists\n    const exists = await client.indices.exists({\n      index: indexName,\n    });\n\n    if (!exists) {\n      // Create index with mapping\n      await client.indices.create({\n        index: indexName,\n        settings: {\n          number_of_shards: 1,\n          number_of_replicas: settings.numberOfReplicas,\n          analysis: {\n            analyzer: {\n              standard: {\n                type: \"standard\",\n                stopwords: \"_english_\",\n              },\n            },\n          },\n        },\n        mappings: repositoryCaseMapping,\n      });\n      console.log(`Created Elasticsearch index: ${indexName}`);\n    } else {\n      // Index already exists, skip update to avoid field type conflicts\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Failed to create/update Elasticsearch index ${indexName}:`, error);\n    return false;\n  }\n}\n\n/**\n * Interface for indexing repository case data\n */\nexport interface RepositoryCaseDocument {\n  id: number;\n  projectId: number;\n  projectName: string;\n  projectIconUrl?: string | null;\n  repositoryId: number;\n  folderId: number;\n  folderPath: string;\n  templateId: number;\n  templateName: string;\n  name: string;\n  className?: string | null;\n  source: string;\n  stateId: number;\n  stateName: string;\n  stateIcon?: string;\n  stateColor?: string;\n  estimate?: number | null;\n  forecastManual?: number | null;\n  forecastAutomated?: number | null;\n  automated: boolean;\n  isArchived: boolean;\n  isDeleted: boolean;\n  createdAt: Date;\n  creatorId: string;\n  creatorName: string;\n  creatorImage?: string | null;\n  tags?: Array<{ id: number; name: string }>;\n  customFields?: Array<{\n    fieldId: number;\n    fieldName: string;\n    fieldType: string;\n    value: any;\n  }>;\n  steps?: Array<{\n    id: number;\n    order: number;\n    step: string;\n    expectedResult: string;\n    isSharedStep?: boolean;\n    sharedStepGroupId?: number;\n    sharedStepGroupName?: string;\n  }>;\n  searchableContent?: string;\n}\n", "import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod/v4\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z\n      .string()\n      .refine(\n        (str) => !str.includes(\"YOUR_MYSQL_URL_HERE\"),\n        \"You forgot to change the default URL\",\n      ),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .prefault(\"development\"),\n    NEXTAUTH_SECRET:\n      process.env.NODE_ENV === \"production\"\n        ? z.string()\n        : z.string().optional(),\n    NEXTAUTH_URL: z.preprocess(\n      // This makes Vercel deployments not fail if you don't set NEXTAUTH_URL\n      // Since NextAuth.js automatically uses the VERCEL_URL if present.\n      (str) => process.env.VERCEL_URL ?? str,\n      // VERCEL_URL doesn't include `https` so it cant be validated as a URL\n      process.env.VERCEL ? z.string() : z.url(),\n    ),\n    ELASTICSEARCH_NODE: z.url().optional(),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,\n    NEXTAUTH_URL: process.env.NEXTAUTH_URL,\n    ELASTICSEARCH_NODE: process.env.ELASTICSEARCH_NODE,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n", "import {\n  getElasticsearchClient,\n  getRepositoryCaseIndexName,\n  RepositoryCaseDocument,\n} from \"./elasticsearchService\";\n\n/**\n * Index a repository case in Elasticsearch\n * @param caseData - The repository case data to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function indexRepositoryCase(\n  caseData: RepositoryCaseDocument,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = getRepositoryCaseIndexName(tenantId);\n\n  try {\n    // Build searchable content from various fields\n    const searchableContent = [\n      caseData.name,\n      caseData.className,\n      caseData.tags?.map((t) => t.name).join(\" \"),\n      caseData.steps?.map((s) => {\n        const stepContent = `${s.step} ${s.expectedResult}`;\n        // Include shared step group name if it's a shared step\n        return s.isSharedStep && s.sharedStepGroupName\n          ? `${stepContent} ${s.sharedStepGroupName}`\n          : stepContent;\n      }).join(\" \"),\n      caseData.customFields?.map((cf) => cf.value).join(\" \"),\n    ]\n      .filter(Boolean)\n      .join(\" \");\n\n    await client.index({\n      index: indexName,\n      id: caseData.id.toString(),\n      document: {\n        ...caseData,\n        searchableContent,\n      },\n    });\n\n    console.log(`Indexed repository case ${caseData.id} in Elasticsearch`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to index repository case ${caseData.id}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index repository cases\n * @param cases - Array of repository case data to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function bulkIndexRepositoryCases(\n  cases: RepositoryCaseDocument[],\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client || cases.length === 0) return false;\n\n  const indexName = getRepositoryCaseIndexName(tenantId);\n\n  try {\n    const operations = cases.flatMap((caseData) => {\n      // Build searchable content\n      const searchableContent = [\n        caseData.name,\n        caseData.className,\n        caseData.tags?.map((t) => t.name).join(\" \"),\n        caseData.steps?.map((s) => {\n          const stepContent = `${s.step} ${s.expectedResult}`;\n          // Include shared step group name if it's a shared step\n          return s.isSharedStep && s.sharedStepGroupName\n            ? `${stepContent} ${s.sharedStepGroupName}`\n            : stepContent;\n        }).join(\" \"),\n        caseData.customFields?.map((cf) => cf.value).join(\" \"),\n      ]\n        .filter(Boolean)\n        .join(\" \");\n\n      return [\n        {\n          index: { _index: indexName, _id: caseData.id.toString() },\n        },\n        { ...caseData, searchableContent },\n      ];\n    });\n\n    const bulkResponse = await client.bulk({\n      operations,\n      refresh: true,\n    });\n\n    if (bulkResponse.errors) {\n      const errorItems = bulkResponse.items.filter((item) => item.index?.error);\n      console.error(\"Bulk indexing errors:\", errorItems);\n      // Log detailed error information\n      errorItems.forEach((item) => {\n        if (item.index?.error) {\n          console.error(`Failed to index document ${item.index._id}:`);\n          console.error(`  Error type: ${item.index.error.type}`);\n          console.error(`  Error reason: ${item.index.error.reason}`);\n        }\n      });\n      return false;\n    }\n\n    console.log(\n      `Bulk indexed ${cases.length} repository cases in Elasticsearch`\n    );\n    return true;\n  } catch (error) {\n    console.error(\"Failed to bulk index repository cases:\", error);\n    return false;\n  }\n}\n\n/**\n * Delete a repository case from Elasticsearch\n * @param caseId - The ID of the repository case to delete\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function deleteRepositoryCase(\n  caseId: number,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = getRepositoryCaseIndexName(tenantId);\n\n  try {\n    await client.delete({\n      index: indexName,\n      id: caseId.toString(),\n    });\n\n    console.log(`Deleted repository case ${caseId} from Elasticsearch`);\n    return true;\n  } catch (error) {\n    // 404 is expected if document doesn't exist\n    if ((error as any).statusCode === 404) {\n      console.log(\n        `Repository case ${caseId} not found in Elasticsearch (already deleted)`\n      );\n      return true;\n    }\n    console.error(`Failed to delete repository case ${caseId}:`, error);\n    return false;\n  }\n}\n", "/**\n * Recursively extracts text content from a JSON node structure\n * (commonly used in Tiptap/ProseMirror).\n */\nexport const extractTextFromNode = (node: any): string => {\n  if (!node) return \"\";\n\n  // If the node itself is just a string, return it\n  if (typeof node === \"string\") return node;\n\n  // If the node has a direct text property, return it\n  if (node.text && typeof node.text === \"string\") return node.text;\n\n  // If the node has a content array, recursively process each item\n  if (node.content && Array.isArray(node.content)) {\n    return node.content.map(extractTextFromNode).join(\"\"); // Join without spaces for raw text\n  }\n\n  // Return empty string if no text found or structure is unexpected\n  return \"\";\n};\n", "import { Client } from \"@elastic/elasticsearch\";\nimport { SearchableEntityType, CustomFieldDocument } from \"~/types/search\";\nimport { getElasticsearchClient } from \"./elasticsearchService\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\n\ntype PrismaClientType = typeof defaultPrisma;\n\n// Re-export for convenience\nexport { getElasticsearchClient };\n\n// Base index names for each entity type (without tenant prefix)\nexport const BASE_INDEX_NAMES = {\n  [SearchableEntityType.REPOSITORY_CASE]: \"repository-cases\",\n  [SearchableEntityType.SHARED_STEP]: \"shared-steps\",\n  [SearchableEntityType.TEST_RUN]: \"test-runs\",\n  [SearchableEntityType.SESSION]: \"sessions\",\n  [SearchableEntityType.PROJECT]: \"projects\",\n  [SearchableEntityType.ISSUE]: \"issues\",\n  [SearchableEntityType.MILESTONE]: \"milestones\",\n} as const;\n\n/**\n * Get the index name for an entity type, optionally prefixed with tenant ID\n * In multi-tenant mode: testplanit-{tenantId}-{entityType}\n * In single-tenant mode: testplanit-{entityType}\n */\nexport function getEntityIndexName(\n  entityType: SearchableEntityType,\n  tenantId?: string\n): string {\n  const baseName = BASE_INDEX_NAMES[entityType];\n  if (tenantId) {\n    return `testplanit-${tenantId}-${baseName}`;\n  }\n  return `testplanit-${baseName}`;\n}\n\n// Legacy constant for backward compatibility (single-tenant mode)\n// @deprecated Use getEntityIndexName() instead for multi-tenant support\nexport const ENTITY_INDICES = {\n  [SearchableEntityType.REPOSITORY_CASE]: \"testplanit-repository-cases\",\n  [SearchableEntityType.SHARED_STEP]: \"testplanit-shared-steps\",\n  [SearchableEntityType.TEST_RUN]: \"testplanit-test-runs\",\n  [SearchableEntityType.SESSION]: \"testplanit-sessions\",\n  [SearchableEntityType.PROJECT]: \"testplanit-projects\",\n  [SearchableEntityType.ISSUE]: \"testplanit-issues\",\n  [SearchableEntityType.MILESTONE]: \"testplanit-milestones\",\n} as const;\n\n// Base mapping for all entities\nconst baseMapping = {\n  properties: {\n    id: { type: \"integer\" as const },\n    projectId: { type: \"integer\" as const },\n    projectName: { type: \"keyword\" as const },\n    projectIconUrl: { type: \"keyword\" as const },\n    createdAt: { type: \"date\" as const },\n    updatedAt: { type: \"date\" as const },\n    createdById: { type: \"keyword\" as const },\n    createdByName: { type: \"keyword\" as const },\n    createdByImage: { type: \"keyword\" as const },\n    searchableContent: {\n      type: \"text\" as const,\n      analyzer: \"standard\",\n      fields: {\n        keyword: {\n          type: \"keyword\" as const,\n          ignore_above: 256,\n        },\n      },\n    },\n    customFields: {\n      type: \"nested\" as const,\n      properties: {\n        fieldId: { type: \"integer\" as const },\n        fieldName: { type: \"keyword\" as const },\n        fieldType: { type: \"keyword\" as const },\n        value: { type: \"text\" as const },\n        valueKeyword: { type: \"keyword\" as const },\n        valueNumeric: { type: \"double\" as const },\n        valueBoolean: { type: \"boolean\" as const },\n        valueDate: { type: \"date\" as const },\n        valueArray: { type: \"keyword\" as const },\n        fieldOption: {\n          type: \"object\" as const,\n          properties: {\n            id: { type: \"integer\" as const },\n            name: { type: \"keyword\" as const },\n            icon: {\n              type: \"object\" as const,\n              properties: {\n                name: { type: \"keyword\" as const },\n              },\n            },\n            iconColor: {\n              type: \"object\" as const,\n              properties: {\n                value: { type: \"keyword\" as const },\n              },\n            },\n          },\n        },\n        fieldOptions: {\n          type: \"nested\" as const,\n          properties: {\n            id: { type: \"integer\" as const },\n            name: { type: \"keyword\" as const },\n            icon: {\n              type: \"object\" as const,\n              properties: {\n                name: { type: \"keyword\" as const },\n              },\n            },\n            iconColor: {\n              type: \"object\" as const,\n              properties: {\n                value: { type: \"keyword\" as const },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n};\n\n// Entity-specific mappings\nexport const ENTITY_MAPPINGS = {\n  [SearchableEntityType.REPOSITORY_CASE]: {\n    properties: {\n      ...baseMapping.properties,\n      repositoryId: { type: \"integer\" as const },\n      folderId: { type: \"integer\" as const },\n      folderPath: { type: \"keyword\" as const },\n      templateId: { type: \"integer\" as const },\n      templateName: { type: \"keyword\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      className: { type: \"keyword\" as const },\n      source: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      estimate: { type: \"integer\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      automated: { type: \"boolean\" as const },\n      isArchived: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n      steps: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          order: { type: \"integer\" as const },\n          step: { type: \"text\" as const },\n          expectedResult: { type: \"text\" as const },\n          isSharedStep: { type: \"boolean\" as const },\n          sharedStepGroupId: { type: \"integer\" as const },\n          sharedStepGroupName: { type: \"text\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.SHARED_STEP]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      isDeleted: { type: \"boolean\" as const },\n      items: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          order: { type: \"integer\" as const },\n          step: { type: \"text\" as const },\n          expectedResult: { type: \"text\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.TEST_RUN]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      configId: { type: \"integer\" as const },\n      configurationName: { type: \"keyword\" as const },\n      milestoneId: { type: \"integer\" as const },\n      milestoneName: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      elapsed: { type: \"integer\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      testRunType: { type: \"keyword\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.SESSION]: {\n    properties: {\n      ...baseMapping.properties,\n      templateId: { type: \"integer\" as const },\n      templateName: { type: \"keyword\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      mission: { type: \"text\" as const },\n      configId: { type: \"integer\" as const },\n      configurationName: { type: \"keyword\" as const },\n      milestoneId: { type: \"integer\" as const },\n      milestoneName: { type: \"keyword\" as const },\n      stateId: { type: \"integer\" as const },\n      stateName: { type: \"keyword\" as const },\n      stateIcon: { type: \"keyword\" as const },\n      stateColor: { type: \"keyword\" as const },\n      assignedToId: { type: \"keyword\" as const },\n      assignedToName: { type: \"keyword\" as const },\n      assignedToImage: { type: \"keyword\" as const },\n      estimate: { type: \"integer\" as const },\n      forecastManual: { type: \"integer\" as const },\n      forecastAutomated: { type: \"float\" as const },\n      elapsed: { type: \"integer\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      tags: {\n        type: \"nested\" as const,\n        properties: {\n          id: { type: \"integer\" as const },\n          name: { type: \"keyword\" as const },\n        },\n      },\n    },\n  },\n  [SearchableEntityType.PROJECT]: {\n    properties: {\n      id: { type: \"integer\" as const },\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      iconUrl: { type: \"keyword\" as const },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      isDeleted: { type: \"boolean\" as const },\n      createdAt: { type: \"date\" as const },\n      createdById: { type: \"keyword\" as const },\n      createdByName: { type: \"keyword\" as const },\n      createdByImage: { type: \"keyword\" as const },\n      searchableContent: { type: \"text\" as const },\n    },\n  },\n  [SearchableEntityType.ISSUE]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      title: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      description: { type: \"text\" as const },\n      externalId: { type: \"keyword\" as const },\n      note: { type: \"text\" as const },\n      url: { type: \"keyword\" as const },\n      issueSystem: { type: \"text\" as const },\n      isDeleted: { type: \"boolean\" as const },\n    },\n  },\n  [SearchableEntityType.MILESTONE]: {\n    properties: {\n      ...baseMapping.properties,\n      name: {\n        type: \"text\" as const,\n        analyzer: \"standard\",\n        fields: {\n          keyword: {\n            type: \"keyword\" as const,\n            ignore_above: 256,\n          },\n        },\n      },\n      note: { type: \"text\" as const },\n      docs: { type: \"text\" as const },\n      milestoneTypeId: { type: \"integer\" as const },\n      milestoneTypeName: { type: \"keyword\" as const },\n      milestoneTypeIcon: { type: \"keyword\" as const },\n      parentId: { type: \"integer\" as const },\n      parentName: { type: \"keyword\" as const },\n      dueDate: { type: \"date\" as const },\n      isCompleted: { type: \"boolean\" as const },\n      completedAt: { type: \"date\" as const },\n      isDeleted: { type: \"boolean\" as const },\n    },\n  },\n};\n\n/**\n * Get Elasticsearch replica settings from database\n */\nasync function getElasticsearchSettings(prismaClient?: PrismaClientType) {\n  const prisma = prismaClient || defaultPrisma;\n  try {\n    const config = await prisma.appConfig.findUnique({\n      where: { key: \"elasticsearch_replicas\" },\n    });\n\n    // Default to 0 for single-node clusters\n    return {\n      numberOfReplicas: config?.value ? (config.value as number) : 0,\n    };\n  } catch (error) {\n    console.warn(\n      \"Failed to get Elasticsearch settings from database, using defaults:\",\n      error\n    );\n    return { numberOfReplicas: 0 };\n  }\n}\n\n/**\n * Create index for a specific entity type\n * @param entityType - The type of entity to create an index for\n * @param prismaClient - Optional Prisma client for getting settings\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function createEntityIndex(\n  entityType: SearchableEntityType,\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = getEntityIndexName(entityType, tenantId);\n  const mapping = ENTITY_MAPPINGS[entityType];\n\n  try {\n    // Get settings from database\n    const settings = await getElasticsearchSettings(prismaClient);\n\n    const indexExists = await client.indices.exists({ index: indexName });\n\n    if (!indexExists) {\n      await client.indices.create({\n        index: indexName,\n        mappings: mapping,\n        settings: {\n          number_of_shards: 1,\n          number_of_replicas: settings.numberOfReplicas,\n          analysis: {\n            analyzer: {\n              standard: {\n                type: \"standard\",\n                stopwords: \"_english_\",\n              },\n            },\n          },\n        },\n      });\n\n      console.log(`Created Elasticsearch index: ${indexName}`);\n      return true;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\n      `Failed to create index ${indexName} for ${entityType}:`,\n      error\n    );\n    return false;\n  }\n}\n\n/**\n * Create all entity indices\n * @param prismaClient - Optional Prisma client for getting settings\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function createAllEntityIndices(\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<void> {\n  const entityTypes = Object.values(SearchableEntityType);\n\n  for (const entityType of entityTypes) {\n    await createEntityIndex(entityType, prismaClient, tenantId);\n  }\n}\n\n/**\n * Transform custom field values based on field type\n */\nexport function transformCustomFieldValue(\n  fieldType: string,\n  value: any\n): Partial<CustomFieldDocument> {\n  const base: Partial<CustomFieldDocument> = {};\n\n  switch (fieldType) {\n    case \"Checkbox\":\n      base.valueBoolean = Boolean(value);\n      base.value = String(value);\n      break;\n\n    case \"Date\":\n      if (value) {\n        const date = new Date(value);\n        if (!isNaN(date.getTime())) {\n          base.valueDate = date.toISOString();\n          base.value = date.toISOString();\n        }\n      }\n      break;\n\n    case \"Number\":\n      base.valueNumeric = Number(value);\n      base.value = String(value);\n      break;\n\n    case \"Multi-Select\":\n      if (Array.isArray(value)) {\n        base.valueArray = value.map((v) => String(v));\n        base.value = value.join(\" \");\n      } else if (value) {\n        // Handle case where value might be a JSON string\n        try {\n          const parsed = JSON.parse(value);\n          if (Array.isArray(parsed)) {\n            base.valueArray = parsed.map((v) => String(v));\n            base.value = parsed.join(\" \");\n          }\n        } catch {\n          base.value = String(value);\n        }\n      }\n      break;\n\n    case \"Select\":\n      base.valueKeyword = String(value);\n      base.value = String(value);\n      break;\n\n    case \"Text String\":\n    case \"Link\":\n      base.valueKeyword = String(value);\n      base.value = String(value);\n      break;\n\n    case \"Text Long\":\n      // Extract text from TipTap JSON\n      if (value) {\n        try {\n          const content = typeof value === \"string\" ? JSON.parse(value) : value;\n          const textContent = extractTextFromTipTap(content);\n          base.value = textContent;\n        } catch {\n          base.value = String(value);\n        }\n      }\n      break;\n\n    case \"Steps\":\n      // Steps are handled separately in the steps array\n      if (value) {\n        base.value = String(value);\n      }\n      break;\n\n    default:\n      base.value = String(value);\n  }\n\n  return base;\n}\n\n/**\n * Extract plain text from TipTap JSON content\n */\nfunction extractTextFromTipTap(content: any): string {\n  if (!content || !content.content) return \"\";\n\n  let text = \"\";\n\n  function extractFromNode(node: any) {\n    if (node.text) {\n      text += node.text + \" \";\n    }\n    if (node.content) {\n      node.content.forEach(extractFromNode);\n    }\n  }\n\n  content.content.forEach(extractFromNode);\n  return text.trim();\n}\n\n/**\n * Build custom field documents for indexing\n */\nexport function buildCustomFieldDocuments(\n  fieldValues: Array<{\n    fieldId: number;\n    field: {\n      displayName: string;\n      systemName: string;\n      type?: { type: string };\n      fieldOptions?: Array<{\n        fieldOption: {\n          id: number;\n          name: string;\n          icon?: { name: string };\n          iconColor?: { value: string };\n        };\n      }>;\n    };\n    value: any;\n  }>\n): CustomFieldDocument[] {\n  return fieldValues.map((cfv) => {\n    const fieldType = cfv.field.type?.type || cfv.field.systemName;\n    const transformed = transformCustomFieldValue(fieldType, cfv.value);\n\n    const doc: CustomFieldDocument = {\n      fieldId: cfv.fieldId,\n      fieldName: cfv.field.displayName,\n      fieldType: fieldType,\n      ...transformed,\n    };\n\n    // For single select/dropdown fields, find the selected option\n    if (\n      cfv.value &&\n      cfv.field.fieldOptions &&\n      (fieldType === \"Select\" || fieldType === \"Dropdown\")\n    ) {\n      const selectedOption = cfv.field.fieldOptions.find(\n        (fo) => fo.fieldOption.id === cfv.value\n      );\n      if (selectedOption) {\n        doc.fieldOption = {\n          id: selectedOption.fieldOption.id,\n          name: selectedOption.fieldOption.name,\n          icon: selectedOption.fieldOption.icon,\n          iconColor: selectedOption.fieldOption.iconColor,\n        };\n      }\n    }\n\n    // Add all field options for multi-select fields\n    if (cfv.field.fieldOptions && fieldType === \"Multi-Select\") {\n      doc.fieldOptions = cfv.field.fieldOptions.map((fo) => ({\n        id: fo.fieldOption.id,\n        name: fo.fieldOption.name,\n        icon: fo.fieldOption.icon,\n        iconColor: fo.fieldOption.iconColor,\n      }));\n    }\n\n    return doc;\n  });\n}\n\n/**\n * Get all indices for a list of entity types\n * @param entityTypes - Optional list of entity types to get indices for\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport function getIndicesForEntityTypes(\n  entityTypes?: SearchableEntityType[],\n  tenantId?: string\n): string[] {\n  const types =\n    entityTypes && entityTypes.length > 0\n      ? entityTypes\n      : Object.values(SearchableEntityType);\n\n  return types.map((type) => getEntityIndexName(type, tenantId));\n}\n\n/**\n * Build aggregations for faceted search\n */\nexport function buildAggregations(\n  facets: string[],\n  entityTypes?: SearchableEntityType[]\n): Record<string, any> {\n  const aggs: Record<string, any> = {};\n\n  // Common facets\n  if (facets.includes(\"projects\") || facets.includes(\"projectId\")) {\n    aggs.projects = {\n      terms: {\n        field: \"projectId\",\n        size: 100,\n      },\n    };\n  }\n\n  if (facets.includes(\"states\") || facets.includes(\"stateId\")) {\n    aggs.states = {\n      terms: {\n        field: \"stateId\",\n        size: 50,\n      },\n    };\n  }\n\n  if (facets.includes(\"tags\") || facets.includes(\"tagIds\")) {\n    aggs.tags = {\n      terms: {\n        field: \"tagIds\",\n        size: 100,\n      },\n    };\n  }\n\n  if (facets.includes(\"creators\") || facets.includes(\"creatorId\")) {\n    aggs.creators = {\n      terms: {\n        field: \"createdById.keyword\",\n        size: 100,\n      },\n    };\n  }\n\n  // Entity-specific aggregations\n  if (\n    !entityTypes ||\n    entityTypes.includes(SearchableEntityType.REPOSITORY_CASE)\n  ) {\n    if (facets.includes(\"folders\") || facets.includes(\"folderId\")) {\n      aggs.folders = {\n        terms: {\n          field: \"folderId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"templates\") || facets.includes(\"templateId\")) {\n      aggs.templates = {\n        terms: {\n          field: \"templateId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"automated\")) {\n      aggs.automated = {\n        terms: {\n          field: \"automated\",\n        },\n      };\n    }\n  }\n\n  if (!entityTypes || entityTypes.includes(SearchableEntityType.TEST_RUN)) {\n    if (\n      facets.includes(\"configurations\") ||\n      facets.includes(\"configurationId\")\n    ) {\n      aggs.configurations = {\n        terms: {\n          field: \"configurationId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"milestones\") || facets.includes(\"milestoneId\")) {\n      aggs.milestones = {\n        terms: {\n          field: \"milestoneId\",\n          size: 50,\n        },\n      };\n    }\n\n    if (facets.includes(\"testRunType\")) {\n      aggs.testRunType = {\n        terms: {\n          field: \"testRunType\",\n        },\n      };\n    }\n  }\n\n  if (!entityTypes || entityTypes.includes(SearchableEntityType.SESSION)) {\n    if (facets.includes(\"assignedTo\") || facets.includes(\"assignedToId\")) {\n      aggs.assignedTo = {\n        terms: {\n          field: \"assignedToId.keyword\",\n          size: 100,\n        },\n      };\n    }\n  }\n\n  // Entity type counts\n  aggs.entityTypes = {\n    terms: {\n      field: \"_index\",\n      size: 10,\n    },\n  };\n\n  return aggs;\n}\n", "import {\n  createRepositoryCaseIndex,\n  RepositoryCaseDocument,\n} from \"./elasticsearchService\";\nimport {\n  indexRepositoryCase,\n  deleteRepositoryCase,\n  bulkIndexRepositoryCases,\n} from \"./elasticsearchIndexing\";\nimport { extractTextFromNode } from \"../utils/extractTextFromJson\";\nimport { buildCustomFieldDocuments } from \"./unifiedElasticsearchService\";\nimport { prisma as defaultPrisma } from \"../lib/prismaBase\";\n\ntype PrismaClientType = typeof defaultPrisma;\n\n/**\n * Safely extract text from a step field that might be JSON string or object\n */\nfunction extractStepText(stepData: any): string {\n  if (!stepData) return \"\";\n\n  try {\n    // If it's a string, try to parse it as JSON\n    if (typeof stepData === \"string\") {\n      const parsed = JSON.parse(stepData);\n      return extractTextFromNode(parsed);\n    }\n    // Otherwise, assume it's already an object\n    return extractTextFromNode(stepData);\n  } catch (error) {\n    // If parsing fails, return the original string\n    return typeof stepData === \"string\" ? stepData : \"\";\n  }\n}\n\n/**\n * Build a repository case document for Elasticsearch from Prisma data\n */\nexport async function buildRepositoryCaseDocument(\n  caseId: number,\n  prismaClient?: PrismaClientType\n): Promise<RepositoryCaseDocument | null> {\n  const prisma = prismaClient || defaultPrisma;\n  const repoCase = await prisma.repositoryCases.findUnique({\n    where: { id: caseId },\n    include: {\n      project: true,\n      folder: true,\n      template: true,\n      state: {\n        include: {\n          icon: true,\n          color: true,\n        },\n      },\n      creator: true,\n      tags: true,\n      steps: {\n        orderBy: { order: \"asc\" },\n        include: {\n          sharedStepGroup: {\n            include: {\n              items: {\n                orderBy: { order: \"asc\" },\n              },\n            },\n          },\n        },\n      },\n      caseFieldValues: {\n        include: {\n          field: {\n            include: {\n              type: true,\n              fieldOptions: {\n                include: {\n                  fieldOption: {\n                    include: {\n                      icon: true,\n                      iconColor: true,\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (!repoCase) return null;\n\n  // Build folder path\n  const folderPath = await buildFolderPath(repoCase.folderId, prisma);\n\n  return {\n    id: repoCase.id,\n    projectId: repoCase.projectId,\n    projectName: repoCase.project.name,\n    projectIconUrl: repoCase.project.iconUrl,\n    repositoryId: repoCase.repositoryId,\n    folderId: repoCase.folderId,\n    folderPath,\n    templateId: repoCase.templateId,\n    templateName: repoCase.template.templateName,\n    name: repoCase.name,\n    className: repoCase.className,\n    source: repoCase.source,\n    stateId: repoCase.stateId,\n    stateName: repoCase.state.name,\n    stateIcon: repoCase.state.icon.name,\n    stateColor: repoCase.state.color.value,\n    estimate: repoCase.estimate,\n    forecastManual: repoCase.forecastManual,\n    forecastAutomated: repoCase.forecastAutomated,\n    automated: repoCase.automated,\n    isArchived: repoCase.isArchived,\n    isDeleted: repoCase.isDeleted,\n    createdAt: repoCase.createdAt,\n    creatorId: repoCase.creatorId,\n    creatorName: repoCase.creator.name,\n    creatorImage: repoCase.creator.image,\n    tags: repoCase.tags.map((tag) => ({\n      id: tag.id,\n      name: tag.name,\n    })),\n    customFields: buildCustomFieldDocuments(\n      repoCase.caseFieldValues.map((cfv) => ({\n        fieldId: cfv.fieldId,\n        field: {\n          displayName: cfv.field.displayName,\n          systemName: cfv.field.systemName,\n          type: cfv.field.type ? { type: cfv.field.type.type } : undefined,\n          fieldOptions: cfv.field.fieldOptions?.map((fo) => ({\n            fieldOption: {\n              id: fo.fieldOption.id,\n              name: fo.fieldOption.name,\n              icon: fo.fieldOption.icon\n                ? { name: fo.fieldOption.icon.name }\n                : undefined,\n              iconColor: fo.fieldOption.iconColor\n                ? { value: fo.fieldOption.iconColor.value }\n                : undefined,\n            },\n          })),\n        },\n        value: cfv.value,\n      }))\n    )\n      .filter(\n        (cf) => cf.value !== null && cf.value !== undefined && cf.value !== \"\"\n      )\n      .map((cf) => ({\n        fieldId: cf.fieldId,\n        fieldName: cf.fieldName,\n        fieldType: cf.fieldType,\n        value: cf.value || \"\", // Ensure value is always present\n      })),\n    steps: repoCase.steps.flatMap((step): any[] => {\n      // If this is a shared step, expand all items from the group\n      if (step.sharedStepGroupId && step.sharedStepGroup) {\n        return step.sharedStepGroup.items.map((item, index) => ({\n          id: step.id * 1000 + index, // Generate unique ID for each shared step item\n          order: step.order,\n          step: extractStepText(item.step),\n          expectedResult: extractStepText(item.expectedResult),\n          isSharedStep: true,\n          sharedStepGroupId: step.sharedStepGroupId,\n          sharedStepGroupName: step.sharedStepGroup?.name,\n        }));\n      }\n      // Regular step\n      return [\n        {\n          id: step.id,\n          order: step.order,\n          step: extractStepText(step.step),\n          expectedResult: extractStepText(step.expectedResult),\n          isSharedStep: false,\n          sharedStepGroupId: undefined,\n          sharedStepGroupName: undefined,\n        },\n      ];\n    }),\n  };\n}\n\n/**\n * Build the full folder path for a folder\n */\nasync function buildFolderPath(\n  folderId: number,\n  prisma: PrismaClientType = defaultPrisma\n): Promise<string> {\n  const folder = await prisma.repositoryFolders.findUnique({\n    where: { id: folderId },\n    include: { parent: true },\n  });\n\n  if (!folder) return \"/\";\n\n  const path = [folder.name];\n  let current: any = folder;\n\n  while (current.parent) {\n    path.unshift(current.parent.name);\n    const nextParent = await prisma.repositoryFolders.findUnique({\n      where: { id: current.parent.id },\n      include: { parent: true },\n    });\n    if (!nextParent) break;\n    current = nextParent;\n  }\n\n  return \"/\" + path.join(\"/\");\n}\n\n/**\n * Sync a repository case to Elasticsearch after create/update\n */\nexport async function syncRepositoryCaseToElasticsearch(\n  caseId: number\n): Promise<boolean> {\n  const doc = await buildRepositoryCaseDocument(caseId);\n  if (!doc) {\n    // Case no longer exists (hard deleted) - remove from Elasticsearch\n    await deleteRepositoryCase(caseId);\n    return true;\n  }\n\n  // Index all cases including deleted ones (they'll be filtered in search based on admin permissions)\n  // Only exclude archived cases as they're typically not meant to be searchable\n  if (doc.isArchived) {\n    await deleteRepositoryCase(caseId);\n    return true;\n  }\n\n  return await indexRepositoryCase(doc);\n}\n\n/**\n * Sync all repository cases for a project to Elasticsearch\n * @param projectId - The project ID to sync cases for\n * @param batchSize - Number of cases to process per batch\n * @param progressCallback - Optional callback for progress updates\n * @param prismaClient - Optional Prisma client for tenant-specific queries\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncProjectCasesToElasticsearch(\n  projectId: number,\n  batchSize: number = 100,\n  progressCallback?: (processed: number, total: number, message: string) => void | Promise<void>,\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<boolean> {\n  const prisma = prismaClient || defaultPrisma;\n  try {\n    // Ensure index exists\n    await createRepositoryCaseIndex(prisma, tenantId);\n\n    const totalCases = await prisma.repositoryCases.count({\n      where: {\n        projectId,\n        isArchived: false, // Only exclude archived, include deleted items\n      },\n    });\n\n    const message = `Syncing ${totalCases} cases for project ${projectId}...`;\n    console.log(message);\n    if (progressCallback) {\n      await progressCallback(0, totalCases, message);\n    }\n\n    let processed = 0;\n    let hasMore = true;\n\n    while (hasMore) {\n      const cases = await prisma.repositoryCases.findMany({\n        where: {\n          projectId,\n          isArchived: false, // Only exclude archived, include deleted items\n        },\n        skip: processed,\n        take: batchSize,\n        orderBy: { id: \"asc\" },\n      });\n\n      if (cases.length === 0) {\n        hasMore = false;\n        break;\n      }\n\n      // Build documents for this batch\n      const documents: RepositoryCaseDocument[] = [];\n\n      for (const caseItem of cases) {\n        const doc = await buildRepositoryCaseDocument(caseItem.id, prisma);\n        if (doc) {\n          documents.push(doc);\n        }\n      }\n\n      // Bulk index this batch\n      if (documents.length > 0) {\n        const success = await bulkIndexRepositoryCases(documents, tenantId);\n        if (!success) {\n          console.error(`Failed to index batch starting at ${processed}`);\n          return false;\n        }\n      }\n\n      processed += cases.length;\n      const progressMessage = `Indexed ${processed}/${totalCases} cases...`;\n      console.log(progressMessage);\n      if (progressCallback) {\n        await progressCallback(processed, totalCases, progressMessage);\n      }\n    }\n\n    const finalMessage = `Successfully synced ${processed} cases to Elasticsearch`;\n    console.log(finalMessage);\n    if (progressCallback) {\n      await progressCallback(processed, totalCases, finalMessage);\n    }\n    return true;\n  } catch (error) {\n    console.error(\"Error syncing project cases to Elasticsearch:\", error);\n    return false;\n  }\n}\n\n/**\n * Initialize Elasticsearch indexes on application startup\n * @param prismaClient - Optional Prisma client for tenant-specific queries\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function initializeElasticsearchIndexes(\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<void> {\n  try {\n    const created = await createRepositoryCaseIndex(prismaClient, tenantId);\n    if (created) {\n      console.log(`Elasticsearch indexes initialized successfully${tenantId ? ` (tenant: ${tenantId})` : \"\"}`);\n    }\n  } catch (error) {\n    console.error(\"Failed to initialize Elasticsearch indexes:\", error);\n  }\n}\n", "import {\n  getElasticsearchClient,\n  createEntityIndex,\n  getEntityIndexName,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\n\ntype PrismaClientType = typeof defaultPrisma;\n\n/**\n * Document structure for shared steps in Elasticsearch\n */\nexport interface SharedStepDocument {\n  id: number;\n  name: string;\n  projectId: number;\n  projectName: string;\n  projectIconUrl?: string | null;\n  createdAt: Date;\n  createdById: string;\n  createdByName: string;\n  createdByImage?: string | null;\n  isDeleted: boolean;\n  items: Array<{\n    id: number;\n    order: number;\n    step: string;\n    expectedResult: string;\n  }>;\n  searchableContent: string;\n}\n\n/**\n * Build a shared step document for Elasticsearch from Prisma data\n */\nexport async function buildSharedStepDocument(\n  stepGroupId: number,\n  prismaClient?: PrismaClientType\n): Promise<SharedStepDocument | null> {\n  const prisma = prismaClient || defaultPrisma;\n  const stepGroup = await prisma.sharedStepGroup.findUnique({\n    where: { id: stepGroupId },\n    include: {\n      project: true,\n      createdBy: true,\n      items: {\n        orderBy: { order: \"asc\" },\n      },\n    },\n  });\n\n  if (!stepGroup) return null;\n\n  // Build searchable content from name and step items\n  const searchableContent = [\n    stepGroup.name,\n    ...stepGroup.items.map((item) => {\n      let stepText = \"\";\n      let expectedResultText = \"\";\n\n      // Handle step field\n      if (typeof item.step === \"string\") {\n        try {\n          const parsed = JSON.parse(item.step);\n          stepText = extractTextFromNode(parsed);\n        } catch {\n          stepText = item.step;\n        }\n      } else if (item.step) {\n        stepText = extractTextFromNode(item.step);\n      }\n\n      // Handle expectedResult field\n      if (typeof item.expectedResult === \"string\") {\n        try {\n          const parsed = JSON.parse(item.expectedResult);\n          expectedResultText = extractTextFromNode(parsed);\n        } catch {\n          expectedResultText = item.expectedResult;\n        }\n      } else if (item.expectedResult) {\n        expectedResultText = extractTextFromNode(item.expectedResult);\n      }\n\n      return `${stepText} ${expectedResultText}`;\n    }),\n  ].join(\" \");\n\n  return {\n    id: stepGroup.id,\n    name: stepGroup.name,\n    projectId: stepGroup.projectId,\n    projectName: stepGroup.project.name,\n    projectIconUrl: stepGroup.project.iconUrl,\n    createdAt: stepGroup.createdAt,\n    createdById: stepGroup.createdById,\n    createdByName: stepGroup.createdBy.name,\n    createdByImage: stepGroup.createdBy.image,\n    isDeleted: stepGroup.isDeleted,\n    items: stepGroup.items.map((item) => ({\n      id: item.id,\n      order: item.order,\n      step:\n        typeof item.step === \"object\"\n          ? JSON.stringify(item.step)\n          : String(item.step),\n      expectedResult:\n        typeof item.expectedResult === \"object\"\n          ? JSON.stringify(item.expectedResult)\n          : String(item.expectedResult),\n    })),\n    searchableContent,\n  };\n}\n\n/**\n * Index a shared step group in Elasticsearch\n * @param stepData - The shared step document to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function indexSharedStep(\n  stepData: SharedStepDocument,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = getEntityIndexName(SearchableEntityType.SHARED_STEP, tenantId);\n\n  try {\n    await client.index({\n      index: indexName,\n      id: stepData.id.toString(),\n      document: stepData,\n    });\n\n    console.log(`Indexed shared step ${stepData.id} in Elasticsearch index ${indexName}`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to index shared step ${stepData.id}:`, error);\n    return false;\n  }\n}\n\n/**\n * Delete a shared step from Elasticsearch\n * @param stepId - The ID of the shared step to delete\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function deleteSharedStep(\n  stepId: number,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) return false;\n\n  const indexName = getEntityIndexName(SearchableEntityType.SHARED_STEP, tenantId);\n\n  try {\n    await client.delete({\n      index: indexName,\n      id: stepId.toString(),\n    });\n\n    console.log(`Deleted shared step ${stepId} from Elasticsearch index ${indexName}`);\n    return true;\n  } catch (error) {\n    // 404 is expected if document doesn't exist\n    if ((error as any).statusCode === 404) {\n      console.log(\n        `Shared step ${stepId} not found in Elasticsearch (already deleted)`\n      );\n      return true;\n    }\n    console.error(`Failed to delete shared step ${stepId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Sync a shared step to Elasticsearch after create/update\n * @param stepId - The ID of the shared step to sync\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncSharedStepToElasticsearch(\n  stepId: number,\n  tenantId?: string\n): Promise<boolean> {\n  const doc = await buildSharedStepDocument(stepId);\n  if (!doc) return false;\n\n  // Index shared step including deleted ones (filtering happens at search time based on admin permissions)\n  return await indexSharedStep(doc, tenantId);\n}\n\n/**\n * Sync all shared steps for a project to Elasticsearch\n * @param projectId - The project ID to sync shared steps for\n * @param batchSize - Number of shared steps to process per batch\n * @param prismaClient - Optional Prisma client for multi-tenant mode\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncProjectSharedStepsToElasticsearch(\n  projectId: number,\n  batchSize: number = 100,\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<boolean> {\n  const prisma = prismaClient || defaultPrisma;\n  try {\n    // Ensure index exists\n    await createEntityIndex(SearchableEntityType.SHARED_STEP, prisma, tenantId);\n\n    const totalSteps = await prisma.sharedStepGroup.count({\n      where: {\n        projectId,\n        // Include deleted items (filtering happens at search time based on admin permissions)\n      },\n    });\n\n    console.log(\n      `Syncing ${totalSteps} shared steps for project ${projectId}${tenantId ? ` (tenant: ${tenantId})` : \"\"}...`\n    );\n\n    let processed = 0;\n    let hasMore = true;\n\n    while (hasMore) {\n      const steps = await prisma.sharedStepGroup.findMany({\n        where: {\n          projectId,\n          // Include deleted items (filtering happens at search time based on admin permissions)\n        },\n        skip: processed,\n        take: batchSize,\n        orderBy: { id: \"asc\" },\n      });\n\n      if (steps.length === 0) {\n        hasMore = false;\n        break;\n      }\n\n      // Build and index documents for this batch\n      for (const step of steps) {\n        const doc = await buildSharedStepDocument(step.id, prisma);\n        if (doc) {\n          await indexSharedStep(doc, tenantId);\n        }\n      }\n\n      processed += steps.length;\n      console.log(`Indexed ${processed}/${totalSteps} shared steps...`);\n    }\n\n    console.log(\n      `Successfully synced ${processed} shared steps to Elasticsearch`\n    );\n    return true;\n  } catch (error) {\n    console.error(\n      \"Error syncing project shared steps to Elasticsearch:\",\n      error\n    );\n    return false;\n  }\n}\n", "import {\n  getElasticsearchClient,\n  getEntityIndexName,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { TestRuns, Prisma, PrismaClient } from \"@prisma/client\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\n/**\n * Type for test run with all required relations for indexing\n */\ntype TestRunForIndexing = TestRuns & {\n  project: { name: string };\n  createdBy: { name: string };\n  state: { name: string };\n  configuration?: { name: string } | null;\n  milestone?: { name: string } | null;\n  tags: Array<{ id: number; name: string }>;\n};\n\n/**\n * Index a single test run to Elasticsearch\n * @param testRun - The test run to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function indexTestRun(\n  testRun: TestRunForIndexing,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.TEST_RUN, tenantId);\n\n  // Extract text from TipTap JSON for note and docs fields\n  const noteText = testRun.note ? extractTextFromNode(testRun.note) : \"\";\n  const docsText = testRun.docs ? extractTextFromNode(testRun.docs) : \"\";\n\n  const searchableContent = [\n    testRun.name,\n    noteText,\n    docsText,\n    testRun.tags.map((t) => t.name).join(\" \"),\n  ].join(\" \");\n\n  const document = {\n    id: testRun.id,\n    projectId: testRun.projectId,\n    projectName: testRun.project.name,\n    name: testRun.name,\n    note: noteText,\n    docs: docsText,\n    configId: testRun.configId,\n    configurationName: testRun.configuration?.name,\n    milestoneId: testRun.milestoneId,\n    milestoneName: testRun.milestone?.name,\n    stateId: testRun.stateId,\n    stateName: testRun.state.name,\n    forecastManual: testRun.forecastManual,\n    forecastAutomated: testRun.forecastAutomated,\n    elapsed: testRun.elapsed,\n    isCompleted: testRun.isCompleted,\n    isDeleted: testRun.isDeleted,\n    completedAt: testRun.completedAt,\n    testRunType: testRun.testRunType,\n    createdAt: testRun.createdAt,\n    createdById: testRun.createdById,\n    createdByName: testRun.createdBy.name,\n    tags: testRun.tags.map((tag) => ({ id: tag.id, name: tag.name })),\n    searchableContent,\n  };\n\n  await client.index({\n    index: indexName,\n    id: testRun.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete a test run from Elasticsearch\n * @param testRunId - The ID of the test run to delete\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function deleteTestRunFromIndex(\n  testRunId: number,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.TEST_RUN, tenantId);\n\n  try {\n    await client.delete({\n      index: indexName,\n      id: testRunId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete test run from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single test run to Elasticsearch\n * @param testRunId - The ID of the test run to sync\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncTestRunToElasticsearch(\n  testRunId: number,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const testRun = await defaultPrisma.testRuns.findUnique({\n      where: { id: testRunId },\n      include: {\n        project: true,\n        createdBy: true,\n        state: true,\n        configuration: true,\n        milestone: true,\n        tags: true,\n      },\n    });\n\n    if (!testRun) {\n      console.warn(`Test run ${testRunId} not found`);\n      return false;\n    }\n\n    // Index test run including deleted ones (filtering happens at search time based on admin permissions)\n\n    // Index the test run\n    await indexTestRun(testRun as TestRunForIndexing, tenantId);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync test run ${testRunId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index test runs for a project\n * @param projectId - The project ID to sync test runs for\n * @param db - Prisma client instance\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncProjectTestRunsToElasticsearch(\n  projectId: number,\n  db: any,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.TEST_RUN, tenantId);\n\n  console.log(`Starting test run sync for project ${projectId}${tenantId ? ` (tenant: ${tenantId})` : \"\"}`);\n\n  const testRuns = await db.testRuns.findMany({\n    where: {\n      projectId: projectId,\n      // Include deleted items (filtering happens at search time based on admin permissions)\n    },\n    include: {\n      project: true,\n      createdBy: true,\n      state: true,\n      configuration: true,\n      milestone: true,\n      tags: true,\n    },\n  });\n\n  if (testRuns.length === 0) {\n    console.log(\"No test runs to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  for (const testRun of testRuns) {\n    // Extract text from TipTap JSON for note and docs fields\n    const noteText = testRun.note ? extractTextFromNode(testRun.note) : \"\";\n    const docsText = testRun.docs ? extractTextFromNode(testRun.docs) : \"\";\n\n    const searchableContent = [\n      testRun.name,\n      noteText,\n      docsText,\n      testRun.tags.map((t: any) => t.name).join(\" \"),\n    ].join(\" \");\n\n    bulkBody.push({\n      index: {\n        _index: indexName,\n        _id: testRun.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: testRun.id,\n      projectId: testRun.projectId,\n      projectName: testRun.project.name,\n      name: testRun.name,\n      note: noteText,\n      docs: docsText,\n      configId: testRun.configId,\n      configurationName: testRun.configuration?.name,\n      milestoneId: testRun.milestoneId,\n      milestoneName: testRun.milestone?.name,\n      stateId: testRun.stateId,\n      stateName: testRun.state.name,\n      forecastManual: testRun.forecastManual,\n      forecastAutomated: testRun.forecastAutomated,\n      elapsed: testRun.elapsed,\n      isCompleted: testRun.isCompleted,\n      isDeleted: testRun.isDeleted,\n      completedAt: testRun.completedAt,\n      testRunType: testRun.testRunType,\n      createdAt: testRun.createdAt,\n      createdById: testRun.createdById,\n      createdByName: testRun.createdBy.name,\n      tags: testRun.tags.map((tag: any) => ({ id: tag.id, name: tag.name })),\n      searchableContent,\n    });\n  }\n\n  try {\n    const bulkResponse = await client.bulk({ body: bulkBody, refresh: true });\n\n    if (bulkResponse.errors) {\n      const errorItems = bulkResponse.items.filter(\n        (item: any) => item.index?.error\n      );\n      console.error(`Bulk indexing errors: ${errorItems.length} failed documents`);\n      // Log detailed error information\n      errorItems.slice(0, 10).forEach((item: any) => {\n        if (item.index?.error) {\n          console.error(`  Failed to index document ${item.index._id}:`);\n          console.error(`    Error type: ${item.index.error.type}`);\n          console.error(`    Error reason: ${item.index.error.reason}`);\n          if (item.index.error.caused_by) {\n            console.error(`    Caused by: ${JSON.stringify(item.index.error.caused_by)}`);\n          }\n        }\n      });\n      if (errorItems.length > 10) {\n        console.error(`  ... and ${errorItems.length - 10} more errors`);\n      }\n    } else {\n      console.log(`Successfully indexed ${testRuns.length} test runs`);\n    }\n  } catch (error) {\n    console.error(\"Failed to bulk index test runs:\", error);\n    throw error;\n  }\n}\n\n/**\n * Search for test runs\n * @param params - Search parameters\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function searchTestRuns(\n  params: {\n    query?: string;\n    projectIds?: number[];\n    stateIds?: number[];\n    configurationIds?: number[];\n    milestoneIds?: number[];\n    isCompleted?: boolean;\n    testRunType?: string;\n    customFields?: Array<{\n      fieldId: number;\n      fieldType: string;\n      operator: string;\n      value: any;\n      value2?: any;\n    }>;\n    from?: number;\n    size?: number;\n    sort?: Array<{ field: string; order: \"asc\" | \"desc\" }>;\n  },\n  tenantId?: string\n): Promise<{\n  hits: any[];\n  total: number;\n  took: number;\n}> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    return { hits: [], total: 0, took: 0 };\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.TEST_RUN, tenantId);\n\n  const must: any[] = [];\n  const filter: any[] = [];\n\n  // Add query\n  if (params.query) {\n    must.push({\n      multi_match: {\n        query: params.query,\n        fields: [\n          \"name^3\",\n          \"searchableContent\",\n          \"note\",\n          \"docs\",\n          \"customFields.value\",\n        ],\n        type: \"best_fields\",\n        operator: \"or\",\n        fuzziness: \"AUTO\",\n      },\n    });\n  }\n\n  // Add filters\n  if (params.projectIds && params.projectIds.length > 0) {\n    filter.push({ terms: { projectId: params.projectIds } });\n  }\n  if (params.stateIds && params.stateIds.length > 0) {\n    filter.push({ terms: { stateId: params.stateIds } });\n  }\n  if (params.configurationIds && params.configurationIds.length > 0) {\n    filter.push({ terms: { configId: params.configurationIds } });\n  }\n  if (params.milestoneIds && params.milestoneIds.length > 0) {\n    filter.push({ terms: { milestoneId: params.milestoneIds } });\n  }\n  if (typeof params.isCompleted === \"boolean\") {\n    filter.push({ term: { isCompleted: params.isCompleted } });\n  }\n  if (params.testRunType) {\n    filter.push({ term: { testRunType: params.testRunType } });\n  }\n\n  // Add custom field filters\n  if (params.customFields) {\n    // Implementation would be similar to repository case custom field filters\n  }\n\n  const searchBody: any = {\n    index: indexName,\n    from: params.from || 0,\n    size: params.size || 20,\n    query: {\n      bool: {\n        must,\n        filter,\n      },\n    },\n    highlight: {\n      fields: {\n        name: { number_of_fragments: 1 },\n        searchableContent: { number_of_fragments: 3 },\n        note: { number_of_fragments: 2 },\n        docs: { number_of_fragments: 2 },\n      },\n      pre_tags: ['<mark class=\"search-highlight\">'],\n      post_tags: [\"</mark>\"],\n    },\n  };\n\n  // Add sorting\n  if (params.sort && params.sort.length > 0) {\n    searchBody.sort = params.sort.map((s) => ({\n      [s.field]: { order: s.order },\n    }));\n  }\n\n  try {\n    const response = await client.search(searchBody);\n    return {\n      hits: response.hits.hits,\n      total:\n        typeof response.hits.total === \"object\"\n          ? response.hits.total.value\n          : response.hits.total || 0,\n      took: response.took,\n    };\n  } catch (error) {\n    console.error(\"Test run search error:\", error);\n    return { hits: [], total: 0, took: 0 };\n  }\n}\n", "import {\n  getElasticsearchClient,\n  getEntityIndexName,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Sessions, Prisma, PrismaClient } from \"@prisma/client\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\n/**\n * Type for session with all required relations for indexing\n */\ntype SessionForIndexing = Sessions & {\n  project: { name: string };\n  createdBy: { name: string };\n  assignedTo?: { name: string } | null;\n  state: { name: string };\n  template: { templateName: string };\n  configuration?: { name: string } | null;\n  milestone?: { name: string } | null;\n  tags: Array<{ id: number; name: string }>;\n  sessionFields?: Array<{\n    fieldId: number;\n    field: {\n      displayName: string;\n      systemName: string;\n      type?: { type: string };\n    };\n    value: any;\n  }>;\n};\n\n/**\n * Index a single session to Elasticsearch\n * @param session - The session to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function indexSession(session: SessionForIndexing, tenantId?: string): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  // Extract text from TipTap JSON for note and mission fields\n  const noteText = session.note ? extractTextFromNode(session.note) : \"\";\n  const missionText = session.mission ? extractTextFromNode(session.mission) : \"\";\n\n  const searchableContent = [\n    session.name,\n    noteText,\n    missionText,\n    session.tags.map((t) => t.name).join(\" \"),\n  ].join(\" \");\n\n\n  const document = {\n    id: session.id,\n    projectId: session.projectId,\n    projectName: session.project.name,\n    templateId: session.templateId,\n    templateName: session.template.templateName,\n    name: session.name,\n    note: noteText,\n    mission: missionText,\n    configId: session.configId,\n    configurationName: session.configuration?.name,\n    milestoneId: session.milestoneId,\n    milestoneName: session.milestone?.name,\n    stateId: session.stateId,\n    stateName: session.state.name,\n    assignedToId: session.assignedToId,\n    assignedToName: session.assignedTo?.name,\n    estimate: session.estimate,\n    forecastManual: session.forecastManual,\n    forecastAutomated: session.forecastAutomated,\n    elapsed: session.elapsed,\n    isCompleted: session.isCompleted,\n    isDeleted: session.isDeleted,\n    completedAt: session.completedAt,\n    createdAt: session.createdAt,\n    createdById: session.createdById,\n    createdByName: session.createdBy.name,\n    tags: session.tags.map((tag) => ({ id: tag.id, name: tag.name })),\n    searchableContent,\n  };\n\n  await client.index({\n    index: getEntityIndexName(SearchableEntityType.SESSION, tenantId),\n    id: session.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete a session from Elasticsearch\n * @param sessionId - The ID of the session to delete\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function deleteSessionFromIndex(sessionId: number, tenantId?: string): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  try {\n    await client.delete({\n      index: getEntityIndexName(SearchableEntityType.SESSION, tenantId),\n      id: sessionId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete session from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single session to Elasticsearch\n */\nexport async function syncSessionToElasticsearch(sessionId: number): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const session = await defaultPrisma.sessions.findUnique({\n      where: { id: sessionId },\n      include: {\n        project: true,\n        createdBy: true,\n        assignedTo: true,\n        state: true,\n        template: true,\n        configuration: true,\n        milestone: true,\n        tags: true,\n      },\n    });\n\n    if (!session) {\n      console.warn(`Session ${sessionId} not found`);\n      return false;\n    }\n\n    // Index session including deleted ones (filtering happens at search time based on admin permissions)\n\n    // Index the session\n    await indexSession(session as SessionForIndexing);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync session ${sessionId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index sessions for a project\n * @param projectId - The project ID to sync sessions for\n * @param db - Prisma client instance\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncProjectSessionsToElasticsearch(\n  projectId: number,\n  db: any,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n\n  const sessions = await db.sessions.findMany({\n    where: {\n      projectId: projectId,\n      // Include deleted items (filtering happens at search time based on admin permissions)\n    },\n    include: {\n      project: true,\n      createdBy: true,\n      assignedTo: true,\n      state: true,\n      template: true,\n      configuration: true,\n      milestone: true,\n      tags: true,\n    },\n  });\n\n  if (sessions.length === 0) {\n    return;\n  }\n\n  const bulkBody = [];\n  for (const session of sessions) {\n    // Extract text from TipTap JSON for note and mission fields\n    const noteText = session.note ? extractTextFromNode(session.note) : \"\";\n    const missionText = session.mission ? extractTextFromNode(session.mission) : \"\";\n\n    const searchableContent = [\n      session.name,\n      noteText,\n      missionText,\n      session.tags.map((t: any) => t.name).join(\" \"),\n    ].join(\" \");\n\n\n    bulkBody.push({\n      index: {\n        _index: getEntityIndexName(SearchableEntityType.SESSION, tenantId),\n        _id: session.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: session.id,\n      projectId: session.projectId,\n      projectName: session.project.name,\n      templateId: session.templateId,\n      templateName: session.template.templateName,\n      name: session.name,\n      note: noteText,\n      mission: missionText,\n      configId: session.configId,\n      configurationName: session.configuration?.name,\n      milestoneId: session.milestoneId,\n      milestoneName: session.milestone?.name,\n      stateId: session.stateId,\n      stateName: session.state.name,\n      assignedToId: session.assignedToId,\n      assignedToName: session.assignedTo?.name,\n      estimate: session.estimate,\n      forecastManual: session.forecastManual,\n      forecastAutomated: session.forecastAutomated,\n      elapsed: session.elapsed,\n      isCompleted: session.isCompleted,\n      isDeleted: session.isDeleted,\n      completedAt: session.completedAt,\n      createdAt: session.createdAt,\n      createdById: session.createdById,\n      createdByName: session.createdBy.name,\n      tags: session.tags.map((tag: any) => ({ id: tag.id, name: tag.name })),\n      searchableContent,\n    });\n  }\n\n  try {\n    const bulkResponse = await client.bulk({ body: bulkBody, refresh: true });\n\n    if (bulkResponse.errors) {\n      const errorItems = bulkResponse.items.filter(\n        (item: any) => item.index?.error\n      );\n      console.error(`Bulk indexing errors: ${errorItems.length} failed documents`);\n      // Log detailed error information\n      errorItems.slice(0, 10).forEach((item: any) => {\n        if (item.index?.error) {\n          console.error(`  Failed to index document ${item.index._id}:`);\n          console.error(`    Error type: ${item.index.error.type}`);\n          console.error(`    Error reason: ${item.index.error.reason}`);\n          if (item.index.error.caused_by) {\n            console.error(`    Caused by: ${JSON.stringify(item.index.error.caused_by)}`);\n          }\n        }\n      });\n      if (errorItems.length > 10) {\n        console.error(`  ... and ${errorItems.length - 10} more errors`);\n      }\n    } else {\n      console.log(`Successfully indexed ${sessions.length} sessions`);\n    }\n  } catch (error) {\n    console.error(\"Failed to bulk index sessions:\", error);\n    throw error;\n  }\n}\n\n/**\n * Search for sessions\n * @param params - Search parameters\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function searchSessions(\n  params: {\n    query?: string;\n    projectIds?: number[];\n    templateIds?: number[];\n    stateIds?: number[];\n    assignedToIds?: string[];\n    configurationIds?: number[];\n    milestoneIds?: number[];\n    isCompleted?: boolean;\n    customFields?: Array<{\n      fieldId: number;\n      fieldType: string;\n      operator: string;\n      value: any;\n      value2?: any;\n    }>;\n    from?: number;\n    size?: number;\n    sort?: Array<{ field: string; order: \"asc\" | \"desc\" }>;\n  },\n  tenantId?: string\n): Promise<{\n  hits: any[];\n  total: number;\n  took: number;\n}> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    return { hits: [], total: 0, took: 0 };\n  }\n\n  const must: any[] = [];\n  const filter: any[] = [];\n\n  // Add query\n  if (params.query) {\n    must.push({\n      multi_match: {\n        query: params.query,\n        fields: [\n          \"name^3\",\n          \"searchableContent\",\n          \"note\",\n          \"mission\",\n          \"customFields.value\",\n        ],\n        type: \"best_fields\",\n        operator: \"or\",\n        fuzziness: \"AUTO\",\n      },\n    });\n  }\n\n  // Add filters\n  if (params.projectIds && params.projectIds.length > 0) {\n    filter.push({ terms: { projectId: params.projectIds } });\n  }\n  if (params.templateIds && params.templateIds.length > 0) {\n    filter.push({ terms: { templateId: params.templateIds } });\n  }\n  if (params.stateIds && params.stateIds.length > 0) {\n    filter.push({ terms: { stateId: params.stateIds } });\n  }\n  if (params.assignedToIds && params.assignedToIds.length > 0) {\n    filter.push({ terms: { assignedToId: params.assignedToIds } });\n  }\n  if (params.configurationIds && params.configurationIds.length > 0) {\n    filter.push({ terms: { configId: params.configurationIds } });\n  }\n  if (params.milestoneIds && params.milestoneIds.length > 0) {\n    filter.push({ terms: { milestoneId: params.milestoneIds } });\n  }\n  if (typeof params.isCompleted === \"boolean\") {\n    filter.push({ term: { isCompleted: params.isCompleted } });\n  }\n\n  // Add custom field filters\n  if (params.customFields) {\n    // Implementation would be similar to repository case custom field filters\n  }\n\n  const searchBody: any = {\n    index: getEntityIndexName(SearchableEntityType.SESSION, tenantId),\n    from: params.from || 0,\n    size: params.size || 20,\n    query: {\n      bool: {\n        must,\n        filter,\n      },\n    },\n    highlight: {\n      fields: {\n        name: { number_of_fragments: 1 },\n        searchableContent: { number_of_fragments: 3 },\n        note: { number_of_fragments: 2 },\n        mission: { number_of_fragments: 2 },\n      },\n      pre_tags: ['<mark class=\"search-highlight\">'],\n      post_tags: [\"</mark>\"],\n    },\n  };\n\n  // Add sorting\n  if (params.sort && params.sort.length > 0) {\n    searchBody.sort = params.sort.map((s) => ({\n      [s.field]: { order: s.order },\n    }));\n  }\n\n  try {\n    const response = await client.search(searchBody);\n    return {\n      hits: response.hits.hits,\n      total:\n        typeof response.hits.total === \"object\"\n          ? response.hits.total.value\n          : response.hits.total || 0,\n      took: response.took,\n    };\n  } catch (error) {\n    console.error(\"Session search error:\", error);\n    return { hits: [], total: 0, took: 0 };\n  }\n}\n", "import {\n  getElasticsearchClient,\n  getEntityIndexName,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Issue, PrismaClient } from \"@prisma/client\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\n/**\n * Type for issue with all required relations for indexing\n */\ntype IssueForIndexing = Issue & {\n  createdBy: { name: string; image?: string | null };\n  integration?: { name: string } | null;\n  // Direct project relationship (preferred)\n  project?: { id: number; name: string; iconUrl?: string | null } | null;\n  // Fallback: Try to get project from any relationship\n  repositoryCases?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  sessions?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  testRuns?: Array<{\n    project: { id: number; name: string; iconUrl?: string | null };\n  }>;\n  sessionResults?: Array<{\n    session: {\n      project: { id: number; name: string; iconUrl?: string | null };\n    };\n  }>;\n  testRunResults?: Array<{\n    testRun: {\n      project: { id: number; name: string; iconUrl?: string | null };\n    };\n  }>;\n  testRunStepResults?: Array<{\n    testRunResult: {\n      testRun: {\n        project: { id: number; name: string; iconUrl?: string | null };\n      };\n    };\n  }>;\n};\n\n/**\n * Helper function to find project info from any issue relationship\n * Checks direct project relationship first, then falls back to relationship tables\n */\nfunction getProjectFromIssue(issue: IssueForIndexing): {\n  id: number;\n  name: string;\n  iconUrl?: string | null;\n} | null {\n  // Check direct project relationship first (most common and efficient)\n  if (issue.project) {\n    return issue.project;\n  }\n\n  // Fallback: Try repository cases\n  if (issue.repositoryCases?.[0]?.project) {\n    return issue.repositoryCases[0].project;\n  }\n\n  // Try sessions\n  if (issue.sessions?.[0]?.project) {\n    return issue.sessions[0].project;\n  }\n\n  // Try test runs\n  if (issue.testRuns?.[0]?.project) {\n    return issue.testRuns[0].project;\n  }\n\n  // Try session results\n  if (issue.sessionResults?.[0]?.session?.project) {\n    return issue.sessionResults[0].session.project;\n  }\n\n  // Try test run results\n  if (issue.testRunResults?.[0]?.testRun?.project) {\n    return issue.testRunResults[0].testRun.project;\n  }\n\n  // Try test run step results\n  if (issue.testRunStepResults?.[0]?.testRunResult?.testRun?.project) {\n    return issue.testRunStepResults[0].testRunResult.testRun.project;\n  }\n\n  return null;\n}\n\n/**\n * Index a single issue to Elasticsearch\n * @param issue - The issue to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function indexIssue(\n  issue: IssueForIndexing,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.ISSUE, tenantId);\n\n  // Try to get project info from any linked relationship\n  const projectInfo = getProjectFromIssue(issue);\n\n  // Skip indexing if no project is found (orphaned issue)\n  if (!projectInfo) {\n    console.warn(`Issue ${issue.id} (${issue.name}) has no linked project, skipping indexing`);\n    return;\n  }\n\n  // Extract text from TipTap JSON for note field\n  const noteText = issue.note ? extractTextFromNode(issue.note) : \"\";\n\n  const searchableContent = [\n    issue.name,\n    issue.title,\n    issue.description || \"\",\n    issue.externalId || \"\",\n    noteText,\n    issue.integration?.name || \"\",\n  ].join(\" \");\n\n  const document = {\n    id: issue.id,\n    projectId: projectInfo.id,\n    projectName: projectInfo.name,\n    projectIconUrl: projectInfo.iconUrl,\n    name: issue.name,\n    title: issue.title,\n    description: issue.description,\n    externalId: issue.externalId,\n    note: noteText,\n    url: (issue.data as any)?.url,\n    issueSystem: issue.integration?.name || \"Unknown\",\n    isDeleted: issue.isDeleted,\n    createdAt: issue.createdAt,\n    createdById: issue.createdById,\n    createdByName: issue.createdBy.name,\n    createdByImage: issue.createdBy.image,\n    searchableContent,\n  };\n\n  await client.index({\n    index: indexName,\n    id: issue.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete an issue from Elasticsearch\n * @param issueId - The ID of the issue to delete\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function deleteIssueFromIndex(\n  issueId: number,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.ISSUE, tenantId);\n\n  try {\n    await client.delete({\n      index: indexName,\n      id: issueId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete issue from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single issue to Elasticsearch\n * @param issueId - The ID of the issue to sync\n * @param prismaClient - Optional Prisma client for tenant-specific queries\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncIssueToElasticsearch(\n  issueId: number,\n  prismaClient?: PrismaClient,\n  tenantId?: string\n): Promise<boolean> {\n  const prisma = prismaClient || defaultPrisma;\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const issue = await prisma.issue.findUnique({\n      where: { id: issueId },\n      include: {\n        createdBy: true,\n        integration: true,\n        // Include direct project relationship (preferred)\n        project: true,\n        // Fallback: Check all possible relationships to find project\n        repositoryCases: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        sessions: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        testRuns: {\n          take: 1,\n          include: {\n            project: true,\n          },\n        },\n        sessionResults: {\n          take: 1,\n          include: {\n            session: {\n              include: {\n                project: true,\n              },\n            },\n          },\n        },\n        testRunResults: {\n          take: 1,\n          include: {\n            testRun: {\n              include: {\n                project: true,\n              },\n            },\n          },\n        },\n        testRunStepResults: {\n          take: 1,\n          include: {\n            testRunResult: {\n              include: {\n                testRun: {\n                  include: {\n                    project: true,\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (!issue) {\n      console.warn(`Issue ${issueId} not found`);\n      return false;\n    }\n\n    // Index issue including deleted ones (filtering happens at search time based on admin permissions)\n    // Note: indexIssue will skip issues without a valid project link\n    await indexIssue(issue as IssueForIndexing, tenantId);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync issue ${issueId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index issues for a project\n * @param projectId - The project ID to sync issues for\n * @param db - Prisma client instance\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncProjectIssuesToElasticsearch(\n  projectId: number,\n  db: any,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.ISSUE, tenantId);\n\n  console.log(`Starting issue sync for project ${projectId}${tenantId ? ` (tenant: ${tenantId})` : \"\"}`);\n\n  // Find issues either by direct projectId or through any relationship\n  const issues = await db.issue.findMany({\n    where: {\n      // Include deleted items (filtering happens at search time based on admin permissions)\n      OR: [\n        // Direct project relationship (preferred)\n        { projectId, project: { isDeleted: false } },\n        // Fallback: Find through relationships\n        { repositoryCases: { some: { projectId, project: { isDeleted: false } } } },\n        { sessions: { some: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        { testRuns: { some: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        { sessionResults: { some: { session: { projectId, isDeleted: false, project: { isDeleted: false } } } } },\n        { testRunResults: { some: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } } },\n        {\n          testRunStepResults: {\n            some: { testRunResult: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n          },\n        },\n      ],\n    },\n    include: {\n      createdBy: true,\n      integration: true,\n      // Include direct project relationship (preferred)\n      project: true,\n      // Fallback relationships\n      repositoryCases: {\n        where: { projectId, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      sessions: {\n        where: { projectId, isDeleted: false, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      testRuns: {\n        where: { projectId, isDeleted: false, project: { isDeleted: false } },\n        take: 1,\n        include: { project: true },\n      },\n      sessionResults: {\n        where: { session: { projectId, isDeleted: false, project: { isDeleted: false } } },\n        take: 1,\n        include: {\n          session: {\n            include: { project: true },\n          },\n        },\n      },\n      testRunResults: {\n        where: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } },\n        take: 1,\n        include: {\n          testRun: {\n            include: { project: true },\n          },\n        },\n      },\n      testRunStepResults: {\n        where: { testRunResult: { testRun: { projectId, isDeleted: false, project: { isDeleted: false } } } },\n        take: 1,\n        include: {\n          testRunResult: {\n            include: {\n              testRun: {\n                include: { project: true },\n              },\n            },\n          },\n        },\n      },\n    },\n  });\n\n  if (issues.length === 0) {\n    console.log(\"No issues to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  let skippedCount = 0;\n\n  for (const issue of issues) {\n    // Try to get project info from any linked relationship\n    const projectInfo = getProjectFromIssue(issue as IssueForIndexing);\n\n    // Skip issues without a valid project link\n    if (!projectInfo) {\n      console.warn(`Issue ${issue.id} has no linked project, skipping`);\n      skippedCount++;\n      continue;\n    }\n\n    // Extract text from TipTap JSON for note field\n    const noteText = issue.note ? extractTextFromNode(issue.note) : \"\";\n\n    const searchableContent = [\n      issue.name,\n      issue.title,\n      issue.description || \"\",\n      issue.externalId || \"\",\n      noteText,\n      issue.integration?.name || \"\",\n    ].join(\" \");\n\n    bulkBody.push({\n      index: {\n        _index: indexName,\n        _id: issue.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: issue.id,\n      projectId: projectInfo.id,\n      projectName: projectInfo.name,\n      projectIconUrl: projectInfo.iconUrl,\n      name: issue.name,\n      title: issue.title,\n      description: issue.description,\n      externalId: issue.externalId,\n      note: noteText,\n      url: (issue.data as any)?.url,\n      issueSystem: issue.integration?.name || \"Unknown\",\n      isDeleted: issue.isDeleted,\n      createdAt: issue.createdAt,\n      createdById: issue.createdById,\n      createdByName: issue.createdBy.name,\n      createdByImage: issue.createdBy.image,\n      searchableContent,\n    });\n  }\n\n  if (bulkBody.length === 0) {\n    console.log(\n      `No valid issues to index (${skippedCount} orphaned issues skipped)`\n    );\n    return;\n  }\n\n  try {\n    const bulkResponse = await client.bulk({ body: bulkBody, refresh: true });\n    if (bulkResponse.errors) {\n      const errorItems = bulkResponse.items.filter(\n        (item: any) => item.index?.error\n      );\n      console.error(`Bulk indexing errors: ${errorItems.length} failed documents`);\n      // Log detailed error information\n      errorItems.slice(0, 10).forEach((item: any) => {\n        if (item.index?.error) {\n          console.error(`  Failed to index document ${item.index._id}:`);\n          console.error(`    Error type: ${item.index.error.type}`);\n          console.error(`    Error reason: ${item.index.error.reason}`);\n          if (item.index.error.caused_by) {\n            console.error(`    Caused by: ${JSON.stringify(item.index.error.caused_by)}`);\n          }\n        }\n      });\n      if (errorItems.length > 10) {\n        console.error(`  ... and ${errorItems.length - 10} more errors`);\n      }\n    } else {\n      console.log(\n        `Successfully indexed ${bulkBody.length / 2} issues (${skippedCount} orphaned issues skipped)`\n      );\n    }\n  } catch (error) {\n    console.error(\"Failed to index issues:\", error);\n  }\n}\n", "import {\n  getElasticsearchClient,\n  getEntityIndexName,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Milestones, PrismaClient } from \"@prisma/client\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\n/**\n * Type for milestone with all required relations for indexing\n */\ntype MilestoneForIndexing = Milestones & {\n  project: { name: string; iconUrl?: string | null };\n  creator: { name: string; image?: string | null };\n  milestoneType: { name: string; icon?: { name: string } | null };\n  parent?: { name: string } | null;\n};\n\n/**\n * Index a single milestone to Elasticsearch\n * @param milestone - The milestone to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function indexMilestone(\n  milestone: MilestoneForIndexing,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.MILESTONE, tenantId);\n\n  // Extract text from TipTap JSON for note and docs fields\n  const noteText = milestone.note ? extractTextFromNode(milestone.note) : \"\";\n  const docsText = milestone.docs ? extractTextFromNode(milestone.docs) : \"\";\n\n  const searchableContent = [\n    milestone.name,\n    noteText,\n    docsText,\n  ].join(\" \");\n\n\n  const document = {\n    id: milestone.id,\n    projectId: milestone.projectId,\n    projectName: milestone.project.name,\n    projectIconUrl: milestone.project.iconUrl,\n    name: milestone.name,\n    note: noteText,\n    docs: docsText,\n    milestoneTypeId: milestone.milestoneTypesId,\n    milestoneTypeName: milestone.milestoneType.name,\n    milestoneTypeIcon: milestone.milestoneType.icon?.name,\n    parentId: milestone.parentId,\n    parentName: milestone.parent?.name,\n    isCompleted: milestone.isCompleted,\n    completedAt: milestone.completedAt,\n    isDeleted: milestone.isDeleted,\n    createdAt: milestone.createdAt,\n    createdById: milestone.createdBy,\n    createdByName: milestone.creator.name,\n    createdByImage: milestone.creator.image,\n    searchableContent,\n  };\n\n  await client.index({\n    index: indexName,\n    id: milestone.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete a milestone from Elasticsearch\n * @param milestoneId - The ID of the milestone to delete\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function deleteMilestoneFromIndex(\n  milestoneId: number,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.MILESTONE, tenantId);\n\n  try {\n    await client.delete({\n      index: indexName,\n      id: milestoneId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete milestone from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single milestone to Elasticsearch\n * @param milestoneId - The ID of the milestone to sync\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncMilestoneToElasticsearch(\n  milestoneId: number,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const milestone = await defaultPrisma.milestones.findUnique({\n      where: { id: milestoneId },\n      include: {\n        project: true,\n        creator: true,\n        milestoneType: {\n          include: {\n            icon: true,\n          },\n        },\n        parent: true,\n      },\n    });\n\n    if (!milestone) {\n      console.warn(`Milestone ${milestoneId} not found`);\n      return false;\n    }\n\n    // Index milestone including deleted ones (filtering happens at search time based on admin permissions)\n\n    // Index the milestone\n    await indexMilestone(milestone as MilestoneForIndexing, tenantId);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync milestone ${milestoneId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Bulk index milestones for a project\n * @param projectId - The project ID to sync milestones for\n * @param db - Prisma client instance\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncProjectMilestonesToElasticsearch(\n  projectId: number,\n  db: any,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.MILESTONE, tenantId);\n\n  console.log(`Starting milestone sync for project ${projectId}${tenantId ? ` (tenant: ${tenantId})` : \"\"}`);\n\n  const milestones = await db.milestones.findMany({\n    where: {\n      projectId: projectId,\n      // Include deleted items (filtering happens at search time based on admin permissions)\n    },\n    include: {\n      project: true,\n      creator: true,\n      milestoneType: {\n        include: {\n          icon: true,\n        },\n      },\n      parent: true,\n    },\n  });\n\n  if (milestones.length === 0) {\n    console.log(\"No milestones to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  for (const milestone of milestones) {\n    // Extract text from TipTap JSON for note and docs fields\n    const noteText = milestone.note ? extractTextFromNode(milestone.note) : \"\";\n    const docsText = milestone.docs ? extractTextFromNode(milestone.docs) : \"\";\n\n    const searchableContent = [\n      milestone.name,\n      noteText,\n      docsText,\n    ].join(\" \");\n\n\n    bulkBody.push({\n      index: {\n        _index: indexName,\n        _id: milestone.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: milestone.id,\n      projectId: milestone.projectId,\n      projectName: milestone.project.name,\n      projectIconUrl: milestone.project.iconUrl,\n      name: milestone.name,\n      note: noteText,\n      docs: docsText,\n      milestoneTypeId: milestone.milestoneTypesId,\n      milestoneTypeName: milestone.milestoneType.name,\n      milestoneTypeIcon: milestone.milestoneType.icon?.name,\n      parentId: milestone.parentId,\n      parentName: milestone.parent?.name,\n        isCompleted: milestone.isCompleted,\n      completedAt: milestone.completedAt,\n      isDeleted: milestone.isDeleted,\n      createdAt: milestone.createdAt,\n        createdById: milestone.createdBy,\n      createdByName: milestone.createdBy.name,\n      createdByImage: milestone.createdBy.image,\n        searchableContent,\n    });\n  }\n\n  try {\n    const bulkResponse = await client.bulk({ body: bulkBody, refresh: true });\n    if (bulkResponse.errors) {\n      const errorItems = bulkResponse.items.filter(\n        (item: any) => item.index?.error\n      );\n      console.error(`Bulk indexing errors: ${errorItems.length} failed documents`);\n      // Log detailed error information\n      errorItems.slice(0, 10).forEach((item: any) => {\n        if (item.index?.error) {\n          console.error(`  Failed to index document ${item.index._id}:`);\n          console.error(`    Error type: ${item.index.error.type}`);\n          console.error(`    Error reason: ${item.index.error.reason}`);\n          if (item.index.error.caused_by) {\n            console.error(`    Caused by: ${JSON.stringify(item.index.error.caused_by)}`);\n          }\n        }\n      });\n      if (errorItems.length > 10) {\n        console.error(`  ... and ${errorItems.length - 10} more errors`);\n      }\n    } else {\n      console.log(`Successfully indexed ${milestones.length} milestones`);\n    }\n  } catch (error) {\n    console.error(\"Failed to index milestones:\", error);\n  }\n}\n\n/**\n * Sync all milestones that have a specific parent\n * @param parentId - The parent milestone ID\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncChildMilestonesToElasticsearch(\n  parentId: number,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  try {\n    const childMilestones = await defaultPrisma.milestones.findMany({\n      where: {\n        parentId: parentId,\n        // Include deleted items (filtering happens at search time based on admin permissions)\n      },\n    });\n\n    for (const child of childMilestones) {\n      await syncMilestoneToElasticsearch(child.id, tenantId);\n    }\n  } catch (error) {\n    console.error(`Failed to sync child milestones of parent ${parentId}:`, error);\n  }\n}", "import {\n  getElasticsearchClient,\n  getEntityIndexName,\n} from \"./unifiedElasticsearchService\";\nimport { SearchableEntityType } from \"~/types/search\";\nimport type { Projects } from \"@prisma/client\";\nimport { prisma as defaultPrisma } from \"~/lib/prismaBase\";\nimport { extractTextFromNode } from \"~/utils/extractTextFromJson\";\n\ntype PrismaClientType = typeof defaultPrisma;\n\n/**\n * Type for project with all required relations for indexing\n */\ntype ProjectForIndexing = Projects & {\n  creator: { name: string; image?: string | null };\n};\n\n/**\n * Index a single project to Elasticsearch\n * @param project - The project to index\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function indexProject(\n  project: ProjectForIndexing,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    throw new Error(\"Elasticsearch client not available\");\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.PROJECT, tenantId);\n\n  const searchableContent = [\n    project.name,\n    project.note ? extractTextFromNode(project.note) : \"\",\n    project.docs ? extractTextFromNode(project.docs) : \"\",\n  ].join(\" \");\n\n  const document = {\n    id: project.id,\n    name: project.name,\n    iconUrl: project.iconUrl,\n    note: project.note,\n    docs: project.docs,\n    isDeleted: project.isDeleted,\n    createdAt: project.createdAt,\n    createdById: project.createdBy,\n    createdByName: project.creator.name,\n    createdByImage: project.creator.image,\n    searchableContent,\n  };\n\n  await client.index({\n    index: indexName,\n    id: project.id.toString(),\n    document,\n    refresh: true,\n  });\n}\n\n/**\n * Delete a project from Elasticsearch\n * @param projectId - The ID of the project to delete\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function deleteProjectFromIndex(\n  projectId: number,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const indexName = getEntityIndexName(SearchableEntityType.PROJECT, tenantId);\n\n  try {\n    await client.delete({\n      index: indexName,\n      id: projectId.toString(),\n      refresh: true,\n    });\n  } catch (error: any) {\n    if (error.meta?.statusCode !== 404) {\n      console.error(\"Failed to delete project from index:\", error);\n    }\n  }\n}\n\n/**\n * Sync a single project to Elasticsearch\n * @param projectId - The ID of the project to sync\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncProjectToElasticsearch(\n  projectId: number,\n  tenantId?: string\n): Promise<boolean> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return false;\n  }\n\n  try {\n    const project = await defaultPrisma.projects.findUnique({\n      where: { id: projectId },\n      include: {\n        creator: true,\n      },\n    });\n\n    if (!project) {\n      console.warn(`Project ${projectId} not found`);\n      return false;\n    }\n\n    // Index project including deleted ones (filtering happens at search time based on admin permissions)\n\n    // Index the project\n    await indexProject(project, tenantId);\n    return true;\n  } catch (error) {\n    console.error(`Failed to sync project ${projectId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Sync all projects to Elasticsearch\n * @param prismaClient - Optional Prisma client for tenant-specific queries\n * @param tenantId - Optional tenant ID for multi-tenant mode\n */\nexport async function syncAllProjectsToElasticsearch(\n  prismaClient?: PrismaClientType,\n  tenantId?: string\n): Promise<void> {\n  const client = getElasticsearchClient();\n  if (!client) {\n    console.warn(\"Elasticsearch client not available\");\n    return;\n  }\n\n  const prisma = prismaClient || defaultPrisma;\n  const indexName = getEntityIndexName(SearchableEntityType.PROJECT, tenantId);\n\n  console.log(`Starting project sync${tenantId ? ` (tenant: ${tenantId})` : \"\"}`);\n\n  const projects = await prisma.projects.findMany({\n    where: {\n      // Include deleted items (filtering happens at search time based on admin permissions)\n    },\n    include: {\n      creator: true,\n    },\n  });\n\n  if (projects.length === 0) {\n    console.log(\"No projects to index\");\n    return;\n  }\n\n  const bulkBody = [];\n  for (const project of projects) {\n    const searchableContent = [\n      project.name,\n      project.note ? extractTextFromNode(project.note) : \"\",\n      project.docs ? extractTextFromNode(project.docs) : \"\",\n    ].join(\" \");\n\n    bulkBody.push({\n      index: {\n        _index: indexName,\n        _id: project.id.toString(),\n      },\n    });\n\n    bulkBody.push({\n      id: project.id,\n      name: project.name,\n      iconUrl: project.iconUrl,\n      note: project.note,\n      docs: project.docs,\n      isDeleted: project.isDeleted,\n      createdAt: project.createdAt,\n      createdById: project.createdBy,\n      createdByName: project.creator.name,\n      createdByImage: project.creator.image,\n      searchableContent,\n    });\n  }\n\n  try {\n    const response = await client.bulk({ body: bulkBody, refresh: true });\n    if (response.errors) {\n      console.error(\"Bulk indexing errors:\", response.errors);\n    }\n    console.log(`Successfully indexed ${projects.length} projects`);\n  } catch (error) {\n    console.error(\"Failed to index projects:\", error);\n  }\n}", "// lib/multiTenantPrisma.ts\n// Multi-tenant Prisma client factory for shared worker containers\n\nimport { PrismaClient } from \"@prisma/client\";\nimport * as fs from \"fs\";\n\n/**\n * Tenant configuration interface\n */\nexport interface TenantConfig {\n  tenantId: string;\n  databaseUrl: string;\n  elasticsearchNode?: string;\n  elasticsearchIndex?: string;\n}\n\n/**\n * Check if multi-tenant mode is enabled\n */\nexport function isMultiTenantMode(): boolean {\n  return process.env.MULTI_TENANT_MODE === \"true\";\n}\n\n/**\n * Get the current instance's tenant ID\n * In multi-tenant deployments, each web app instance belongs to a single tenant.\n * Set via INSTANCE_TENANT_ID environment variable.\n *\n * Note: This returns the tenant ID whenever INSTANCE_TENANT_ID is set,\n * regardless of whether MULTI_TENANT_MODE is enabled. This allows web app\n * instances to include their tenant ID in queued jobs, which the shared\n * worker (running with MULTI_TENANT_MODE=true) can then use to route\n * database operations to the correct tenant.\n *\n * Returns undefined if INSTANCE_TENANT_ID is not configured.\n */\nexport function getCurrentTenantId(): string | undefined {\n  return process.env.INSTANCE_TENANT_ID;\n}\n\n/**\n * Cache of Prisma clients per tenant to avoid creating new connections for each job\n * Stores both the client and the database URL used to create it (for credential change detection)\n */\ninterface CachedClient {\n  client: PrismaClient;\n  databaseUrl: string;\n}\nconst tenantClients: Map<string, CachedClient> = new Map();\n\n/**\n * Tenant configurations loaded from environment or config file\n */\nlet tenantConfigs: Map<string, TenantConfig> | null = null;\n\n/**\n * Path to the tenant config file (can be set via TENANT_CONFIG_FILE env var)\n */\nconst TENANT_CONFIG_FILE = process.env.TENANT_CONFIG_FILE || \"/config/tenants.json\";\n\n/**\n * Load tenant configurations from file\n */\nfunction loadTenantsFromFile(filePath: string): Map<string, TenantConfig> {\n  const configs = new Map<string, TenantConfig>();\n\n  try {\n    if (fs.existsSync(filePath)) {\n      const fileContent = fs.readFileSync(filePath, \"utf-8\");\n      const parsed = JSON.parse(fileContent) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(parsed)) {\n        configs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n        });\n      }\n      console.log(`Loaded ${configs.size} tenant configurations from ${filePath}`);\n    }\n  } catch (error) {\n    console.error(`Failed to load tenant configs from ${filePath}:`, error);\n  }\n\n  return configs;\n}\n\n/**\n * Reload tenant configurations from file (for dynamic updates)\n * This allows adding new tenants without restarting workers\n */\nexport function reloadTenantConfigs(): Map<string, TenantConfig> {\n  // Clear cached configs\n  tenantConfigs = null;\n  // Reload\n  return loadTenantConfigs();\n}\n\n/**\n * Load tenant configurations from:\n * 1. Config file (TENANT_CONFIG_FILE env var or /config/tenants.json)\n * 2. TENANT_CONFIGS environment variable (JSON string)\n * 3. Individual environment variables: TENANT_<ID>_DATABASE_URL, etc.\n */\nexport function loadTenantConfigs(): Map<string, TenantConfig> {\n  if (tenantConfigs) {\n    return tenantConfigs;\n  }\n\n  tenantConfigs = new Map();\n\n  // Priority 1: Load from config file\n  const fileConfigs = loadTenantsFromFile(TENANT_CONFIG_FILE);\n  for (const [tenantId, config] of fileConfigs) {\n    tenantConfigs.set(tenantId, config);\n  }\n\n  // Priority 2: Load from TENANT_CONFIGS env var (can override file configs)\n  const configJson = process.env.TENANT_CONFIGS;\n  if (configJson) {\n    try {\n      const configs = JSON.parse(configJson) as Record<string, Omit<TenantConfig, \"tenantId\">>;\n      for (const [tenantId, config] of Object.entries(configs)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: config.databaseUrl,\n          elasticsearchNode: config.elasticsearchNode,\n          elasticsearchIndex: config.elasticsearchIndex,\n        });\n      }\n      console.log(`Loaded ${Object.keys(configs).length} tenant configurations from TENANT_CONFIGS env var`);\n    } catch (error) {\n      console.error(\"Failed to parse TENANT_CONFIGS:\", error);\n    }\n  }\n\n  // Priority 3: Individual tenant environment variables\n  // Format: TENANT_<TENANT_ID>_DATABASE_URL, TENANT_<TENANT_ID>_ELASTICSEARCH_NODE\n  for (const [key, value] of Object.entries(process.env)) {\n    const match = key.match(/^TENANT_([A-Z0-9_]+)_DATABASE_URL$/);\n    if (match && value) {\n      const tenantId = match[1].toLowerCase();\n      if (!tenantConfigs.has(tenantId)) {\n        tenantConfigs.set(tenantId, {\n          tenantId,\n          databaseUrl: value,\n          elasticsearchNode: process.env[`TENANT_${match[1]}_ELASTICSEARCH_NODE`],\n          elasticsearchIndex: process.env[`TENANT_${match[1]}_ELASTICSEARCH_INDEX`],\n        });\n      }\n    }\n  }\n\n  if (tenantConfigs.size === 0) {\n    console.warn(\"No tenant configurations found. Multi-tenant mode will not work without configurations.\");\n  }\n\n  return tenantConfigs;\n}\n\n/**\n * Get tenant configuration by ID\n */\nexport function getTenantConfig(tenantId: string): TenantConfig | undefined {\n  const configs = loadTenantConfigs();\n  return configs.get(tenantId);\n}\n\n/**\n * Get all tenant IDs\n */\nexport function getAllTenantIds(): string[] {\n  const configs = loadTenantConfigs();\n  return Array.from(configs.keys());\n}\n\n/**\n * Create a Prisma client for a specific tenant\n */\nfunction createTenantPrismaClient(config: TenantConfig): PrismaClient {\n  const client = new PrismaClient({\n    datasources: {\n      db: {\n        url: config.databaseUrl,\n      },\n    },\n    errorFormat: \"pretty\",\n  });\n\n  return client;\n}\n\n/**\n * Get or create a Prisma client for a specific tenant\n * Caches clients to reuse connections\n * Supports dynamic tenant addition by reloading configs if tenant not found\n * Automatically invalidates cached clients when credentials change\n */\nexport function getTenantPrismaClient(tenantId: string): PrismaClient {\n  // Always reload config from file to get latest credentials\n  reloadTenantConfigs();\n  const config = getTenantConfig(tenantId);\n\n  if (!config) {\n    throw new Error(`No configuration found for tenant: ${tenantId}`);\n  }\n\n  // Check cache - but invalidate if credentials have changed\n  const cached = tenantClients.get(tenantId);\n  if (cached) {\n    if (cached.databaseUrl === config.databaseUrl) {\n      // Credentials unchanged, reuse cached client\n      return cached.client;\n    } else {\n      // Credentials changed - disconnect old client and create new one\n      console.log(`Credentials changed for tenant ${tenantId}, invalidating cached client...`);\n      cached.client.$disconnect().catch((err) => {\n        console.error(`Error disconnecting stale client for tenant ${tenantId}:`, err);\n      });\n      tenantClients.delete(tenantId);\n    }\n  }\n\n  // Create and cache new client\n  const client = createTenantPrismaClient(config);\n  tenantClients.set(tenantId, { client, databaseUrl: config.databaseUrl });\n  console.log(`Created Prisma client for tenant: ${tenantId}`);\n\n  return client;\n}\n\n/**\n * Get a Prisma client based on job data\n * In single-tenant mode, returns the default client\n * In multi-tenant mode, returns tenant-specific client\n */\nexport function getPrismaClientForJob(jobData: { tenantId?: string }): PrismaClient {\n  if (!isMultiTenantMode()) {\n    // Single-tenant mode: use lightweight Prisma client (no ES sync extensions)\n    // Import lazily to avoid circular dependencies\n    const { prisma } = require(\"./prismaBase\");\n    return prisma;\n  }\n\n  // Multi-tenant mode: require tenantId\n  if (!jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n\n  return getTenantPrismaClient(jobData.tenantId);\n}\n\n/**\n * Disconnect all tenant clients (for graceful shutdown)\n */\nexport async function disconnectAllTenantClients(): Promise<void> {\n  const disconnectPromises: Promise<void>[] = [];\n\n  for (const [tenantId, cached] of tenantClients) {\n    console.log(`Disconnecting Prisma client for tenant: ${tenantId}`);\n    disconnectPromises.push(cached.client.$disconnect());\n  }\n\n  await Promise.all(disconnectPromises);\n  tenantClients.clear();\n  console.log(\"All tenant Prisma clients disconnected\");\n}\n\n/**\n * Base interface for job data that supports multi-tenancy\n */\nexport interface MultiTenantJobData {\n  tenantId?: string; // Optional in single-tenant mode, required in multi-tenant mode\n}\n\n/**\n * Validate job data for multi-tenant mode\n */\nexport function validateMultiTenantJobData(jobData: MultiTenantJobData): void {\n  if (isMultiTenantMode() && !jobData.tenantId) {\n    throw new Error(\"tenantId is required in multi-tenant mode\");\n  }\n}\n"],
  "mappings": "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",
  "names": ["IORedis", "prismaClient", "prisma", "getElasticsearchSettings", "prismaClient", "prisma", "prismaClient", "prisma", "prismaClient", "prisma", "prismaClient", "prisma", "prismaClient", "prisma", "prismaClient", "prisma", "import_client", "prisma", "prisma", "esClient"]
}
