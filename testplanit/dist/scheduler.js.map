{
  "version": 3,
  "sources": ["../lib/queues.ts", "../lib/valkey.ts", "../lib/queueNames.ts", "../workers/forecastWorker.ts", "../lib/prismaBase.ts", "../services/forecastService.ts", "../workers/notificationWorker.ts", "../scheduler.ts"],
  "sourcesContent": ["import { Queue } from \"bullmq\";\nimport valkeyConnection from \"./valkey\";\nimport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n} from \"./queueNames\";\n\n// Re-export queue names for backward compatibility\nexport {\n  FORECAST_QUEUE_NAME,\n  NOTIFICATION_QUEUE_NAME,\n  EMAIL_QUEUE_NAME,\n  SYNC_QUEUE_NAME,\n  TESTMO_IMPORT_QUEUE_NAME,\n  ELASTICSEARCH_REINDEX_QUEUE_NAME,\n};\n\n// Lazy-initialized queue instances\nlet _forecastQueue: Queue | null = null;\nlet _notificationQueue: Queue | null = null;\nlet _emailQueue: Queue | null = null;\nlet _syncQueue: Queue | null = null;\nlet _testmoImportQueue: Queue | null = null;\nlet _elasticsearchReindexQueue: Queue | null = null;\n\n/**\n * Get the forecast queue instance (lazy initialization)\n * Only creates the queue when first accessed\n */\nexport function getForecastQueue(): Queue | null {\n  if (_forecastQueue) return _forecastQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${FORECAST_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _forecastQueue = new Queue(FORECAST_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${FORECAST_QUEUE_NAME}\" initialized.`);\n\n  _forecastQueue.on(\"error\", (error) => {\n    console.error(`Queue ${FORECAST_QUEUE_NAME} error:`, error);\n  });\n\n  return _forecastQueue;\n}\n\n/**\n * Get the notification queue instance (lazy initialization)\n */\nexport function getNotificationQueue(): Queue | null {\n  if (_notificationQueue) return _notificationQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${NOTIFICATION_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _notificationQueue = new Queue(NOTIFICATION_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 1000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${NOTIFICATION_QUEUE_NAME}\" initialized.`);\n\n  _notificationQueue.on(\"error\", (error) => {\n    console.error(`Queue ${NOTIFICATION_QUEUE_NAME} error:`, error);\n  });\n\n  return _notificationQueue;\n}\n\n/**\n * Get the email queue instance (lazy initialization)\n */\nexport function getEmailQueue(): Queue | null {\n  if (_emailQueue) return _emailQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${EMAIL_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _emailQueue = new Queue(EMAIL_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 5,\n      backoff: {\n        type: \"exponential\",\n        delay: 10000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 5000,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${EMAIL_QUEUE_NAME}\" initialized.`);\n\n  _emailQueue.on(\"error\", (error) => {\n    console.error(`Queue ${EMAIL_QUEUE_NAME} error:`, error);\n  });\n\n  return _emailQueue;\n}\n\n/**\n * Get the sync queue instance (lazy initialization)\n */\nexport function getSyncQueue(): Queue | null {\n  if (_syncQueue) return _syncQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${SYNC_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _syncQueue = new Queue(SYNC_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 3,\n      backoff: {\n        type: \"exponential\",\n        delay: 5000,\n      },\n      removeOnComplete: {\n        age: 3600 * 24 * 3,\n        count: 500,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 7,\n      },\n    },\n  });\n\n  console.log(`Queue \"${SYNC_QUEUE_NAME}\" initialized.`);\n\n  _syncQueue.on(\"error\", (error) => {\n    console.error(`Queue ${SYNC_QUEUE_NAME} error:`, error);\n  });\n\n  return _syncQueue;\n}\n\n/**\n * Get the Testmo import queue instance (lazy initialization)\n */\nexport function getTestmoImportQueue(): Queue | null {\n  if (_testmoImportQueue) return _testmoImportQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _testmoImportQueue = new Queue(TESTMO_IMPORT_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 30,\n        count: 100,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 30,\n      },\n    },\n  });\n\n  console.log(`Queue \"${TESTMO_IMPORT_QUEUE_NAME}\" initialized.`);\n\n  _testmoImportQueue.on(\"error\", (error) => {\n    console.error(`Queue ${TESTMO_IMPORT_QUEUE_NAME} error:`, error);\n  });\n\n  return _testmoImportQueue;\n}\n\n/**\n * Get the Elasticsearch reindex queue instance (lazy initialization)\n */\nexport function getElasticsearchReindexQueue(): Queue | null {\n  if (_elasticsearchReindexQueue) return _elasticsearchReindexQueue;\n  if (!valkeyConnection) {\n    console.warn(`Valkey connection not available, Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" not initialized.`);\n    return null;\n  }\n\n  _elasticsearchReindexQueue = new Queue(ELASTICSEARCH_REINDEX_QUEUE_NAME, {\n    connection: valkeyConnection,\n    defaultJobOptions: {\n      attempts: 1,\n      removeOnComplete: {\n        age: 3600 * 24 * 7,\n        count: 50,\n      },\n      removeOnFail: {\n        age: 3600 * 24 * 14,\n      },\n    },\n  });\n\n  console.log(`Queue \"${ELASTICSEARCH_REINDEX_QUEUE_NAME}\" initialized.`);\n\n  _elasticsearchReindexQueue.on(\"error\", (error) => {\n    console.error(`Queue ${ELASTICSEARCH_REINDEX_QUEUE_NAME} error:`, error);\n  });\n\n  return _elasticsearchReindexQueue;\n}\n\n/**\n * Get all queues (initializes all of them)\n * Use this only when you need access to all queues (e.g., admin dashboard)\n */\nexport function getAllQueues() {\n  return {\n    forecastQueue: getForecastQueue(),\n    notificationQueue: getNotificationQueue(),\n    emailQueue: getEmailQueue(),\n    syncQueue: getSyncQueue(),\n    testmoImportQueue: getTestmoImportQueue(),\n    elasticsearchReindexQueue: getElasticsearchReindexQueue(),\n  };\n}\n", "import IORedis from \"ioredis\";\n\n// Check if we should skip Valkey connection (useful during build)\nconst skipConnection = process.env.SKIP_VALKEY_CONNECTION === \"true\";\n\n// Get Valkey URL from environment\nconst valkeyUrl = process.env.VALKEY_URL;\n\nif (!valkeyUrl && !skipConnection) {\n  // Log an error, but maybe don't throw immediately\n  // depending on whether Valkey is strictly required at startup\n  console.error(\n    \"VALKEY_URL environment variable is not set. Background jobs may fail.\"\n  );\n  // Optional: throw new Error('VALKEY_URL environment variable is not set.');\n}\n\n// Configure the connection options\nconst connectionOptions = {\n  maxRetriesPerRequest: null, // Required by BullMQ\n  enableReadyCheck: false, // Optional: Sometimes helps with startup race conditions\n};\n\nlet valkeyConnection: IORedis | null = null;\n\nif (valkeyUrl && !skipConnection) {\n  // Convert valkey:// to redis:// for ioredis compatibility\n  // ioredis expects redis:// protocol but we're connecting to Valkey\n  const connectionUrl = valkeyUrl.replace(/^valkey:\\/\\//, 'redis://');\n  \n  // Create and export the connection instance only if URL is provided\n  valkeyConnection = new IORedis(connectionUrl, connectionOptions);\n\n  valkeyConnection.on(\"connect\", () => {\n    console.log(\"Successfully connected to Valkey.\");\n  });\n\n  valkeyConnection.on(\"error\", (err) => {\n    console.error(\"Valkey connection error:\", err);\n  });\n} else {\n  console.warn(\"Valkey URL not provided. Valkey connection not established.\");\n}\n\nexport default valkeyConnection;", "// Queue name constants - no initialization, just names\nexport const FORECAST_QUEUE_NAME = \"forecast-updates\";\nexport const NOTIFICATION_QUEUE_NAME = \"notifications\";\nexport const EMAIL_QUEUE_NAME = \"emails\";\nexport const SYNC_QUEUE_NAME = \"issue-sync\";\nexport const TESTMO_IMPORT_QUEUE_NAME = \"testmo-imports\";\nexport const ELASTICSEARCH_REINDEX_QUEUE_NAME = \"elasticsearch-reindex\";\n", "import { Worker, Job } from \"bullmq\";\nimport valkeyConnection from \"../lib/valkey\";\nimport { FORECAST_QUEUE_NAME } from \"../lib/queueNames\";\nimport {\n  updateRepositoryCaseForecast,\n  getUniqueCaseGroupIds,\n  updateTestRunForecast,\n} from \"../services/forecastService\";\nimport { pathToFileURL } from \"node:url\";\nimport { prisma } from \"../lib/prismaBase\";\n\n// Define expected job data structures (optional but good practice)\ninterface UpdateSingleCaseJobData {\n  repositoryCaseId: number;\n}\n\n// Define job names for clarity and export them for the scheduler\nexport const JOB_UPDATE_SINGLE_CASE = \"update-single-case-forecast\";\nexport const JOB_UPDATE_ALL_CASES = \"update-all-cases-forecast\";\n\nconst processor = async (job: Job) => {\n  console.log(`Processing job ${job.id} of type ${job.name}`);\n  let successCount = 0;\n  let failCount = 0;\n\n  switch (job.name) {\n    case JOB_UPDATE_SINGLE_CASE:\n      const singleData = job.data as UpdateSingleCaseJobData;\n      if (!singleData || typeof singleData.repositoryCaseId !== \"number\") {\n        throw new Error(\n          `Invalid data for job ${job.id}: repositoryCaseId missing or not a number.`\n        );\n      }\n      try {\n        await updateRepositoryCaseForecast(singleData.repositoryCaseId);\n        successCount = 1;\n        console.log(\n          `Job ${job.id} completed: Updated forecast for case ${singleData.repositoryCaseId}`\n        );\n      } catch (error) {\n        failCount = 1;\n        console.error(\n          `Job ${job.id} failed for case ${singleData.repositoryCaseId}`,\n          error\n        );\n        throw error; // Re-throw to mark job as failed\n      }\n      break;\n\n    case JOB_UPDATE_ALL_CASES:\n      console.log(`Job ${job.id}: Starting update for all active cases.`);\n      // Reset counters for batch job\n      successCount = 0;\n      failCount = 0;\n      // Use unique case group IDs to avoid recalculating the same linked groups multiple times\n      const caseIds = await getUniqueCaseGroupIds();\n\n      // Track affected TestRuns to update them once at the end\n      const affectedTestRunIds = new Set<number>();\n\n      // Process cases sequentially, skipping TestRun updates and collecting affected TestRuns\n      for (const caseId of caseIds) {\n        try {\n          const result = await updateRepositoryCaseForecast(caseId, {\n            skipTestRunUpdate: true,\n            collectAffectedTestRuns: true,\n          });\n\n          // Collect affected TestRun IDs\n          for (const testRunId of result.affectedTestRunIds) {\n            affectedTestRunIds.add(testRunId);\n          }\n\n          successCount++;\n        } catch (error) {\n          console.error(\n            `Job ${job.id}: Failed to update forecast for case ${caseId}`,\n            error\n          );\n          failCount++;\n          // Continue processing other cases even if one fails\n        }\n      }\n\n      console.log(\n        `Job ${job.id}: Processed ${caseIds.length} unique case groups. Success: ${successCount}, Failed: ${failCount}`\n      );\n\n      // Filter out completed test runs (they're locked and don't need forecast updates)\n      console.log(\n        `Job ${job.id}: Filtering ${affectedTestRunIds.size} affected test runs...`\n      );\n\n      const activeTestRuns = await prisma.testRuns.findMany({\n        where: {\n          id: { in: Array.from(affectedTestRunIds) },\n          isCompleted: false,\n        },\n        select: { id: true },\n      });\n\n      const activeTestRunIds = activeTestRuns.map((tr) => tr.id);\n      const skippedCompletedCount =\n        affectedTestRunIds.size - activeTestRunIds.length;\n\n      console.log(\n        `Job ${job.id}: Updating ${activeTestRunIds.length} active test runs (skipped ${skippedCompletedCount} completed)...`\n      );\n      let testRunSuccessCount = 0;\n      let testRunFailCount = 0;\n\n      for (const testRunId of activeTestRunIds) {\n        try {\n          await updateTestRunForecast(testRunId);\n          testRunSuccessCount++;\n        } catch (error) {\n          console.error(\n            `Job ${job.id}: Failed to update forecast for test run ${testRunId}`,\n            error\n          );\n          testRunFailCount++;\n        }\n      }\n\n      console.log(\n        `Job ${job.id} completed: Updated ${testRunSuccessCount} test runs. Failed: ${testRunFailCount}. Skipped ${skippedCompletedCount} completed.`\n      );\n\n      if (failCount > 0 || testRunFailCount > 0) {\n        // Indicate partial failure but don't necessarily throw to allow job completion\n        console.warn(\n          `Job ${job.id} finished with ${failCount} case failures and ${testRunFailCount} test run failures.`\n        );\n        // throw new Error(`Completed with failures.`); // Uncomment to mark job as failed\n      }\n      break;\n\n    default:\n      throw new Error(`Unknown job type: ${job.name}`);\n  }\n\n  return { status: \"completed\", successCount, failCount }; // Return summary\n};\n\nasync function startWorker() {\n  // Initialize the worker only if Valkey connection exists\n  if (valkeyConnection) {\n    const worker = new Worker(FORECAST_QUEUE_NAME, processor, {\n      connection: valkeyConnection,\n      concurrency: 5,\n      limiter: {\n        max: 100,\n        duration: 1000,\n      },\n    });\n\n    worker.on(\"completed\", (job, result) => {\n      console.info(\n        `Worker: Job ${job.id} (${job.name}) completed successfully. Result:`,\n        result\n      );\n    });\n\n    worker.on(\"failed\", (job, err) => {\n      console.error(\n        `Worker: Job ${job?.id} (${job?.name}) failed with error:`,\n        err\n      );\n    });\n\n    worker.on(\"error\", (err) => {\n      console.error(\"Worker encountered an error:\", err);\n    });\n\n    console.log(\"Forecast worker started and listening for jobs...\");\n\n    // Graceful shutdown handling\n    const shutdown = async () => {\n      console.log(\"Shutting down forecast worker...\");\n      await worker.close();\n      console.log(\"Forecast worker shut down gracefully.\");\n      process.exit(0);\n    };\n\n    process.on(\"SIGTERM\", shutdown);\n    process.on(\"SIGINT\", shutdown);\n  } else {\n    console.warn(\n      \"Valkey connection not available. Forecast worker cannot start.\"\n    );\n    process.exit(1);\n  }\n}\n\n// Conditionally call startWorker only when this file is executed directly\n// This check ensures importing the file doesn't automatically start the worker\n// Works with both ESM and CommonJS\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  typeof import.meta === \"undefined\" ||\n  (import.meta as any).url === undefined\n) {\n  startWorker().catch((err) => {\n    console.error(\"Failed to start worker:\", err);\n    process.exit(1);\n  });\n}\n", "// lib/prismaBase.ts\n// Base Prisma client without Elasticsearch sync extensions\n// Use this for workers and services that don't need auto-ES sync\n\nimport { PrismaClient } from \"@prisma/client\";\n\n// Declare global types\ndeclare global {\n  var prismaBase: PrismaClient | undefined;\n}\n\nlet prismaClient: PrismaClient;\n\n// Create a simple PrismaClient without extensions\nif (process.env.NODE_ENV === \"production\") {\n  prismaClient = new PrismaClient({ errorFormat: \"pretty\" });\n} else {\n  // Reuse global instance in development to prevent hot-reload issues\n  if (!global.prismaBase) {\n    global.prismaBase = new PrismaClient({ errorFormat: \"colorless\" });\n  }\n  prismaClient = global.prismaBase;\n}\n\nexport const prisma = prismaClient;\n", "\"use server\";\n\nimport { prisma } from \"../lib/prismaBase\";\n\ntype UpdateRepositoryCaseForecastOptions = {\n  skipTestRunUpdate?: boolean;\n  collectAffectedTestRuns?: boolean;\n};\n\ntype UpdateRepositoryCaseForecastResult = {\n  updatedCaseIds: number[];\n  affectedTestRunIds: number[];\n};\n\ntype UpdateTestRunForecastOptions = {\n  alreadyRefreshedCaseIds?: Set<number>;\n};\n\n/**\n * Calculates the group-averaged forecast for a repository case and all cases linked by SAME_TEST_DIFFERENT_SOURCE.\n * Updates forecastManual and forecastAutomated for all cases in the group.\n * @param repositoryCaseId The ID of the RepositoryCase to update.\n * @returns The unique RepositoryCase IDs whose forecasts were refreshed and affected TestRun IDs.\n */\nexport async function updateRepositoryCaseForecast(\n  repositoryCaseId: number,\n  options: UpdateRepositoryCaseForecastOptions = {}\n): Promise<UpdateRepositoryCaseForecastResult> {\n  if (process.env.DEBUG_FORECAST) {\n    console.log(\n      `Calculating group forecast for RepositoryCase ID: ${repositoryCaseId}`\n    );\n  }\n\n  try {\n    // 1. Find all cases in the SAME_TEST_DIFFERENT_SOURCE link group (including itself)\n    const caseAndLinks = await prisma.repositoryCases.findUnique({\n      where: { id: repositoryCaseId },\n      select: {\n        id: true,\n        source: true,\n        linksFrom: {\n          where: { type: \"SAME_TEST_DIFFERENT_SOURCE\", isDeleted: false },\n          select: { caseBId: true },\n        },\n        linksTo: {\n          where: { type: \"SAME_TEST_DIFFERENT_SOURCE\", isDeleted: false },\n          select: { caseAId: true },\n        },\n      },\n    });\n    if (!caseAndLinks) return { updatedCaseIds: [], affectedTestRunIds: [] };\n    const linkedIds = [\n      caseAndLinks.id,\n      ...caseAndLinks.linksFrom.map((l) => l.caseBId),\n      ...caseAndLinks.linksTo.map((l) => l.caseAId),\n    ];\n    const uniqueCaseIds = Array.from(new Set(linkedIds));\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] Group case IDs:\", uniqueCaseIds);\n\n    // 2. Fetch all cases in the group with their source\n    const allCases = await prisma.repositoryCases.findMany({\n      where: { id: { in: uniqueCaseIds } },\n      select: { id: true, source: true },\n    });\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] allCases:\", allCases);\n\n    // 3. Gather all manual and JUNIT result durations\n    // Manual: TestRunResults (isDeleted: false, elapsed > 0)\n    const manualCaseIds = allCases\n      .filter((c) => c.source === \"MANUAL\")\n      .map((c) => c.id);\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] manualCaseIds:\", manualCaseIds);\n    let manualResults: { elapsed: number | null }[] = [];\n    if (manualCaseIds.length) {\n      // 1. Find all TestRunCase IDs for these repositoryCaseIds\n      const testRunCases = await prisma.testRunCases.findMany({\n        where: { repositoryCaseId: { in: manualCaseIds } },\n        select: { id: true },\n      });\n      const testRunCaseIds = testRunCases.map((trc) => trc.id);\n\n      // 2. Find all TestRunResults for those TestRunCase IDs\n      manualResults = testRunCaseIds.length\n        ? await prisma.testRunResults.findMany({\n            where: {\n              testRunCaseId: { in: testRunCaseIds },\n              isDeleted: false,\n              elapsed: { gt: 0 },\n            },\n            select: { elapsed: true },\n          })\n        : [];\n    }\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] manualResults:\", manualResults);\n    const manualDurations = manualResults\n      .map((r) => r.elapsed)\n      .filter((v) => v != null);\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] manualDurations:\", manualDurations);\n\n    // JUNIT: JUnitTestResult (statusId not null, time > 0)\n    const junitCaseIds = allCases\n      .filter((c) => c.source === \"JUNIT\")\n      .map((c) => c.id);\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] junitCaseIds:\", junitCaseIds);\n    const junitResults = junitCaseIds.length\n      ? await prisma.jUnitTestResult.findMany({\n          where: {\n            repositoryCaseId: { in: junitCaseIds },\n            time: { gt: 0 },\n          },\n          select: { time: true },\n        })\n      : [];\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] junitResults:\", junitResults);\n    const junitDurations = junitResults\n      .map((r) => r.time)\n      .filter((v) => v != null);\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] junitDurations:\", junitDurations);\n\n    // 4. Compute averages\n    const avgManual =\n      manualDurations.length > 0\n        ? Math.round(\n            manualDurations.reduce((a, b) => a + b, 0) / manualDurations.length\n          )\n        : null;\n    const avgJunit =\n      junitDurations.length > 0\n        ? parseFloat(\n            (\n              junitDurations.reduce((a, b) => a + b, 0) / junitDurations.length\n            ).toFixed(3)\n          )\n        : null;\n    if (process.env.DEBUG_FORECAST) console.log(\"[Forecast] avgManual:\", avgManual, \"avgJunit:\", avgJunit);\n\n    // 5. Update all cases in the group (using updateMany can reset fields to defaults, so we use individual updates)\n    for (const caseId of uniqueCaseIds) {\n      await prisma.repositoryCases.update({\n        where: { id: caseId },\n        data: {\n          forecastManual: avgManual,\n          forecastAutomated: avgJunit,\n        },\n      });\n    }\n    if (process.env.DEBUG_FORECAST) {\n      console.log(\n        `Updated forecastManual=${avgManual}, forecastAutomated=${avgJunit} for cases: [${uniqueCaseIds.join(\", \")}]`\n      );\n    }\n\n    // --- Update TestRun forecasts for all TestRuns affected by these case updates ---\n    const affectedTestRunCases = await prisma.testRunCases.findMany({\n      where: {\n        repositoryCaseId: { in: uniqueCaseIds },\n      },\n      select: {\n        testRunId: true,\n      },\n    });\n\n    const uniqueAffectedTestRunIds = Array.from(\n      new Set(affectedTestRunCases.map((trc) => trc.testRunId))\n    );\n\n    // If not skipping, update TestRuns now; otherwise just collect their IDs\n    if (!options.skipTestRunUpdate && uniqueAffectedTestRunIds.length > 0) {\n      for (const testRunId of uniqueAffectedTestRunIds) {\n        await updateTestRunForecast(testRunId, {\n          alreadyRefreshedCaseIds: new Set(uniqueCaseIds),\n        });\n      }\n    }\n    // --- End TestRun forecast update ---\n\n    return {\n      updatedCaseIds: uniqueCaseIds,\n      affectedTestRunIds: options.collectAffectedTestRuns ? uniqueAffectedTestRunIds : [],\n    };\n  } catch (error) {\n    console.error(\n      `Error updating group forecast for RepositoryCase ID ${repositoryCaseId}:`,\n      error\n    );\n    throw error;\n  }\n}\n\n/**\n * Calculates and updates the forecast for a specific TestRun.\n * @param testRunId The ID of the TestRun to update.\n */\nexport async function updateTestRunForecast(\n  testRunId: number,\n  options: UpdateTestRunForecastOptions = {}\n): Promise<void> {\n  if (process.env.DEBUG_FORECAST) console.log(`Updating forecast for TestRun ID: ${testRunId}`);\n  try {\n    // 1. Fetch all TestRunCases for this TestRun, including their status system name\n    let testRunCasesWithDetails = await prisma.testRunCases.findMany({\n      where: { testRunId: testRunId },\n      select: {\n        repositoryCaseId: true,\n        status: {\n          select: {\n            systemName: true,\n          },\n        },\n      },\n    });\n\n    // Ensure repository case forecasts are current before recalculating the run forecast\n    if (testRunCasesWithDetails.length > 0) {\n      const processedCaseIds = new Set<number>(\n        options.alreadyRefreshedCaseIds\n          ? Array.from(options.alreadyRefreshedCaseIds)\n          : []\n      );\n\n      const repositoryCaseIdsInRun = Array.from(\n        new Set(testRunCasesWithDetails.map((trc) => trc.repositoryCaseId))\n      );\n\n      let refreshedAnyCase = false;\n\n      for (const repositoryCaseId of repositoryCaseIdsInRun) {\n        if (processedCaseIds.has(repositoryCaseId)) {\n          continue;\n        }\n\n        const result = await updateRepositoryCaseForecast(\n          repositoryCaseId,\n          { skipTestRunUpdate: true }\n        );\n\n        if (result.updatedCaseIds.length > 0) {\n          refreshedAnyCase = true;\n          for (const refreshedId of result.updatedCaseIds) {\n            processedCaseIds.add(refreshedId);\n          }\n        }\n      }\n\n      if (refreshedAnyCase) {\n        // Refetch to capture any status changes that may have occurred during case refresh\n        testRunCasesWithDetails = await prisma.testRunCases.findMany({\n          where: { testRunId: testRunId },\n          select: {\n            repositoryCaseId: true,\n            status: {\n              select: {\n                systemName: true,\n              },\n            },\n          },\n        });\n      }\n    }\n\n    // 2. Filter cases to include only those with no result or an \"untested\" status\n    const repositoryCaseIdsToForecast = testRunCasesWithDetails\n      .filter(\n        (trc) => trc.status === null || trc.status?.systemName === \"UNTESTED\"\n      )\n      .map((trc) => trc.repositoryCaseId);\n\n    if (!repositoryCaseIdsToForecast.length) {\n      // No applicable cases in this test run, so clear its forecasts\n      await prisma.testRuns.update({\n        where: { id: testRunId },\n        data: {\n          forecastManual: null,\n          forecastAutomated: null,\n        },\n      });\n      if (process.env.DEBUG_FORECAST) {\n        console.log(\n          `Cleared forecasts for TestRun ID: ${testRunId} as no pending/untested cases were found`\n        );\n      }\n      return;\n    }\n\n    // 3. Fetch the RepositoryCases for these filtered IDs\n    const repositoryCases = await prisma.repositoryCases.findMany({\n      where: { id: { in: repositoryCaseIdsToForecast } },\n      select: { forecastManual: true, forecastAutomated: true },\n    });\n\n    // 4. Calculate the sum of forecasts\n    let totalForecastManual = 0;\n    let totalForecastAutomated = 0;\n    let hasManual = false;\n    let hasAutomated = false;\n\n    for (const rc of repositoryCases) {\n      if (rc.forecastManual !== null) {\n        totalForecastManual += rc.forecastManual;\n        hasManual = true;\n      }\n      if (rc.forecastAutomated !== null) {\n        totalForecastAutomated += rc.forecastAutomated;\n        hasAutomated = true;\n      }\n    }\n\n    // 5. Update the TestRun record\n    await prisma.testRuns.update({\n      where: { id: testRunId },\n      data: {\n        forecastManual: hasManual ? totalForecastManual : null,\n        forecastAutomated: hasAutomated\n          ? parseFloat(totalForecastAutomated.toFixed(3))\n          : null,\n      },\n    });\n\n    if (process.env.DEBUG_FORECAST) {\n      console.log(\n        `Updated TestRun ID ${testRunId} with forecastManual=${totalForecastManual}, forecastAutomated=${totalForecastAutomated}`\n      );\n    }\n  } catch (error) {\n    console.error(\n      `Error updating forecast for TestRun ID ${testRunId}:`,\n      error\n    );\n    throw error;\n  }\n}\n\n/**\n * Fetches all RepositoryCase IDs that are not deleted or archived.\n * @returns An array of active RepositoryCase IDs.\n */\nexport async function getActiveRepositoryCaseIds(): Promise<number[]> {\n  if (process.env.DEBUG_FORECAST) console.log(\"Fetching active repository case IDs...\");\n  try {\n    const cases = await prisma.repositoryCases.findMany({\n      where: {\n        isDeleted: false,\n        isArchived: false,\n      },\n      select: {\n        id: true,\n      },\n    });\n    const ids = cases.map((c) => c.id);\n    if (process.env.DEBUG_FORECAST) console.log(`Found ${ids.length} active repository cases.`);\n    return ids;\n  } catch (error) {\n    console.error(\"Error fetching active repository case IDs:\", error);\n    throw error; // Propagate error\n  }\n}\n\n/**\n * Fetches unique case group representatives to avoid recalculating the same linked groups.\n * For each group of cases linked by SAME_TEST_DIFFERENT_SOURCE, returns only one representative case ID.\n * Processes cases in batches to avoid hitting database bind variable limits.\n * @returns An array of representative RepositoryCase IDs, one per unique group.\n */\nexport async function getUniqueCaseGroupIds(): Promise<number[]> {\n  if (process.env.DEBUG_FORECAST) console.log(\"Fetching unique case group representatives...\");\n  try {\n    const BATCH_SIZE = 1000;\n    const processedCaseIds = new Set<number>();\n    const uniqueRepresentatives: number[] = [];\n\n    // First, get all active case IDs\n    const allCaseIds = await prisma.repositoryCases.findMany({\n      where: {\n        isDeleted: false,\n        isArchived: false,\n      },\n      select: {\n        id: true,\n      },\n    });\n\n    const totalCases = allCaseIds.length;\n    if (process.env.DEBUG_FORECAST) console.log(`Processing ${totalCases} active cases in batches of ${BATCH_SIZE}...`);\n\n    // Process in batches to avoid bind variable limit\n    for (let i = 0; i < allCaseIds.length; i += BATCH_SIZE) {\n      const batchIds = allCaseIds.slice(i, i + BATCH_SIZE).map((c) => c.id);\n\n      const casesWithLinks = await prisma.repositoryCases.findMany({\n        where: {\n          id: { in: batchIds },\n        },\n        select: {\n          id: true,\n          linksFrom: {\n            where: { type: \"SAME_TEST_DIFFERENT_SOURCE\", isDeleted: false },\n            select: { caseBId: true },\n          },\n          linksTo: {\n            where: { type: \"SAME_TEST_DIFFERENT_SOURCE\", isDeleted: false },\n            select: { caseAId: true },\n          },\n        },\n      });\n\n      for (const caseData of casesWithLinks) {\n        // Skip if we've already processed this case as part of another group\n        if (processedCaseIds.has(caseData.id)) {\n          continue;\n        }\n\n        // This case becomes the representative for its group\n        uniqueRepresentatives.push(caseData.id);\n\n        // Mark all cases in this group as processed\n        const linkedIds = [\n          caseData.id,\n          ...caseData.linksFrom.map((l) => l.caseBId),\n          ...caseData.linksTo.map((l) => l.caseAId),\n        ];\n\n        for (const linkedId of linkedIds) {\n          processedCaseIds.add(linkedId);\n        }\n      }\n\n      if (process.env.DEBUG_FORECAST) {\n        console.log(`Processed batch ${Math.floor(i / BATCH_SIZE) + 1}/${Math.ceil(totalCases / BATCH_SIZE)}: ${uniqueRepresentatives.length} unique groups so far`);\n      }\n    }\n\n    if (process.env.DEBUG_FORECAST) {\n      console.log(\n        `Found ${uniqueRepresentatives.length} unique case groups (from ${totalCases} total active cases)`\n      );\n    }\n    return uniqueRepresentatives;\n  } catch (error) {\n    console.error(\"Error fetching unique case group IDs:\", error);\n    throw error;\n  }\n}\n\n// Optional: Disconnect Prisma client on exit (important for graceful shutdown)\n// This might be better handled in the worker's shutdown process\n// process.on('exit', async () => {\n//   await prisma.$disconnect();\n// });\n", "import { Worker, Job } from \"bullmq\";\nimport valkeyConnection from \"../lib/valkey\";\nimport { NOTIFICATION_QUEUE_NAME, getEmailQueue } from \"../lib/queues\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { pathToFileURL } from \"node:url\";\n\nconst prisma = new PrismaClient();\n\n// Define job data structures\ninterface CreateNotificationJobData {\n  userId: string;\n  type: string;\n  title: string;\n  message: string;\n  relatedEntityId?: string;\n  relatedEntityType?: string;\n  data?: any;\n}\n\ninterface ProcessUserNotificationsJobData {\n  userId: string;\n}\n\n// Define job names\nexport const JOB_CREATE_NOTIFICATION = \"create-notification\";\nexport const JOB_PROCESS_USER_NOTIFICATIONS = \"process-user-notifications\";\nexport const JOB_SEND_DAILY_DIGEST = \"send-daily-digest\";\n\nconst processor = async (job: Job) => {\n  console.log(`Processing notification job ${job.id} of type ${job.name}`);\n\n  switch (job.name) {\n    case JOB_CREATE_NOTIFICATION:\n      const createData = job.data as CreateNotificationJobData;\n\n      try {\n        // Check user preferences first\n        const userPreferences = await prisma.userPreferences.findUnique({\n          where: { userId: createData.userId },\n        });\n\n        // Get global notification settings from AppConfig\n        const globalSettings = await prisma.appConfig.findUnique({\n          where: { key: \"notificationSettings\" },\n        });\n\n        // Determine notification mode\n        let notificationMode =\n          userPreferences?.notificationMode || \"USE_GLOBAL\";\n        if (notificationMode === \"USE_GLOBAL\") {\n          const settingsValue = globalSettings?.value as {\n            defaultMode?: string;\n          } | null;\n          notificationMode = (settingsValue?.defaultMode || \"IN_APP\") as any;\n        }\n\n        // Skip notification creation if user has notifications set to NONE\n        if (notificationMode === \"NONE\") {\n          console.log(\n            `Skipping notification for user ${createData.userId} - notifications disabled`\n          );\n          return;\n        }\n\n        // Create the in-app notification (for all modes except NONE)\n        const notification = await prisma.notification.create({\n          data: {\n            userId: createData.userId,\n            type: createData.type as any,\n            title: createData.title,\n            message: createData.message,\n            relatedEntityId: createData.relatedEntityId,\n            relatedEntityType: createData.relatedEntityType,\n            data: createData.data,\n          },\n        });\n\n        // Queue email if needed based on notification mode\n        if (notificationMode === \"IN_APP_EMAIL_IMMEDIATE\") {\n          await getEmailQueue()?.add(\"send-notification-email\", {\n            notificationId: notification.id,\n            userId: createData.userId,\n            immediate: true,\n          });\n        }\n\n        console.log(\n          `Created notification ${notification.id} for user ${createData.userId} with mode ${notificationMode}`\n        );\n      } catch (error) {\n        console.error(`Failed to create notification:`, error);\n        throw error;\n      }\n      break;\n\n    case JOB_PROCESS_USER_NOTIFICATIONS:\n      const processData = job.data as ProcessUserNotificationsJobData;\n\n      try {\n        // Get unread notifications for the user\n        const notifications = await prisma.notification.findMany({\n          where: {\n            userId: processData.userId,\n            isRead: false,\n            isDeleted: false,\n          },\n          orderBy: { createdAt: \"desc\" },\n        });\n\n        console.log(\n          `Processing ${notifications.length} notifications for user ${processData.userId}`\n        );\n      } catch (error) {\n        console.error(`Failed to process user notifications:`, error);\n        throw error;\n      }\n      break;\n\n    case JOB_SEND_DAILY_DIGEST:\n      try {\n        // Get global settings from AppConfig\n        const globalSettings = await prisma.appConfig.findUnique({\n          where: { key: \"notificationSettings\" },\n        });\n        const settingsValue = globalSettings?.value as {\n          defaultMode?: string;\n        } | null;\n        const globalDefaultMode = settingsValue?.defaultMode || \"IN_APP\";\n\n        // Get all users with IN_APP_EMAIL_DAILY preference or USE_GLOBAL where global is daily\n        const users = await prisma.userPreferences.findMany({\n          where: {\n            OR: [\n              { notificationMode: \"IN_APP_EMAIL_DAILY\" },\n              {\n                notificationMode: \"USE_GLOBAL\",\n                ...(globalDefaultMode === \"IN_APP_EMAIL_DAILY\"\n                  ? {}\n                  : { id: \"none\" }), // Only include if global is daily\n              },\n            ],\n          },\n          include: {\n            user: true,\n          },\n        });\n\n        for (const userPref of users) {\n          // Get unread notifications from the last 24 hours\n          const yesterday = new Date();\n          yesterday.setDate(yesterday.getDate() - 1);\n\n          const notifications = await prisma.notification.findMany({\n            where: {\n              userId: userPref.userId,\n              isRead: false,\n              isDeleted: false,\n              createdAt: { gte: yesterday },\n            },\n            orderBy: { createdAt: \"desc\" },\n          });\n\n          if (notifications.length > 0) {\n            await getEmailQueue()?.add(\"send-digest-email\", {\n              userId: userPref.userId,\n              notifications: notifications.map((n) => ({\n                id: n.id,\n                title: n.title,\n                message: n.message,\n                createdAt: n.createdAt,\n              })),\n            });\n          }\n        }\n\n        console.log(`Processed daily digest for ${users.length} users`);\n      } catch (error) {\n        console.error(`Failed to send daily digest:`, error);\n        throw error;\n      }\n      break;\n\n    default:\n      throw new Error(`Unknown job type: ${job.name}`);\n  }\n};\n\nlet worker: Worker | null = null;\n\n// Function to start the worker\nconst startWorker = async () => {\n  if (valkeyConnection) {\n    worker = new Worker(NOTIFICATION_QUEUE_NAME, processor, {\n      connection: valkeyConnection,\n      concurrency: 5,\n    });\n\n    worker.on(\"completed\", (job) => {\n      console.log(`Job ${job.id} completed successfully.`);\n    });\n\n    worker.on(\"failed\", (job, err) => {\n      console.error(`Job ${job?.id} failed:`, err);\n    });\n\n    worker.on(\"error\", (err) => {\n      console.error(\"Worker error:\", err);\n    });\n\n    console.log(\n      `Notification worker started for queue \"${NOTIFICATION_QUEUE_NAME}\".`\n    );\n  } else {\n    console.warn(\n      \"Valkey connection not available. Notification worker not started.\"\n    );\n  }\n\n  // Allow graceful shutdown\n  process.on(\"SIGINT\", async () => {\n    console.log(\"Shutting down notification worker...\");\n    if (worker) {\n      await worker.close();\n    }\n    await prisma.$disconnect();\n    process.exit(0);\n  });\n};\n\n// Run the worker if this file is executed directly (works with both ESM and CommonJS)\nif (\n  (typeof import.meta !== \"undefined\" &&\n    import.meta.url === pathToFileURL(process.argv[1]).href) ||\n  (typeof import.meta === \"undefined\" ||\n    (import.meta as any).url === undefined)\n) {\n  console.log(\"Notification worker running...\");\n  startWorker().catch((err) => {\n    console.error(\"Failed to start notification worker:\", err);\n    process.exit(1);\n  });\n}\n\nexport default worker;\nexport { processor };\n", "import { getForecastQueue, getNotificationQueue } from \"./lib/queues\";\nimport { FORECAST_QUEUE_NAME, NOTIFICATION_QUEUE_NAME } from \"./lib/queues\";\nimport { JOB_UPDATE_ALL_CASES } from \"./workers/forecastWorker\";\nimport { JOB_SEND_DAILY_DIGEST } from \"./workers/notificationWorker\";\n\n// Define the cron schedule (e.g., every day at 3:00 AM server time)\n// Uses standard cron syntax: min hour day(month) month day(week)\nconst CRON_SCHEDULE_DAILY_3AM = \"0 3 * * *\";\nconst CRON_SCHEDULE_DAILY_8AM = \"0 8 * * *\"; // For daily digest emails\n\nasync function scheduleJobs() {\n  console.log(\"Attempting to schedule jobs...\");\n\n  const forecastQueue = getForecastQueue();\n  const notificationQueue = getNotificationQueue();\n\n  if (!forecastQueue || !notificationQueue) {\n    console.error(\"Required queues are not initialized. Cannot schedule jobs.\");\n    process.exit(1); // Exit if queues aren't available\n  }\n\n  try {\n    // Clean up any old versions of the repeatable job first\n    const repeatableJobs = await forecastQueue.getRepeatableJobs();\n    let removedCount = 0;\n    for (const job of repeatableJobs) {\n      // Check job name specifically - avoids removing unrelated repeatable jobs\n      if (job.name === JOB_UPDATE_ALL_CASES) {\n        console.log(\n          `Removing existing repeatable job \"${job.name}\" with key: ${job.key}`\n        );\n        await forecastQueue.removeRepeatableByKey(job.key);\n        removedCount++;\n      }\n    }\n    if (removedCount > 0) {\n      console.log(`Removed ${removedCount} old repeatable forecast jobs.`);\n    }\n\n    // Add the repeatable job to update all cases\n    await forecastQueue.add(\n      JOB_UPDATE_ALL_CASES, // Job name from worker\n      {}, // No specific data needed\n      {\n        repeat: {\n          // BullMQ v3+ uses pattern instead of cron\n          // For older versions use: cron: CRON_SCHEDULE_DAILY_3AM\n          pattern: CRON_SCHEDULE_DAILY_3AM,\n          // tz: 'UTC', // Example: Explicitly set timezone if needed\n        },\n        jobId: JOB_UPDATE_ALL_CASES, // Use the job name as a predictable ID\n      }\n    );\n\n    console.log(\n      `Successfully scheduled repeatable job \"${JOB_UPDATE_ALL_CASES}\" with pattern \"${CRON_SCHEDULE_DAILY_3AM}\" on queue \"${FORECAST_QUEUE_NAME}\".`\n    );\n\n    // Schedule daily digest notifications\n    const notificationRepeatableJobs =\n      await notificationQueue.getRepeatableJobs();\n    let removedNotificationCount = 0;\n    for (const job of notificationRepeatableJobs) {\n      if (job.name === JOB_SEND_DAILY_DIGEST) {\n        console.log(\n          `Removing existing repeatable job \"${job.name}\" with key: ${job.key}`\n        );\n        await notificationQueue.removeRepeatableByKey(job.key);\n        removedNotificationCount++;\n      }\n    }\n    if (removedNotificationCount > 0) {\n      console.log(\n        `Removed ${removedNotificationCount} old repeatable notification jobs.`\n      );\n    }\n\n    // Add the repeatable job for daily digest\n    await notificationQueue.add(\n      JOB_SEND_DAILY_DIGEST,\n      {},\n      {\n        repeat: {\n          pattern: CRON_SCHEDULE_DAILY_8AM,\n        },\n        jobId: JOB_SEND_DAILY_DIGEST,\n      }\n    );\n\n    console.log(\n      `Successfully scheduled repeatable job \"${JOB_SEND_DAILY_DIGEST}\" with pattern \"${CRON_SCHEDULE_DAILY_8AM}\" on queue \"${NOTIFICATION_QUEUE_NAME}\".`\n    );\n  } catch (error) {\n    console.error(\"Error scheduling jobs:\", error);\n    process.exit(1); // Exit if scheduling fails\n  }\n}\n\n// Run the scheduling function\nscheduleJobs()\n  .then(() => {\n    console.log(\"Scheduling script finished successfully.\");\n    // Close the connection used by the queue ONLY if this script is standalone\n    // If part of app init, the main app should manage connection lifecycle\n    // forecastQueue?.client.disconnect();\n    process.exit(0); // Exit successfully\n  })\n  .catch((err) => {\n    console.error(\"Scheduling script failed unexpectedly:\", err);\n    process.exit(1); // Exit with error\n  });\n\n// Keep the script running if it's part of a larger initialization process\n// or exit if it's standalone.\n// setTimeout(() => {}, 10000); // Example keep-alive\n"],
  "mappings": "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",
  "names": ["IORedis", "import_bullmq", "worker", "import_bullmq", "import_client", "import_node_url", "import_meta", "prisma", "processor", "startWorker"]
}
