import { describe, it, expect } from "vitest";
import { generateShareKey, isValidShareKey } from "./share-tokens";

describe("generateShareKey", () => {
  describe("format and entropy", () => {
    it("should generate a 43-character string", () => {
      const shareKey = generateShareKey();
      expect(shareKey.length).toBe(43);
    });

    it("should only contain URL-safe base64url characters", () => {
      const shareKey = generateShareKey();
      // base64url: A-Z, a-z, 0-9, -, _
      expect(shareKey).toMatch(/^[A-Za-z0-9_-]+$/);
    });

    it("should not contain base64 padding (=)", () => {
      const shareKey = generateShareKey();
      expect(shareKey).not.toContain("=");
    });

    it("should not contain + or / characters", () => {
      const shareKey = generateShareKey();
      expect(shareKey).not.toContain("+");
      expect(shareKey).not.toContain("/");
    });

    it("should generate 256 bits (32 bytes) of entropy", () => {
      const shareKey = generateShareKey();
      // 32 bytes = 256 bits
      // base64url encoding: 4 chars per 3 bytes, so 32 bytes = 43 chars (with padding removed)
      // Verify by decoding and checking length
      const decoded = Buffer.from(shareKey, "base64url");
      expect(decoded.length).toBe(32);
    });
  });

  describe("uniqueness", () => {
    it("should generate unique keys on each call", () => {
      const key1 = generateShareKey();
      const key2 = generateShareKey();

      expect(key1).not.toBe(key2);
    });

    it("should generate 1000 unique keys", () => {
      const keys = new Set<string>();
      const count = 1000;

      for (let i = 0; i < count; i++) {
        keys.add(generateShareKey());
      }

      expect(keys.size).toBe(count);
    });

    it("should have high entropy across multiple keys", () => {
      // Generate 100 keys and ensure they all differ significantly
      const keys = Array.from({ length: 100 }, () => generateShareKey());

      // Check that all keys are unique
      const uniqueKeys = new Set(keys);
      expect(uniqueKeys.size).toBe(100);

      // Check that keys don't share common prefixes (weak randomness indicator)
      const prefixes = keys.map((key) => key.substring(0, 10));
      const uniquePrefixes = new Set(prefixes);
      expect(uniquePrefixes.size).toBe(100);
    });
  });

  describe("cryptographic properties", () => {
    it("should be suitable for use in URLs", () => {
      const shareKey = generateShareKey();
      const url = `https://example.com/share/${shareKey}`;

      // Should not require URL encoding
      expect(encodeURIComponent(shareKey)).toBe(shareKey);
      expect(url).toContain(shareKey);
    });

    it("should have sufficient entropy for security", () => {
      // 32 bytes = 256 bits of entropy
      // Collision probability is negligible (2^-256)
      const shareKey = generateShareKey();
      const decoded = Buffer.from(shareKey, "base64url");

      // Verify it's truly random by checking it's not all zeros
      const allZeros = decoded.every((byte) => byte === 0);
      expect(allZeros).toBe(false);

      // Verify it's not all the same byte
      const firstByte = decoded[0];
      const allSame = decoded.every((byte) => byte === firstByte);
      expect(allSame).toBe(false);
    });
  });
});

describe("isValidShareKey", () => {
  describe("valid keys", () => {
    it("should validate keys generated by generateShareKey", () => {
      const shareKey = generateShareKey();
      expect(isValidShareKey(shareKey)).toBe(true);
    });

    it("should validate multiple generated keys", () => {
      for (let i = 0; i < 10; i++) {
        const shareKey = generateShareKey();
        expect(isValidShareKey(shareKey)).toBe(true);
      }
    });

  });

  describe("invalid keys", () => {
    it("should reject keys that are too short", () => {
      expect(isValidShareKey("abcd1234")).toBe(false);
      expect(isValidShareKey("")).toBe(false);
      expect(isValidShareKey("a".repeat(42))).toBe(false);
    });

    it("should reject keys that are too long", () => {
      expect(isValidShareKey("a".repeat(44))).toBe(false);
      expect(isValidShareKey("a".repeat(100))).toBe(false);
    });

    it("should reject keys with invalid characters (base64 padding)", () => {
      const keyWithPadding = "aBcDeFgHiJkLmNoPqRsTuVwXyZa012345678901=";
            expect(isValidShareKey(keyWithPadding)).toBe(false);
    });

    it("should reject keys with + character", () => {
      const keyWithPlus = "aBcDeFgHiJkLmNoPqRsTuVwXyZa012345678901+";
            expect(isValidShareKey(keyWithPlus)).toBe(false);
    });

    it("should reject keys with / character", () => {
      const keyWithSlash = "aBcDeFgHiJkLmNoPqRsTuVwXyZa012345678901/";
            expect(isValidShareKey(keyWithSlash)).toBe(false);
    });

    it("should reject keys with spaces", () => {
      const keyWithSpaces = "aBcDeFgHiJkLm NoPqRsTuVwXyZa012345678901";
            expect(isValidShareKey(keyWithSpaces)).toBe(false);
    });

    it("should reject keys with special characters", () => {
      expect(isValidShareKey("aBcDeFgHiJkLm@NoPqRsTuVwXyZa0123456789012")).toBe(false);
      expect(isValidShareKey("aBcDeFgHiJkLm#NoPqRsTuVwXyZa0123456789012")).toBe(false);
      expect(isValidShareKey("aBcDeFgHiJkLm$NoPqRsTuVwXyZa0123456789012")).toBe(false);
      expect(isValidShareKey("aBcDeFgHiJkLm%NoPqRsTuVwXyZa0123456789012")).toBe(false);
    });

    it("should reject null or undefined", () => {
      expect(isValidShareKey(null as any)).toBe(false);
      expect(isValidShareKey(undefined as any)).toBe(false);
    });

    it("should reject non-string values", () => {
      expect(isValidShareKey(12345 as any)).toBe(false);
      expect(isValidShareKey({} as any)).toBe(false);
      expect(isValidShareKey([] as any)).toBe(false);
    });
  });

  describe("edge cases", () => {
    it("should handle very long strings", () => {
      const veryLong = "a".repeat(1000);
      expect(isValidShareKey(veryLong)).toBe(false);
    });

    it("should handle strings with unicode characters", () => {
      const unicodeKey = "aBcDeFgHiJkLm密码qRsTuVwXyZa0123456789012";
      expect(isValidShareKey(unicodeKey)).toBe(false);
    });

    it("should handle mixed valid and invalid characters", () => {
      const mixedKey = "aBcDeFgHiJkLm-_+NoPqRsTuVwXyZa0123456789";
            expect(isValidShareKey(mixedKey)).toBe(false); // Contains +
    });
  });
});
