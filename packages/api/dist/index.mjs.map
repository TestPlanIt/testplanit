{"version":3,"sources":["../src/client.ts"],"names":[],"mappings":"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","file":"index.mjs","sourcesContent":["import type {\n  TestPlanItClientConfig,\n  ApiError,\n  TestRun,\n  RepositoryCase,\n  TestRunCase,\n  TestRunResult,\n  Status,\n  Project,\n  Configuration,\n  Milestone,\n  WorkflowState,\n  RepositoryFolder,\n  Template,\n  Tag,\n  Attachment,\n  CreateTestRunOptions,\n  UpdateTestRunOptions,\n  CreateTestCaseOptions,\n  CreateTagOptions,\n  CreateFolderOptions,\n  AddTestCaseToRunOptions,\n  CreateTestResultOptions,\n  ListTestRunsOptions,\n  PaginatedResponse,\n  FindTestCaseOptions,\n  FindOrCreateTestCaseResult,\n  ImportTestResultsOptions,\n  ImportProgressEvent,\n  NormalizedStatus,\n  JUnitTestSuite,\n  JUnitTestResult,\n  CreateJUnitTestSuiteOptions,\n  CreateJUnitTestResultOptions,\n  UpdateJUnitTestSuiteOptions,\n} from \"./types.js\";\n\n/**\n * Custom error class for TestPlanIt API errors\n */\nexport class TestPlanItError extends Error {\n  public statusCode?: number;\n  public code?: string;\n  public details?: unknown;\n\n  constructor(message: string, options?: Partial<ApiError>) {\n    super(message);\n    this.name = \"TestPlanItError\";\n    this.statusCode = options?.statusCode;\n    this.code = options?.code;\n    this.details = options?.details;\n  }\n}\n\n/**\n * ZenStack response wrapper\n */\ninterface ZenStackResponse<T> {\n  data?: T;\n  error?: {\n    message: string;\n    code?: string;\n  };\n}\n\n/**\n * CLI Lookup request\n */\ninterface LookupRequest {\n  projectId?: number;\n  type:\n    | \"project\"\n    | \"state\"\n    | \"config\"\n    | \"milestone\"\n    | \"tag\"\n    | \"folder\"\n    | \"testRun\";\n  name: string;\n  createIfMissing?: boolean;\n}\n\n/**\n * CLI Lookup response\n */\ninterface LookupResponse {\n  id: number;\n  name: string;\n  created?: boolean;\n}\n\n/**\n * TestPlanIt API Client\n *\n * Official JavaScript/TypeScript client for interacting with the TestPlanIt API.\n * Uses the ZenStack /api/model endpoints for CRUD operations and /api/cli/lookup for name lookups.\n *\n * @example\n * ```typescript\n * import { TestPlanItClient } from '@testplanit/api';\n *\n * const client = new TestPlanItClient({\n *   baseUrl: 'https://testplanit.example.com',\n *   apiToken: 'tpi_your_token_here',\n * });\n *\n * // Create a test run\n * const testRun = await client.createTestRun({\n *   projectId: 1,\n *   name: 'Automated Test Run',\n * });\n * ```\n */\nexport class TestPlanItClient {\n  private readonly baseUrl: string;\n  private readonly apiToken: string;\n  private readonly timeout: number;\n  private readonly maxRetries: number;\n  private readonly retryDelay: number;\n  private readonly headers: Record<string, string>;\n\n  // Cache for statuses to avoid repeated lookups\n  private statusCache: Map<number, Status[]> = new Map();\n\n  constructor(config: TestPlanItClientConfig) {\n    if (!config.baseUrl) {\n      throw new TestPlanItError(\"baseUrl is required\");\n    }\n    if (!config.apiToken) {\n      throw new TestPlanItError(\"apiToken is required\");\n    }\n\n    // Normalize base URL (remove trailing slash)\n    this.baseUrl = config.baseUrl.replace(/\\/$/, \"\");\n    this.apiToken = config.apiToken;\n    this.timeout = config.timeout ?? 30000;\n    this.maxRetries = config.maxRetries ?? 3;\n    this.retryDelay = config.retryDelay ?? 1000;\n    this.headers = config.headers ?? {};\n  }\n\n  // ============================================================================\n  // HTTP Methods\n  // ============================================================================\n\n  /**\n   * Make an authenticated request to the API\n   */\n  private async request<T>(\n    method: string,\n    path: string,\n    options?: {\n      body?: unknown;\n      query?: Record<string, string | number | boolean | undefined>;\n      headers?: Record<string, string>;\n    }\n  ): Promise<T> {\n    const url = new URL(path, this.baseUrl);\n\n    // Add query parameters\n    if (options?.query) {\n      for (const [key, value] of Object.entries(options.query)) {\n        if (value !== undefined) {\n          url.searchParams.set(key, String(value));\n        }\n      }\n    }\n\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${this.apiToken}`,\n      \"Content-Type\": \"application/json\",\n      ...this.headers,\n      ...options?.headers,\n    };\n\n    const fetchOptions: RequestInit = {\n      method,\n      headers,\n      signal: AbortSignal.timeout(this.timeout),\n    };\n\n    if (options?.body && method !== \"GET\") {\n      fetchOptions.body = JSON.stringify(options.body);\n    }\n\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n      try {\n        const response = await fetch(url.toString(), fetchOptions);\n\n        if (!response.ok) {\n          const errorBody = await response.text();\n          let errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n          let errorDetails: unknown;\n\n          try {\n            const parsed = JSON.parse(errorBody);\n            // Extract message from various error response formats\n            if (typeof parsed.message === \"string\") {\n              errorMessage = parsed.message;\n            } else if (typeof parsed.error === \"string\") {\n              errorMessage = parsed.error;\n            } else if (\n              typeof parsed.error === \"object\" &&\n              parsed.error !== null\n            ) {\n              // ZenStack returns { error: { message: 'string', ... } }\n              errorMessage =\n                parsed.error.message ||\n                parsed.error.reason ||\n                JSON.stringify(parsed.error);\n            } else if (\n              parsed.error === undefined &&\n              parsed.message === undefined\n            ) {\n              // Unknown format, include full body\n              errorMessage = `HTTP ${response.status}: ${JSON.stringify(\n                parsed\n              )}`;\n            }\n            errorDetails = parsed;\n          } catch {\n            // Body is not JSON\n            if (errorBody) {\n              // Truncate very long error bodies (like HTML 404 pages)\n              errorMessage =\n                errorBody.length > 500\n                  ? errorBody.slice(0, 500) + \"...\"\n                  : errorBody;\n            }\n          }\n\n          throw new TestPlanItError(errorMessage, {\n            statusCode: response.status,\n            details: errorDetails,\n          });\n        }\n\n        // Handle empty responses\n        const text = await response.text();\n        if (!text) {\n          return undefined as T;\n        }\n\n        return JSON.parse(text) as T;\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        // Don't retry on client errors (4xx) except 429 (rate limit)\n        if (error instanceof TestPlanItError) {\n          if (\n            error.statusCode &&\n            error.statusCode >= 400 &&\n            error.statusCode < 500 &&\n            error.statusCode !== 429\n          ) {\n            throw error;\n          }\n        }\n\n        // Wait before retrying\n        if (attempt < this.maxRetries) {\n          await this.sleep(this.retryDelay * (attempt + 1));\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Make a ZenStack model API request\n   * ZenStack endpoints are: /api/model/{model}/{operation}\n   * Based on the OpenAPI spec:\n   * - Read operations (findMany, findFirst, findUnique, count, aggregate, groupBy) use GET with ?q= parameter\n   * - create, createMany, upsert use POST with body\n   * - update, updateMany use PATCH with body\n   * - delete, deleteMany use DELETE with body\n   */\n  private async zenstack<T>(\n    model: string,\n    operation: string,\n    body?: unknown\n  ): Promise<T> {\n    const readOperations = [\n      \"findMany\",\n      \"findFirst\",\n      \"findUnique\",\n      \"count\",\n      \"aggregate\",\n      \"groupBy\",\n    ];\n    const postOperations = [\"create\", \"createMany\", \"upsert\"];\n    const patchOperations = [\"update\", \"updateMany\"];\n    const deleteOperations = [\"delete\", \"deleteMany\"];\n\n    let response: ZenStackResponse<T>;\n\n    if (readOperations.includes(operation)) {\n      // Read operations use GET with ?q= parameter\n      if (body) {\n        const queryParam = encodeURIComponent(JSON.stringify(body));\n        response = await this.request<ZenStackResponse<T>>(\n          \"GET\",\n          `/api/model/${model}/${operation}?q=${queryParam}`\n        );\n      } else {\n        response = await this.request<ZenStackResponse<T>>(\n          \"GET\",\n          `/api/model/${model}/${operation}`\n        );\n      }\n    } else if (postOperations.includes(operation)) {\n      response = await this.request<ZenStackResponse<T>>(\n        \"POST\",\n        `/api/model/${model}/${operation}`,\n        { body }\n      );\n    } else if (patchOperations.includes(operation)) {\n      response = await this.request<ZenStackResponse<T>>(\n        \"PATCH\",\n        `/api/model/${model}/${operation}`,\n        { body }\n      );\n    } else if (deleteOperations.includes(operation)) {\n      response = await this.request<ZenStackResponse<T>>(\n        \"DELETE\",\n        `/api/model/${model}/${operation}`,\n        { body }\n      );\n    } else {\n      // Default to POST for any other operation\n      response = await this.request<ZenStackResponse<T>>(\n        \"POST\",\n        `/api/model/${model}/${operation}`,\n        { body }\n      );\n    }\n\n    // Handle ZenStack error responses\n    if (response && typeof response === \"object\" && \"error\" in response) {\n      const error = (response as ZenStackResponse<T>).error;\n      if (error) {\n        // Handle various error formats\n        let message: string;\n        if (typeof error === \"string\") {\n          message = error;\n        } else if (typeof error === \"object\" && error !== null) {\n          message = error.message || JSON.stringify(error);\n        } else {\n          message = String(error);\n        }\n        throw new TestPlanItError(message, {\n          code:\n            typeof error === \"object\" && error !== null\n              ? error.code\n              : undefined,\n          details: error,\n        });\n      }\n    }\n\n    // Handle case where response is null/undefined\n    if (response === null || response === undefined) {\n      return undefined as T;\n    }\n\n    // Extract data from response\n    if (typeof response === \"object\" && \"data\" in response) {\n      return (response as ZenStackResponse<T>).data as T;\n    }\n\n    // If response doesn't have data property, return as-is (shouldn't happen with ZenStack)\n    return response as T;\n  }\n\n  /**\n   * Make a multipart form data request\n   */\n  private async requestFormData<T>(\n    method: string,\n    path: string,\n    formData: FormData,\n    options?: {\n      query?: Record<string, string | number | boolean | undefined>;\n    }\n  ): Promise<T> {\n    const url = new URL(path, this.baseUrl);\n\n    if (options?.query) {\n      for (const [key, value] of Object.entries(options.query)) {\n        if (value !== undefined) {\n          url.searchParams.set(key, String(value));\n        }\n      }\n    }\n\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${this.apiToken}`,\n      ...this.headers,\n    };\n\n    // Don't set Content-Type - let fetch set it with boundary\n    const fetchOptions: RequestInit = {\n      method,\n      headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout),\n    };\n\n    const response = await fetch(url.toString(), fetchOptions);\n\n    if (!response.ok) {\n      const errorBody = await response.text();\n      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n\n      try {\n        const parsed = JSON.parse(errorBody);\n        errorMessage = parsed.message || parsed.error || errorMessage;\n      } catch {\n        if (errorBody) {\n          errorMessage = errorBody;\n        }\n      }\n\n      throw new TestPlanItError(errorMessage, { statusCode: response.status });\n    }\n\n    const text = await response.text();\n    if (!text) {\n      return undefined as T;\n    }\n\n    return JSON.parse(text) as T;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  // ============================================================================\n  // CLI Lookup (for name-to-ID resolution)\n  // ============================================================================\n\n  /**\n   * Look up an entity by name and get its ID\n   * Uses the /api/cli/lookup endpoint\n   */\n  async lookup(options: LookupRequest): Promise<LookupResponse> {\n    return this.request<LookupResponse>(\"POST\", \"/api/cli/lookup\", {\n      body: options,\n    });\n  }\n\n  // ============================================================================\n  // Projects\n  // ============================================================================\n\n  /**\n   * Get project by ID\n   */\n  async getProject(projectId: number): Promise<Project> {\n    return this.zenstack<Project>(\"projects\", \"findUnique\", {\n      where: { id: projectId },\n    });\n  }\n\n  /**\n   * List all projects accessible to the authenticated user\n   */\n  async listProjects(): Promise<Project[]> {\n    return this.zenstack<Project[]>(\"projects\", \"findMany\", {\n      where: { isDeleted: false },\n    });\n  }\n\n  // ============================================================================\n  // Statuses\n  // ============================================================================\n\n  /**\n   * Get all statuses for a project (with Automation scope)\n   */\n  async getStatuses(projectId: number): Promise<Status[]> {\n    // Check cache first\n    if (this.statusCache.has(projectId)) {\n      return this.statusCache.get(projectId)!;\n    }\n\n    const statuses = await this.zenstack<Status[]>(\"status\", \"findMany\", {\n      where: {\n        isEnabled: true,\n        isDeleted: false,\n        projects: {\n          some: {\n            projectId: projectId,\n          },\n        },\n        scope: {\n          some: {\n            scope: {\n              name: \"Automation\",\n            },\n          },\n        },\n      },\n      include: {\n        color: true,\n      },\n    });\n\n    this.statusCache.set(projectId, statuses);\n    return statuses;\n  }\n\n  /**\n   * Get status ID for a normalized status name\n   */\n  async getStatusId(\n    projectId: number,\n    status: NormalizedStatus\n  ): Promise<number | undefined> {\n    const statuses = await this.getStatuses(projectId);\n\n    // Map normalized status to system names\n    const systemNameMap: Record<NormalizedStatus, string[]> = {\n      passed: [\"passed\", \"pass\", \"success\"],\n      failed: [\"failed\", \"fail\", \"failure\", \"error\"],\n      skipped: [\"skipped\", \"skip\", \"ignored\"],\n      blocked: [\"blocked\", \"block\"],\n      pending: [\"pending\", \"untested\", \"not_run\"],\n    };\n\n    const systemNames = systemNameMap[status];\n\n    for (const systemName of systemNames) {\n      const found = statuses.find(\n        (s) =>\n          s.systemName.toLowerCase() === systemName ||\n          s.name.toLowerCase() === systemName ||\n          s.aliases?.toLowerCase().includes(systemName)\n      );\n      if (found) {\n        return found.id;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Clear the status cache (useful if statuses are updated)\n   */\n  clearStatusCache(): void {\n    this.statusCache.clear();\n  }\n\n  // ============================================================================\n  // Test Runs\n  // ============================================================================\n\n  /**\n   * Create a new test run\n   */\n  async createTestRun(options: CreateTestRunOptions): Promise<TestRun> {\n    // Get the IN_PROGRESS workflow state for RUNS (or first available if none)\n    const workflows = await this.zenstack<WorkflowState[]>(\n      \"workflows\",\n      \"findMany\",\n      {\n        where: {\n          isEnabled: true,\n          isDeleted: false,\n          scope: \"RUNS\",\n          workflowType: \"IN_PROGRESS\",\n          projects: {\n            some: { projectId: options.projectId },\n          },\n        },\n        orderBy: { order: \"asc\" },\n        take: 1,\n      }\n    );\n\n    // Fall back to any RUNS workflow if no IN_PROGRESS one exists\n    let defaultStateId = options.stateId || workflows[0]?.id;\n    if (!defaultStateId) {\n      const fallbackWorkflows = await this.zenstack<WorkflowState[]>(\n        \"workflows\",\n        \"findMany\",\n        {\n          where: {\n            isEnabled: true,\n            isDeleted: false,\n            scope: \"RUNS\",\n            projects: {\n              some: { projectId: options.projectId },\n            },\n          },\n          orderBy: { order: \"asc\" },\n          take: 1,\n        }\n      );\n      defaultStateId = fallbackWorkflows[0]?.id;\n    }\n\n    if (!defaultStateId) {\n      throw new TestPlanItError(\n        \"No workflow state found for test runs in this project\"\n      );\n    }\n\n    // ZenStack REST API requires relation syntax (connect) instead of scalar FK fields\n    const data: Record<string, unknown> = {\n      name: options.name,\n      testRunType: options.testRunType ?? \"REGULAR\",\n      project: { connect: { id: options.projectId } },\n      state: { connect: { id: defaultStateId } },\n    };\n\n    // Add optional relations\n    if (options.configId) {\n      data.configuration = { connect: { id: options.configId } };\n    }\n    if (options.milestoneId) {\n      data.milestone = { connect: { id: options.milestoneId } };\n    }\n    if (options.tagIds?.length) {\n      data.tags = { connect: options.tagIds.map((id) => ({ id })) };\n    }\n\n    return this.zenstack<TestRun>(\"testRuns\", \"create\", { data });\n  }\n\n  /**\n   * Get a test run by ID\n   */\n  async getTestRun(testRunId: number): Promise<TestRun> {\n    return this.zenstack<TestRun>(\"testRuns\", \"findUnique\", {\n      where: { id: testRunId },\n    });\n  }\n\n  /**\n   * Update a test run\n   */\n  async updateTestRun(\n    testRunId: number,\n    options: UpdateTestRunOptions\n  ): Promise<TestRun> {\n    return this.zenstack<TestRun>(\"testRuns\", \"update\", {\n      where: { id: testRunId },\n      data: options,\n    });\n  }\n\n  /**\n   * Complete a test run\n   * Sets isCompleted to true and updates the workflow state to the first DONE state\n   * @param testRunId - The test run ID\n   * @param projectId - The project ID (required to look up the DONE workflow state)\n   */\n  async completeTestRun(\n    testRunId: number,\n    projectId: number\n  ): Promise<TestRun> {\n    // Get the DONE workflow state for RUNS\n    const workflows = await this.zenstack<WorkflowState[]>(\n      \"workflows\",\n      \"findMany\",\n      {\n        where: {\n          isEnabled: true,\n          isDeleted: false,\n          scope: \"RUNS\",\n          workflowType: \"DONE\",\n          projects: {\n            some: { projectId },\n          },\n        },\n        orderBy: { order: \"asc\" },\n        take: 1,\n      }\n    );\n\n    const doneStateId = workflows[0]?.id;\n\n    // Build update data - completedAt is auto-set by the backend when isCompleted becomes true\n    const updateData: UpdateTestRunOptions = {\n      isCompleted: true,\n    };\n    if (doneStateId) {\n      updateData.state = { connect: { id: doneStateId } };\n    }\n\n    return this.updateTestRun(testRunId, updateData);\n  }\n\n  /**\n   * List test runs for a project\n   * Uses the dedicated /api/test-runs/completed endpoint\n   */\n  async listTestRuns(\n    options: ListTestRunsOptions\n  ): Promise<PaginatedResponse<TestRun>> {\n    const response = await this.request<{\n      runs: TestRun[];\n      totalCount: number;\n      pageCount: number;\n    }>(\"GET\", \"/api/test-runs/completed\", {\n      query: {\n        projectId: options.projectId,\n        page: options.page ?? 1,\n        pageSize: options.pageSize ?? 25,\n        search: options.search,\n        runType: options.runType,\n      },\n    });\n\n    return {\n      data: response.runs,\n      totalCount: response.totalCount,\n      pageCount: response.pageCount,\n      page: options.page ?? 1,\n      pageSize: options.pageSize ?? 25,\n    };\n  }\n\n  /**\n   * Find a test run by name using CLI lookup\n   */\n  async findTestRunByName(\n    projectId: number,\n    name: string\n  ): Promise<TestRun | undefined> {\n    try {\n      const result = await this.lookup({ projectId, type: \"testRun\", name });\n      return this.getTestRun(result.id);\n    } catch (error) {\n      if (error instanceof TestPlanItError && error.statusCode === 404) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // Configurations\n  // ============================================================================\n\n  /**\n   * List all configurations\n   */\n  async listConfigurations(projectId: number): Promise<Configuration[]> {\n    return this.zenstack<Configuration[]>(\"configurations\", \"findMany\", {\n      where: {\n        isDeleted: false,\n        isEnabled: true,\n      },\n    });\n  }\n\n  /**\n   * Find a configuration by name using CLI lookup\n   */\n  async findConfigurationByName(\n    projectId: number,\n    name: string\n  ): Promise<Configuration | undefined> {\n    try {\n      const result = await this.lookup({ type: \"config\", name });\n      return this.zenstack<Configuration>(\"configurations\", \"findUnique\", {\n        where: { id: result.id },\n      });\n    } catch (error) {\n      if (error instanceof TestPlanItError && error.statusCode === 404) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // Milestones\n  // ============================================================================\n\n  /**\n   * List all milestones for a project\n   */\n  async listMilestones(projectId: number): Promise<Milestone[]> {\n    return this.zenstack<Milestone[]>(\"milestones\", \"findMany\", {\n      where: {\n        projectId: projectId,\n        isDeleted: false,\n      },\n    });\n  }\n\n  /**\n   * Find a milestone by name using CLI lookup\n   */\n  async findMilestoneByName(\n    projectId: number,\n    name: string\n  ): Promise<Milestone | undefined> {\n    try {\n      const result = await this.lookup({ projectId, type: \"milestone\", name });\n      return this.zenstack<Milestone>(\"milestones\", \"findUnique\", {\n        where: { id: result.id },\n      });\n    } catch (error) {\n      if (error instanceof TestPlanItError && error.statusCode === 404) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // Workflow States\n  // ============================================================================\n\n  /**\n   * List all workflow states for a project (RUNS scope)\n   */\n  async listWorkflowStates(projectId: number): Promise<WorkflowState[]> {\n    return this.zenstack<WorkflowState[]>(\"workflows\", \"findMany\", {\n      where: {\n        isEnabled: true,\n        isDeleted: false,\n        scope: \"RUNS\",\n        projects: {\n          some: { projectId: projectId },\n        },\n      },\n      orderBy: { order: \"asc\" },\n    });\n  }\n\n  /**\n   * Find a workflow state by name using CLI lookup\n   */\n  async findWorkflowStateByName(\n    projectId: number,\n    name: string\n  ): Promise<WorkflowState | undefined> {\n    try {\n      const result = await this.lookup({ projectId, type: \"state\", name });\n      return this.zenstack<WorkflowState>(\"workflows\", \"findUnique\", {\n        where: { id: result.id },\n      });\n    } catch (error) {\n      if (error instanceof TestPlanItError && error.statusCode === 404) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  // ============================================================================\n  // Repository Folders\n  // ============================================================================\n\n  /**\n   * List all folders for a project\n   */\n  async listFolders(projectId: number): Promise<RepositoryFolder[]> {\n    return this.zenstack<RepositoryFolder[]>(\"repositoryFolders\", \"findMany\", {\n      where: {\n        projectId: projectId,\n        isDeleted: false,\n      },\n    });\n  }\n\n  /**\n   * Find a folder by name using CLI lookup\n   */\n  async findFolderByName(\n    projectId: number,\n    name: string\n  ): Promise<RepositoryFolder | undefined> {\n    try {\n      const result = await this.lookup({ projectId, type: \"folder\", name });\n      return this.zenstack<RepositoryFolder>(\n        \"repositoryFolders\",\n        \"findUnique\",\n        {\n          where: { id: result.id },\n        }\n      );\n    } catch (error) {\n      if (error instanceof TestPlanItError && error.statusCode === 404) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new folder\n   */\n  async createFolder(options: CreateFolderOptions): Promise<RepositoryFolder> {\n    // Get or create repository for the project\n    let repositories = await this.zenstack<{ id: number }[]>(\n      \"repositories\",\n      \"findMany\",\n      {\n        where: {\n          projectId: options.projectId,\n          isActive: true,\n          isDeleted: false,\n          isArchived: false,\n        },\n        take: 1,\n      }\n    );\n\n    let repositoryId: number;\n    if (repositories.length === 0) {\n      const newRepo = await this.zenstack<{ id: number }>(\n        \"repositories\",\n        \"create\",\n        {\n          data: {\n            project: { connect: { id: options.projectId } },\n            isActive: true,\n          },\n        }\n      );\n      repositoryId = newRepo.id;\n    } else {\n      repositoryId = repositories[0].id;\n    }\n\n    const data: Record<string, unknown> = {\n      name: options.name,\n      project: { connect: { id: options.projectId } },\n      repository: { connect: { id: repositoryId } },\n    };\n\n    if (options.parentId) {\n      data.parent = { connect: { id: options.parentId } };\n    }\n\n    return this.zenstack<RepositoryFolder>(\"repositoryFolders\", \"create\", {\n      data,\n    });\n  }\n\n  /**\n   * Find or create a folder hierarchy from a path\n   * @param projectId - The project ID\n   * @param folderPath - Array of folder names representing the path (e.g., ['Suite A', 'Suite B', 'Suite C'])\n   * @param rootFolderId - Optional root folder ID to start from\n   * @returns The final folder in the path\n   *\n   * @example\n   * // Create nested folders: \"Custom Text\" > \"ADM-649\" > \"@smoke\"\n   * const folder = await client.findOrCreateFolderPath(projectId, ['Custom Text', 'ADM-649', '@smoke']);\n   */\n  async findOrCreateFolderPath(\n    projectId: number,\n    folderPath: string[],\n    rootFolderId?: number\n  ): Promise<RepositoryFolder> {\n    if (folderPath.length === 0) {\n      throw new TestPlanItError(\"Folder path cannot be empty\");\n    }\n\n    // Get all folders for this project to enable efficient lookups\n    const allFolders = await this.listFolders(projectId);\n\n    let currentParentId: number | undefined = rootFolderId;\n    let currentFolder: RepositoryFolder | undefined;\n\n    for (const folderName of folderPath) {\n      // Look for existing folder with this name under the current parent\n      // Handle both null and undefined for parentId comparison\n      const existingFolder = allFolders.find((f) => {\n        const folderParentId = f.parentId ?? undefined;\n        return f.name === folderName && folderParentId === currentParentId;\n      });\n\n      if (existingFolder) {\n        currentFolder = existingFolder;\n        currentParentId = existingFolder.id;\n      } else {\n        // Create the folder - use try/catch to handle race conditions\n        // when multiple workers try to create the same folder simultaneously\n        try {\n          currentFolder = await this.createFolder({\n            projectId,\n            name: folderName,\n            parentId: currentParentId,\n          });\n          // Add to allFolders so subsequent iterations can find it\n          allFolders.push(currentFolder);\n        } catch (error) {\n          // If we get a unique constraint error, the folder was created by another worker\n          // Re-fetch folders and find the one that was just created\n          if (\n            error instanceof TestPlanItError &&\n            error.message?.includes(\"Unique constraint failed\")\n          ) {\n            const refreshedFolders = await this.listFolders(projectId);\n            const justCreatedFolder = refreshedFolders.find((f) => {\n              const folderParentId = f.parentId ?? undefined;\n              return (\n                f.name === folderName && folderParentId === currentParentId\n              );\n            });\n            if (justCreatedFolder) {\n              currentFolder = justCreatedFolder;\n              // Update allFolders with refreshed data\n              allFolders.length = 0;\n              allFolders.push(...refreshedFolders);\n            } else {\n              throw error; // Re-throw if we still can't find it\n            }\n          } else {\n            throw error;\n          }\n        }\n        currentParentId = currentFolder.id;\n      }\n    }\n\n    return currentFolder!;\n  }\n\n  // ============================================================================\n  // Templates\n  // ============================================================================\n\n  /**\n   * List all templates accessible to the user\n   * ZenStack access control handles permission filtering automatically\n   */\n  async listTemplates(projectId: number): Promise<Template[]> {\n    return this.zenstack<Template[]>(\"templates\", \"findMany\", {\n      where: {\n        isDeleted: false,\n        isEnabled: true,\n      },\n    });\n  }\n\n  /**\n   * Find a template by name (case-insensitive)\n   * Logs available templates if template not found for debugging\n   */\n  async findTemplateByName(\n    projectId: number,\n    name: string\n  ): Promise<Template | undefined> {\n    const templates = await this.listTemplates(projectId);\n\n    const normalizedName = name.toLowerCase().trim();\n    const found = templates.find(\n      (t) => t.templateName.toLowerCase().trim() === normalizedName\n    );\n\n    // Log error only when template not found\n    if (!found) {\n      if (templates.length === 0) {\n        console.error(\n          `[TestPlanIt API] Template \"${name}\" not found. No templates available. This may be a permissions issue - ensure the API token user has access to templates.`\n        );\n      } else {\n        const availableNames = templates.map((t) => t.templateName);\n        console.error(\n          `[TestPlanIt API] Template \"${name}\" not found. Available templates: ${availableNames.join(\n            \", \"\n          )}`\n        );\n      }\n    }\n\n    return found;\n  }\n\n  // ============================================================================\n  // Tags\n  // ============================================================================\n\n  /**\n   * List all tags\n   */\n  async listTags(projectId: number): Promise<Tag[]> {\n    return this.zenstack<Tag[]>(\"tags\", \"findMany\", {\n      where: {\n        isDeleted: false,\n      },\n    });\n  }\n\n  /**\n   * Create a new tag\n   */\n  async createTag(options: CreateTagOptions): Promise<Tag> {\n    return this.zenstack<Tag>(\"tags\", \"create\", {\n      data: {\n        name: options.name,\n      },\n    });\n  }\n\n  /**\n   * Find a tag by name using CLI lookup\n   */\n  async findTagByName(\n    projectId: number,\n    name: string\n  ): Promise<Tag | undefined> {\n    try {\n      const result = await this.lookup({ type: \"tag\", name });\n      return this.zenstack<Tag>(\"tags\", \"findUnique\", {\n        where: { id: result.id },\n      });\n    } catch (error) {\n      if (error instanceof TestPlanItError && error.statusCode === 404) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Find or create a tag by name using CLI lookup with createIfMissing\n   */\n  async findOrCreateTag(projectId: number, name: string): Promise<Tag> {\n    const result = await this.lookup({\n      type: \"tag\",\n      name,\n      createIfMissing: true,\n    });\n    return this.zenstack<Tag>(\"tags\", \"findUnique\", {\n      where: { id: result.id },\n    });\n  }\n\n  /**\n   * Resolve multiple tag IDs or names to numeric IDs\n   * If a tag name doesn't exist, it will be created automatically\n   */\n  async resolveTagIds(\n    projectId: number,\n    tagIdsOrNames: (number | string)[]\n  ): Promise<number[]> {\n    const resolvedIds: number[] = [];\n\n    for (const idOrName of tagIdsOrNames) {\n      if (typeof idOrName === \"number\") {\n        resolvedIds.push(idOrName);\n      } else {\n        const result = await this.lookup({\n          type: \"tag\",\n          name: idOrName,\n          createIfMissing: true,\n        });\n        resolvedIds.push(result.id);\n      }\n    }\n\n    return resolvedIds;\n  }\n\n  // ============================================================================\n  // Test Cases (Repository Cases)\n  // ============================================================================\n\n  /**\n   * Create a new test case in the repository\n   */\n  async createTestCase(\n    options: CreateTestCaseOptions\n  ): Promise<RepositoryCase> {\n    // Get or create repository for the project\n    let repositories = await this.zenstack<{ id: number }[]>(\n      \"repositories\",\n      \"findMany\",\n      {\n        where: {\n          projectId: options.projectId,\n          isActive: true,\n          isDeleted: false,\n          isArchived: false,\n        },\n        take: 1,\n      }\n    );\n\n    let repositoryId: number;\n    if (repositories.length === 0) {\n      const newRepo = await this.zenstack<{ id: number }>(\n        \"repositories\",\n        \"create\",\n        {\n          data: {\n            project: { connect: { id: options.projectId } },\n            isActive: true,\n          },\n        }\n      );\n      repositoryId = newRepo.id;\n    } else {\n      repositoryId = repositories[0].id;\n    }\n\n    // Get the workflow state - either provided or default for CASES scope\n    let stateId = options.stateId;\n    if (!stateId) {\n      const workflows = await this.zenstack<{ id: number }[]>(\n        \"workflows\",\n        \"findMany\",\n        {\n          where: {\n            isEnabled: true,\n            isDeleted: false,\n            scope: \"CASES\",\n            projects: {\n              some: { projectId: options.projectId },\n            },\n          },\n          orderBy: { order: \"asc\" },\n          take: 1,\n        }\n      );\n\n      if (workflows.length === 0) {\n        throw new TestPlanItError(\n          \"No workflow state found for test cases in this project\"\n        );\n      }\n      stateId = workflows[0].id;\n    }\n\n    // ZenStack REST API requires relation syntax (connect) instead of scalar FK fields\n    const data: Record<string, unknown> = {\n      name: options.name,\n      source: options.source ?? \"API\",\n      automated: options.automated ?? true,\n      project: { connect: { id: options.projectId } },\n      repository: { connect: { id: repositoryId } },\n      folder: { connect: { id: options.folderId } },\n      template: { connect: { id: options.templateId } },\n      state: { connect: { id: stateId } },\n    };\n    if (options.className) {\n      data.className = options.className;\n    }\n    if (options.estimate !== undefined) {\n      data.estimate = options.estimate;\n    }\n\n    return this.zenstack<RepositoryCase>(\"repositoryCases\", \"create\", { data });\n  }\n\n  /**\n   * Get a test case by ID\n   */\n  async getTestCase(caseId: number): Promise<RepositoryCase> {\n    return this.zenstack<RepositoryCase>(\"repositoryCases\", \"findUnique\", {\n      where: { id: caseId },\n    });\n  }\n\n  /**\n   * Find test cases matching criteria\n   */\n  async findTestCases(options: FindTestCaseOptions): Promise<RepositoryCase[]> {\n    return this.zenstack<RepositoryCase[]>(\"repositoryCases\", \"findMany\", {\n      where: {\n        projectId: options.projectId,\n        name: options.name,\n        className: options.className,\n        source: options.source,\n        isDeleted: false,\n      },\n    });\n  }\n\n  /**\n   * Find or create a test case\n   * First searches for an active (non-deleted) test case in an active folder, then creates if not found.\n   * If a matching case exists in a deleted folder, it will be moved to the specified folder.\n   *\n   * @returns Object containing the test case and an action indicating what happened:\n   *   - 'found': An existing test case was found in an active folder\n   *   - 'moved': A test case was found in a deleted folder and moved to the specified folder\n   *   - 'created': A new test case was created\n   */\n  async findOrCreateTestCase(\n    options: CreateTestCaseOptions\n  ): Promise<FindOrCreateTestCaseResult> {\n    // First, check for an existing ACTIVE test case (not deleted) in an ACTIVE folder\n    const existingCases = await this.zenstack<\n      (RepositoryCase & { folder?: { isDeleted: boolean } })[]\n    >(\"repositoryCases\", \"findMany\", {\n      where: {\n        projectId: options.projectId,\n        name: options.name,\n        className: options.className || \"\",\n        source: options.source ?? \"API\",\n        isDeleted: false,\n      },\n      include: {\n        folder: {\n          select: { isDeleted: true },\n        },\n      },\n      take: 10, // Get a few to check folder status\n    });\n\n    // Find a test case in an active (non-deleted) folder\n    const caseInActiveFolder = existingCases.find(\n      (c) => c.folder && !c.folder.isDeleted\n    );\n\n    if (caseInActiveFolder) {\n      // Found an active test case in an active folder\n      return { testCase: caseInActiveFolder, action: 'found' };\n    }\n\n    // Check if there's a test case in a deleted folder that we should move\n    const caseInDeletedFolder = existingCases.find(\n      (c) => c.folder && c.folder.isDeleted\n    );\n\n    if (caseInDeletedFolder) {\n      // Move the test case to the new folder\n      const movedCase = await this.zenstack<RepositoryCase>(\"repositoryCases\", \"update\", {\n        where: { id: caseInDeletedFolder.id },\n        data: {\n          folder: { connect: { id: options.folderId } },\n        },\n      });\n      return { testCase: movedCase, action: 'moved' };\n    }\n\n    // No active test case found, create a new one\n    // Get or create repository for the project\n    let repositories = await this.zenstack<{ id: number }[]>(\n      \"repositories\",\n      \"findMany\",\n      {\n        where: {\n          projectId: options.projectId,\n          isActive: true,\n          isDeleted: false,\n          isArchived: false,\n        },\n        take: 1,\n      }\n    );\n\n    let repositoryId: number;\n    if (repositories.length === 0) {\n      const newRepo = await this.zenstack<{ id: number }>(\n        \"repositories\",\n        \"create\",\n        {\n          data: {\n            project: { connect: { id: options.projectId } },\n            isActive: true,\n          },\n        }\n      );\n      repositoryId = newRepo.id;\n    } else {\n      repositoryId = repositories[0].id;\n    }\n\n    // Get the workflow state - either provided or default for CASES scope\n    let stateId = options.stateId;\n    if (!stateId) {\n      const workflows = await this.zenstack<{ id: number }[]>(\n        \"workflows\",\n        \"findMany\",\n        {\n          where: {\n            isEnabled: true,\n            isDeleted: false,\n            scope: \"CASES\",\n            projects: {\n              some: { projectId: options.projectId },\n            },\n          },\n          orderBy: { order: \"asc\" },\n          take: 1,\n        }\n      );\n\n      if (workflows.length === 0) {\n        throw new TestPlanItError(\n          \"No workflow state found for test cases in this project\"\n        );\n      }\n      stateId = workflows[0].id;\n    }\n\n    // ZenStack REST API requires relation syntax (connect) instead of scalar FK fields\n    const createData: Record<string, unknown> = {\n      name: options.name,\n      source: options.source ?? \"API\",\n      automated: options.automated ?? true,\n      project: { connect: { id: options.projectId } },\n      repository: { connect: { id: repositoryId } },\n      folder: { connect: { id: options.folderId } },\n      template: { connect: { id: options.templateId } },\n      state: { connect: { id: stateId } },\n    };\n    if (options.className) {\n      createData.className = options.className;\n    }\n    if (options.estimate !== undefined) {\n      createData.estimate = options.estimate;\n    }\n\n    // Use upsert to handle race conditions - if a deleted record exists with the same\n    // composite key, restore it and move to the new folder; otherwise create new\n    const createdCase = await this.zenstack<RepositoryCase>(\"repositoryCases\", \"upsert\", {\n      where: {\n        projectId_name_className_source: {\n          projectId: options.projectId,\n          name: options.name,\n          className: options.className || \"\",\n          source: options.source ?? \"API\",\n        },\n      },\n      update: {\n        automated: options.automated ?? true,\n        isDeleted: false,\n        isArchived: false,\n        // Also move to the new folder when restoring (in case old folder was deleted)\n        folder: { connect: { id: options.folderId } },\n      },\n      create: createData,\n    });\n    return { testCase: createdCase, action: 'created' };\n  }\n\n  // ============================================================================\n  // Test Run Cases (linking cases to runs)\n  // ============================================================================\n\n  /**\n   * Add a test case to a test run\n   */\n  async addTestCaseToRun(\n    options: AddTestCaseToRunOptions\n  ): Promise<TestRunCase> {\n    // ZenStack REST API requires relation syntax (connect) instead of scalar FK fields\n    const data: Record<string, unknown> = {\n      testRun: { connect: { id: options.testRunId } },\n      repositoryCase: { connect: { id: options.repositoryCaseId } },\n    };\n    if (options.assignedToId) {\n      data.assignedTo = { connect: { id: options.assignedToId } };\n    }\n    return this.zenstack<TestRunCase>(\"testRunCases\", \"create\", { data });\n  }\n\n  /**\n   * Get test run cases for a test run\n   */\n  async getTestRunCases(testRunId: number): Promise<TestRunCase[]> {\n    return this.zenstack<TestRunCase[]>(\"testRunCases\", \"findMany\", {\n      where: { testRunId: testRunId },\n    });\n  }\n\n  /**\n   * Find a test run case by repository case ID\n   */\n  async findTestRunCase(\n    testRunId: number,\n    repositoryCaseId: number\n  ): Promise<TestRunCase | undefined> {\n    const cases = await this.zenstack<TestRunCase[]>(\n      \"testRunCases\",\n      \"findMany\",\n      {\n        where: {\n          testRunId: testRunId,\n          repositoryCaseId: repositoryCaseId,\n        },\n        take: 1,\n      }\n    );\n    return cases[0];\n  }\n\n  /**\n   * Find or add a test case to a run\n   */\n  async findOrAddTestCaseToRun(\n    options: AddTestCaseToRunOptions\n  ): Promise<TestRunCase> {\n    // ZenStack REST API requires relation syntax (connect) instead of scalar FK fields\n    const createData: Record<string, unknown> = {\n      testRun: { connect: { id: options.testRunId } },\n      repositoryCase: { connect: { id: options.repositoryCaseId } },\n    };\n    if (options.assignedToId) {\n      createData.assignedTo = { connect: { id: options.assignedToId } };\n    }\n    return this.zenstack<TestRunCase>(\"testRunCases\", \"upsert\", {\n      where: {\n        testRunId_repositoryCaseId: {\n          testRunId: options.testRunId,\n          repositoryCaseId: options.repositoryCaseId,\n        },\n      },\n      update: {},\n      create: createData,\n    });\n  }\n\n  // ============================================================================\n  // Test Results\n  // ============================================================================\n\n  /**\n   * Create a test result\n   */\n  async createTestResult(\n    options: CreateTestResultOptions\n  ): Promise<TestRunResult> {\n    // ZenStack REST API requires relation syntax (connect) instead of scalar FK fields\n    const data: Record<string, unknown> = {\n      testRun: { connect: { id: options.testRunId } },\n      testRunCase: { connect: { id: options.testRunCaseId } },\n      status: { connect: { id: options.statusId } },\n      attempt: options.attempt ?? 1,\n    };\n    if (options.elapsed !== undefined) {\n      data.elapsed = options.elapsed;\n    }\n    if (options.notes) {\n      data.notes = options.notes;\n    }\n    if (options.evidence) {\n      data.evidence = options.evidence;\n    }\n    return this.zenstack<TestRunResult>(\"testRunResults\", \"create\", { data });\n  }\n\n  /**\n   * Get test results for a test run\n   */\n  async getTestResults(testRunId: number): Promise<TestRunResult[]> {\n    return this.zenstack<TestRunResult[]>(\"testRunResults\", \"findMany\", {\n      where: { testRunId: testRunId },\n    });\n  }\n\n  // ============================================================================\n  // Bulk Import\n  // ============================================================================\n\n  /**\n   * Import test results from files (JUnit, TestNG, etc.)\n   * Returns a stream of progress events\n   */\n  async importTestResults(\n    options: ImportTestResultsOptions,\n    onProgress?: (event: ImportProgressEvent) => void\n  ): Promise<{ testRunId: number }> {\n    const formData = new FormData();\n\n    // Add files\n    for (const file of options.files) {\n      formData.append(\"files\", file);\n    }\n\n    // Add options\n    formData.append(\"projectId\", String(options.projectId));\n    if (options.format) formData.append(\"format\", options.format);\n    if (options.testRunId)\n      formData.append(\"testRunId\", String(options.testRunId));\n    if (options.name) formData.append(\"name\", options.name);\n    if (options.configId) formData.append(\"configId\", String(options.configId));\n    if (options.milestoneId)\n      formData.append(\"milestoneId\", String(options.milestoneId));\n    if (options.stateId) formData.append(\"stateId\", String(options.stateId));\n    if (options.parentFolderId)\n      formData.append(\"parentFolderId\", String(options.parentFolderId));\n    if (options.templateId)\n      formData.append(\"templateId\", String(options.templateId));\n    if (options.tagIds) {\n      for (const tagId of options.tagIds) {\n        formData.append(\"tagIds\", String(tagId));\n      }\n    }\n\n    const url = new URL(\"/api/test-results/import\", this.baseUrl);\n\n    const response = await fetch(url.toString(), {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${this.apiToken}`,\n        ...this.headers,\n      },\n      body: formData,\n    });\n\n    if (!response.ok) {\n      const errorBody = await response.text();\n      throw new TestPlanItError(errorBody || `HTTP ${response.status}`, {\n        statusCode: response.status,\n      });\n    }\n\n    // Handle SSE response\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new TestPlanItError(\"No response body\");\n    }\n\n    const decoder = new TextDecoder();\n    let testRunId: number | undefined;\n    let buffer = \"\";\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split(\"\\n\");\n      // Keep the last potentially incomplete line in the buffer\n      buffer = lines.pop() || \"\";\n\n      for (const line of lines) {\n        if (!line.startsWith(\"data: \")) continue;\n        const data = line.slice(6); // Remove 'data: '\n        if (!data) continue;\n\n        const event = JSON.parse(data) as ImportProgressEvent;\n        onProgress?.(event);\n\n        if (event.complete && event.testRunId) {\n          testRunId = event.testRunId;\n        }\n\n        if (event.error) {\n          throw new TestPlanItError(event.error);\n        }\n      }\n    }\n\n    // Process any remaining data in the buffer\n    if (buffer.startsWith(\"data: \")) {\n      const data = buffer.slice(6);\n      if (data) {\n        const event = JSON.parse(data) as ImportProgressEvent;\n        onProgress?.(event);\n\n        if (event.complete && event.testRunId) {\n          testRunId = event.testRunId;\n        }\n\n        if (event.error) {\n          throw new TestPlanItError(event.error);\n        }\n      }\n    }\n\n    if (!testRunId) {\n      throw new TestPlanItError(\"Import completed but no test run ID returned\");\n    }\n\n    return { testRunId };\n  }\n\n  // ============================================================================\n  // Attachments\n  // ============================================================================\n\n  /**\n   * Upload file to storage\n   * Uses the /api/upload-attachment endpoint to upload to S3/MinIO\n   */\n  private async uploadFile(\n    file: Blob | Buffer,\n    fileName: string,\n    mimeType?: string,\n    prependString?: string\n  ): Promise<{ url: string; key: string }> {\n    const formData = new FormData();\n\n    if (file instanceof Buffer) {\n      formData.append(\"file\", new Blob([file], { type: mimeType }), fileName);\n    } else {\n      formData.append(\"file\", file, fileName);\n    }\n    if (prependString) {\n      formData.append(\"prependString\", prependString);\n    }\n\n    const response = await this.requestFormData<{\n      success: { url: string; key: string };\n    }>(\"POST\", \"/api/upload-attachment\", formData);\n\n    if (!response || !response.success || !response.success.url) {\n      throw new TestPlanItError(\n        \"Upload failed: API returned an empty or invalid response\"\n      );\n    }\n\n    return response.success;\n  }\n\n  /**\n   * Upload an attachment to a test run result (for regular test runs)\n   * Uploads the file to storage and creates an Attachment record\n   */\n  async uploadAttachment(\n    testRunResultId: number,\n    file: Blob | Buffer,\n    fileName: string,\n    mimeType?: string\n  ): Promise<Attachment> {\n    // Step 1: Upload file to storage\n    const { url } = await this.uploadFile(\n      file,\n      fileName,\n      mimeType,\n      `result_${testRunResultId}`\n    );\n\n    // Step 2: Create attachment record\n    const size = Buffer.isBuffer(file) ? file.length : file.size;\n    const data: Record<string, unknown> = {\n      url,\n      name: fileName,\n      mimeType: mimeType || \"application/octet-stream\",\n      size,\n      testRunResults: { connect: { id: testRunResultId } },\n    };\n\n    return this.zenstack<Attachment>(\"attachments\", \"create\", { data });\n  }\n\n  /**\n   * Upload an attachment to a JUnit test result (for automated test runs)\n   * Uploads the file to storage and creates an Attachment record linked to the JUnit result\n   */\n  async uploadJUnitAttachment(\n    junitTestResultId: number,\n    file: Blob | Buffer,\n    fileName: string,\n    mimeType?: string,\n    note?: string\n  ): Promise<Attachment> {\n    // Step 1: Upload file to storage\n    const { url } = await this.uploadFile(\n      file,\n      fileName,\n      mimeType,\n      `junit_${junitTestResultId}`\n    );\n\n    // Step 2: Create attachment record linked to JUnit result\n    // Uses dedicated endpoint that handles BigInt conversion for size field\n    const size = Buffer.isBuffer(file) ? file.length : file.size;\n    const response = await this.request<{ data: Attachment }>(\n      \"POST\",\n      \"/api/junit/attachment\",\n      {\n        body: {\n          junitTestResultId,\n          url,\n          name: fileName,\n          mimeType: mimeType || \"application/octet-stream\",\n          size,\n          note,\n        },\n      }\n    );\n\n    return response.data;\n  }\n\n  // ============================================================================\n  // JUnit Test Results (for automated test runs)\n  // ============================================================================\n\n  /**\n   * Create a JUnit test suite\n   * Used for storing test results from automated test frameworks (Mocha, JUnit, etc.)\n   */\n  async createJUnitTestSuite(\n    options: CreateJUnitTestSuiteOptions\n  ): Promise<JUnitTestSuite> {\n    const data: Record<string, unknown> = {\n      name: options.name,\n      testRun: { connect: { id: options.testRunId } },\n    };\n\n    if (options.time !== undefined) data.time = options.time;\n    if (options.tests !== undefined) data.tests = options.tests;\n    if (options.failures !== undefined) data.failures = options.failures;\n    if (options.errors !== undefined) data.errors = options.errors;\n    if (options.skipped !== undefined) data.skipped = options.skipped;\n    if (options.assertions !== undefined) data.assertions = options.assertions;\n    if (options.timestamp) data.timestamp = options.timestamp;\n    if (options.file) data.file = options.file;\n    if (options.systemOut) data.systemOut = options.systemOut;\n    if (options.systemErr) data.systemErr = options.systemErr;\n    if (options.parentId) data.parent = { connect: { id: options.parentId } };\n\n    return this.zenstack<JUnitTestSuite>(\"jUnitTestSuite\", \"create\", { data });\n  }\n\n  /**\n   * Create a JUnit test result\n   * Used for storing individual test case results within a test suite\n   */\n  async createJUnitTestResult(\n    options: CreateJUnitTestResultOptions\n  ): Promise<JUnitTestResult> {\n    const data: Record<string, unknown> = {\n      type: options.type,\n      testSuite: { connect: { id: options.testSuiteId } },\n      repositoryCase: { connect: { id: options.repositoryCaseId } },\n    };\n\n    if (options.message) data.message = options.message;\n    if (options.content) data.content = options.content;\n    if (options.statusId) data.status = { connect: { id: options.statusId } };\n    if (options.executedAt) data.executedAt = options.executedAt;\n    if (options.time !== undefined) data.time = options.time;\n    if (options.assertions !== undefined) data.assertions = options.assertions;\n    if (options.file) data.file = options.file;\n    if (options.line !== undefined) data.line = options.line;\n    if (options.systemOut) data.systemOut = options.systemOut;\n    if (options.systemErr) data.systemErr = options.systemErr;\n\n    return this.zenstack<JUnitTestResult>(\"jUnitTestResult\", \"create\", {\n      data,\n    });\n  }\n\n  /**\n   * Update a JUnit test suite\n   * Used to update statistics (tests, failures, errors, skipped, time) after all results are reported\n   */\n  async updateJUnitTestSuite(\n    testSuiteId: number,\n    options: UpdateJUnitTestSuiteOptions\n  ): Promise<JUnitTestSuite> {\n    const data: Record<string, unknown> = {};\n\n    if (options.time !== undefined) data.time = options.time;\n    if (options.tests !== undefined) data.tests = options.tests;\n    if (options.failures !== undefined) data.failures = options.failures;\n    if (options.errors !== undefined) data.errors = options.errors;\n    if (options.skipped !== undefined) data.skipped = options.skipped;\n    if (options.assertions !== undefined) data.assertions = options.assertions;\n    if (options.systemOut) data.systemOut = options.systemOut;\n    if (options.systemErr) data.systemErr = options.systemErr;\n\n    return this.zenstack<JUnitTestSuite>(\"jUnitTestSuite\", \"update\", {\n      where: { id: testSuiteId },\n      data,\n    });\n  }\n\n  /**\n   * Get JUnit test suites for a test run\n   */\n  async getJUnitTestSuites(testRunId: number): Promise<JUnitTestSuite[]> {\n    return this.zenstack<JUnitTestSuite[]>(\"jUnitTestSuite\", \"findMany\", {\n      where: { testRunId },\n      orderBy: { id: \"asc\" },\n    });\n  }\n\n  /**\n   * Get JUnit test results for a test suite\n   */\n  async getJUnitTestResults(testSuiteId: number): Promise<JUnitTestResult[]> {\n    return this.zenstack<JUnitTestResult[]>(\"jUnitTestResult\", \"findMany\", {\n      where: { testSuiteId },\n      orderBy: { id: \"asc\" },\n    });\n  }\n\n  // ============================================================================\n  // Utilities\n  // ============================================================================\n\n  /**\n   * Test the API connection by listing projects\n   */\n  async testConnection(): Promise<boolean> {\n    try {\n      await this.listProjects();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get the base URL\n   */\n  getBaseUrl(): string {\n    return this.baseUrl;\n  }\n}\n"]}